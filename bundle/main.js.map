{"version":3,"file":"main.js","mappings":";;;;;;;;;;AAAa;;AAEb,8CAA6C,EAAE,aAAa,EAAC;;AAE7D,kBAAkB,mBAAO,CAAC,oDAAW;AACrC,sBAAsB,mBAAO,CAAC,8DAAgB;;AAE9C;AACA,aAAa,iCAAiC;AAC9C,aAAa,0BAA0B;AACvC,aAAa,mCAAmC;AAChD;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,iBAAiB;AAC5B,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;ACvGA,+HAAoD;;;;;;;;;;;;ACAvC;;AAEb,kBAAkB,mBAAO,CAAC,+DAAiB;AAC3C,gBAAgB,mBAAO,CAAC,2DAAe;AACvC,eAAe,mBAAO,CAAC,yDAAc;AACrC,cAAc,mBAAO,CAAC,uDAAa;;AAEnC;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM,KAAK,eAAe,IAAI;AACtD,wBAAwB,MAAM,KAAK;AACnC;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;;AAEA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI;AACpC,yCAAyC,OAAO,IAAI;AACpD;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,UAAU,MAAM,EAAE,MAAM;AACrE;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzKa;;AAEb,aAAa,mBAAO,CAAC,sDAAY;AACjC,cAAc,mBAAO,CAAC,mDAAS;;AAE/B,kCAAkC;AAClC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,wCAAwC;;AAE1E;AACA,yDAAyD,MAAM;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxDa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxDa;;AAEb,aAAa,mBAAO,CAAC,sDAAY;AACjC,kBAAkB,mBAAO,CAAC,2DAAa;AACvC,cAAc,mBAAO,CAAC,mDAAS;;AAE/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uDAAuD,EAAE,KAAK;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,iEAAiE,EAAE,KAAK;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;;AAEA,+BAA+B;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChHa;;AAEb,kBAAkB,mBAAO,CAAC,2DAAa;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,2DAAa;;AAEzB;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,aAAa,6BAA6B,IAAI;AACzF;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,aAAa;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,sEAAsE;AACnF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,0BAA0B;AAC/C;AACA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,aAAa;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE;;AAEA,aAAa,sBAAsB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,qBAAqB;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,qBAAqB;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,SAAS,aAAa;AACtB;AACA;;AAEA;;;;;;;;;;;;AC5Ua;;AAEb,cAAc,mBAAO,CAAC,mDAAS;;AAE/B,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC9Ba;;AAEb,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,yBAAyB;AACrD,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;;;;;;;;;;AC3Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;;;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,uBAAuB,mBAAO,CAAC,+EAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe,UAAU,GAAG,OAAO,sBAAsB;AAC9G,qCAAqC,WAAW,GAAG,UAAU,GAAG,iBAAiB;AACjF;AACA;AACA;AACA;AACA;AACA,2GAA2G,8EAA8E;AACzL;AACA;AACA,sCAAsC,cAAc,YAAY,QAAQ;AACxE;AACA;AACA,sCAAsC,cAAc,YAAY,QAAQ;AACxE;AACA;AACA,sCAAsC,cAAc;AACpD;AACA,SAAS;AACT;AACA;AACA,sCAAsC,cAAc,YAAY,QAAQ;AACxE;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;;AC9Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,+BAA+B,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,2BAA2B,GAAG,sCAAsC,GAAG,oBAAoB,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,uBAAuB;AAC7Q,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,gBAAgB,mBAAO,CAAC,gDAAO;AAC/B,aAAa,mBAAO,CAAC,cAAI;AACzB,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,cAAc,mBAAO,CAAC,gBAAK;AAC3B,4BAA4B,mBAAO,CAAC,yFAAqB;AACzD,gBAAgB,mBAAO,CAAC,iEAAS;AACjC,oCAAoC,mBAAO,CAAC,yGAA6B;AACzE;AACA;AACA,uDAAuD,qBAAqB,EAAE,uBAAuB;AACrG;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gDAAgD;AACrG;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB,EAAE,uBAAuB,qBAAqB,2BAA2B;AAC7H;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB,OAAO,6BAA6B,IAAI,iBAAiB,EAAE,mBAAmB,aAAa,OAAO,EAAE;;AAErL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,yBAAyB,OAAO,6BAA6B,IAAI,iBAAiB,EAAE,mBAAmB,aAAa,OAAO,EAAE;;AAE7L;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uEAAuE,UAAU,2BAA2B,cAAc;AAC1H;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,+DAA+D,oCAAoC,IAAI,wBAAwB,EAAE,oBAAoB,YAAY,oBAAoB,IAAI,uBAAuB;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,yEAAyE,YAAY;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB,8BAA8B,cAAc,QAAQ,aAAa;AACvH;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,0DAA0D,MAAM,UAAU,YAAY;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,2GAA2G,MAAM;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;;;;;;;;;;;ACnca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,eAAe,GAAG,qCAAqC,GAAG,uCAAuC,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,iCAAiC,GAAG,YAAY,GAAG,eAAe,GAAG,iBAAiB,GAAG,gCAAgC,GAAG,2BAA2B,GAAG,iBAAiB,GAAG,yBAAyB,GAAG,sCAAsC,GAAG,+BAA+B,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,oBAAoB,GAAG,uBAAuB,GAAG,iBAAiB,GAAG,yBAAyB,GAAG,yBAAyB;AAC9lB,0BAA0B,mBAAO,CAAC,yFAAqB;AACvD,qDAAoD,EAAE,qCAAqC,iDAAiD,EAAC;AAC7I,qDAAoD,EAAE,qCAAqC,iDAAiD,EAAC;AAC7I,qBAAqB,mBAAO,CAAC,+EAAgB;AAC7C,6CAA4C,EAAE,qCAAqC,oCAAoC,EAAC;AACxH,mDAAkD,EAAE,qCAAqC,0CAA0C,EAAC;AACpI,gDAA+C,EAAE,qCAAqC,uCAAuC,EAAC;AAC9H,mDAAkD,EAAE,qCAAqC,0CAA0C,EAAC;AACpI,iDAAgD,EAAE,qCAAqC,wCAAwC,EAAC;AAChI,2DAA0D,EAAE,qCAAqC,kDAAkD,EAAC;AACpJ,kEAAiE,EAAE,qCAAqC,yDAAyD,EAAC;AAClK,qDAAoD,EAAE,qCAAqC,4CAA4C,EAAC;AACxI,6CAA4C,EAAE,qCAAqC,oCAAoC,EAAC;AACxH,uDAAsD,EAAE,qCAAqC,8CAA8C,EAAC;AAC5I,uBAAuB,mBAAO,CAAC,mFAAkB;AACjD,4DAA2D,EAAE,qCAAqC,qDAAqD,EAAC;AACxJ,6CAA4C,EAAE,qCAAqC,sCAAsC,EAAC;AAC1H,sBAAsB,mBAAO,CAAC,iFAAiB;AAC/C,2CAA0C,EAAE,qCAAqC,mCAAmC,EAAC;AACrH,aAAa,mBAAO,CAAC,+DAAQ;AAC7B,wCAAuC,EAAE,qCAAqC,uBAAuB,EAAC;AACtG,kCAAkC,mBAAO,CAAC,yGAA6B;AACvE,6DAA4D,EAAE,qCAAqC,iEAAiE,EAAC;AACrK,YAAY,mBAAO,CAAC,6DAAO;AAC3B,4CAA2C,EAAE,qCAAqC,0BAA0B,EAAC;AAC7G,4CAA2C,EAAE,qCAAqC,0BAA0B,EAAC;AAC7G;AACA,uCAAuC;AACvC;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;;ACnDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,iBAAiB;AACpD;AACA;AACA,cAAc,4BAA4B,KAAK,4BAA4B;AAC3E;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA,gCAAgC;AAChC;AACA;AACA;AACA,iBAAiB,iBAAiB,GAAG,eAAe;AACpD;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA,gCAAgC,eAAe,iBAAiB,eAAe;AAC/E;AACA;AACA;AACA,yBAAyB,eAAe,MAAM,eAAe;AAC7D;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa,GAAG,eAAe;AAChE;AACA;;;;;;;;;;;AC9Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;;;;AChFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW,GAAG,YAAY;AAC1B,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,gBAAgB,mBAAO,CAAC,iEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc,EAAE,gBAAgB;AACxD;AACA;AACA;AACA;AACA,4BAA4B,EAAE,WAAW,EAAE,EAAE,EAAE,WAAW,GAAG;AAC7D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvMa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,gBAAgB;AACnC,YAAY,mBAAO,CAAC,0CAAK;AACzB,gBAAgB,mBAAO,CAAC,iEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,KAAK;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;;AC5Ga;;AAEb,QAAQ,eAAe,EAAE,mBAAO,CAAC,sBAAQ;AACzC,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B,QAAQ,YAAY,EAAE,mBAAO,CAAC,kBAAM;AACpC,iBAAiB,mBAAO,CAAC,kDAAU;AACnC,iBAAiB,oFAA2B;AAC5C,mBAAmB,mBAAO,CAAC,wDAAa;AACxC,eAAe,mBAAO,CAAC,gDAAS;AAChC,eAAe,mBAAO,CAAC,8CAAQ;AAC/B,sBAAsB,mBAAO,CAAC,8DAAgB;;AAE9C,sBAAsB,mBAAO,CAAC,2EAAsB;AACpD,wBAAwB,mBAAO,CAAC,+EAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,iEAAiB;;AAE7B;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,0EAA0E;AACvF,aAAa,2CAA2C;AACxD;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,cAAc,gBAAgB;AAC9B,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB,cAAc,UAAU;AACxB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,8DAA8D,MAAM;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,WAAW;AACzB;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA,yCAAyC;;AAEzC,aAAa,uBAAuB;AACpC;AACA,aAAa,oBAAoB;AACjC;AACA,aAAa,aAAa;AAC1B;;AAEA,aAAa,wBAAwB;AACrC;;AAEA,aAAa,2BAA2B;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,SAAS,kBAAkB;AACtC,WAAW,UAAU,mBAAmB;AACxC,aAAa,WAAW;AACxB;AACA;AACA,SAAS,sBAAsB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,SAAS,KAAK;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,MAAM;AACjB,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAmB;AAChC;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;;;;;;;;;;;;AC77BA;;AAEb,OAAO,KAAK,EAAE,mBAAO,CAAC,kBAAM;AAC5B,OAAO,UAAU;;AAEjB,cAAc;AACd,gBAAgB;AAChB,cAAc;AACd,iBAAiB;AACjB,kBAAkB;AAClB,iBAAiB;AACjB,qBAAqB;AACrB,cAAc;AACd,gBAAgB;;AAEhB,gBAAgB;AAChB,eAAe;AACf,iBAAiB;;AAEjB,uBAAuB;AACvB,wBAAwB;AACxB,uBAAuB;AACvB,qBAAqB;AACrB,sBAAsB;AACtB,uBAAuB;AACvB,yBAAyB;AACzB,8BAA8B;AAC9B,4BAA4B;;AAE5B,qBAAqB;AACrB,eAAe;AACf,eAAe;AACf,oBAAoB;;AAEpB,iBAAiB,OAAO,IAAI;;AAE5B,qBAAqB;AACrB,uBAAuB;AACvB,8BAA8B;AAC9B,cAAc;AACd,mBAAmB;;AAEnB,aAAa;AACb,mBAAmB;AACnB,mBAAmB,KAAK;AACxB,YAAY;AACZ,eAAe;AACf,gBAAgB;AAChB,YAAY;AACZ,gBAAgB;AAChB,qBAAqB;AACrB,sBAAsB;AACtB,kBAAkB;AAClB,qBAAqB,IAAI;AACzB,mBAAmB;AACnB,qBAAqB;AACrB,iBAAiB;AACjB,gBAAgB;AAChB,mBAAmB;;AAEnB,iBAAiB;AACjB,eAAe;AACf,eAAe;;;;;;;;;;;;AC9DF;;AAEb,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B,QAAQ,YAAY,EAAE,mBAAO,CAAC,kBAAM;;AAEpC;AACA;AACA,aAAa,mBAAO,CAAC,uIAAU;AAC/B,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAa;;AAEzB,2CAA2C,GAAG;;AAE9C;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,eAAe;AAC7B,cAAc,UAAU;AACxB,eAAe,iBAAiB;AAChC;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,UAAU;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB;;;;;;;;;;;;AC3gBR;;AAEb,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B,QAAQ,YAAY,EAAE,mBAAO,CAAC,kBAAM;AACpC,qBAAqB,mBAAO,CAAC,8DAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAa;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,KAAK;AACnB,cAAc,eAAe;AAC7B,cAAc,UAAU;AACxB;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,SAAS,kCAAkC;AAC3C;;AAEA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA,SAAS,sBAAsB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA,OAAO;;AAEP;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;ACpoBA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAA4C;;AAEvD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,oDAAU;;AAEnC,OAAO,YAAY;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;AC3QA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,sCAAI;AACpC;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACjRA;AACA;AACA;AACA;;AAEA;AACA,CAAC,+FAAwC;AACzC,EAAE;AACF,CAAC,yFAAqC;AACtC;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,gBAAK;AACzB,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;;AAEA,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,8DAAgB;;AAE/C;AACA,EAAE,cAAc;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,4BAA4B;;AAEpC;AACA;AACA,iDAAiD,EAAE;AACnD,sBAAsB,WAAW,IAAI,MAAM;;AAE3C;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,oDAAU;;AAEnC,OAAO,YAAY;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtQa;;AAEb;AACA,6CAA6C,EAAE,EAAE;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;ACpBa;AACb,OAAO,oBAAoB,EAAE,mBAAO,CAAC,0BAAU;AAC/C,sBAAsB,mBAAO,CAAC,gFAAyB;AACvD,eAAe,mBAAO,CAAC,gFAAyB;AAChD,OAAO,YAAY,EAAE,mBAAO,CAAC,gHAAyC;AACtE,eAAe,mBAAO,CAAC,gDAAO;;AAE9B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;;AAExB,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B,OAAO,oBAAoB,MAAM;AAC/D,aAAa,sBAAsB;AACnC;AACA,wBAAwB,YAAY;AACpC;;AAEA;AACA;;AAEA,uBAAuB,YAAY;AACnC;AACA;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA,YAAY,sBAAsB;AAClC,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,mCAAmC,aAAa,YAAY,WAAW;AACvE;;AAEA,UAAU,aAAa;;AAEvB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,qCAAqC,aAAa,YAAY,WAAW;;AAEzE;;AAEA,UAAU,aAAa;;AAEvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnUa;;AAEb;AACA;AACA;;AAEA,kBAAkB,mBAAO,CAAC,qEAAe;AACzC,kBAAkB,mBAAO,CAAC,gCAAa;;AAEvC;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9Fa;;AAEb;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA;AACA;AACA,aAAa,mBAAO,CAAC,0BAAU;AAC/B,EAAE;AACF;AACA;;AAEA,SAAS,mBAAO,CAAC,cAAI;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,KAAsC;AAC/C,OAAO,CAAmC;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B,YAAY,OAAO;AAChE;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;ACpOa;;AAEb,kBAAkB,mBAAO,CAAC,qEAAe;AACzC,kBAAkB,mBAAO,CAAC,qEAAe;AACzC,UAAU,mBAAO,CAAC,qDAAO;AACzB,mBAAmB,mBAAO,CAAC,yDAAS;AACpC,uBAAuB,mBAAO,CAAC,mFAAsB;AACrD,oBAAoB,mBAAO,CAAC,mFAAmB;AAC/C,mBAAmB,mBAAO,CAAC,2EAAkB;AAC7C,sBAAsB,mBAAO,CAAC,iFAAqB;;AAEnD;AACA,yBAAsB;;AAEtB;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,OAAO,eAAe;;AAEtB;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa;AACnE;AACA,KAAK;AACL,GAAG;;AAEH;AACA,uBAAuB;AACvB;;AAEA,gDAAgD,eAAe;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;ACpFa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACrEa;;AAEb,UAAU,gFAAoB;;AAE9B;;AAEA;AACA,WAAW,yBAAyB;AACpC,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACvEa;;AAEb,aAAa,mBAAO,CAAC,qEAAU;AAC/B,YAAY,mBAAO,CAAC,mEAAS;AAC7B,eAAe,mBAAO,CAAC,yEAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,aAAa,YAAY;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;ACnDa;;AAEb,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,mBAAmB;AAC/C,4BAA4B,oCAAoC;AAChE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACvKa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,WAAW;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;AC1Ea;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,EAAE;AACjB,eAAe,IAAI;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,6CAA6C;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA,iCAAiC,MAAM;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA,yCAAyC,MAAM;AAC/C,gCAAgC,MAAM;AACtC,gCAAgC,MAAM;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,KAAK;AACpD;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,KAAK;AAC7C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC9Ja;;AAEb;;AAEA,gBAAgB,mBAAO,CAAC,wEAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,4BAA4B;;AAE5B;AACA;AACA,eAAe,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,MAAM,sBAAsB,KAAK;AAChE,cAAc,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,OAAO,GAAG,KAAK;AAC7C,YAAY,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,OAAO,GAAG,KAAK;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7Ga;;AAEb,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;;AAEA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACnWa;;AAEb,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,gBAAgB,mBAAO,CAAC,2EAAiB;AACzC,mBAAmB,2GAA8B;AACjD,gBAAgB,mBAAO,CAAC,iFAAa;;AAErC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,MAAM,EAAE,QAAQ,KAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,wBAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,+BAA+B;AAC/B;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnMa;;AAEb;;AAEA,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,uBAAuB,4CAAY,IAAI,4CAAY;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,WAAW,WAAW;AACtB,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACjGa;;AAEb,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,kBAAkB,mBAAO,CAAC,yEAAmB;AAC7C,kBAAkB,mBAAO,CAAC,qFAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACtHa;;AAEb,gBAAgB,mBAAO,CAAC,wEAAc;AACtC,kBAAkB,mBAAO,CAAC,sEAAgB;AAC1C,UAAU,mBAAO,CAAC,yDAAW;;AAE7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;;;;;;;;;;;ACzCa;;AAEb,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,UAAU,mBAAO,CAAC,gBAAK;AACvB,gBAAgB,mBAAO,CAAC,wEAAc;;AAEtC;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACvFa;AACb;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,iCAAiC,mBAAO,CAAC,0BAAU;AACnD,2BAA2B,mBAAO,CAAC,cAAI;AACvC,+BAA+B,mBAAO,CAAC,8CAAQ;AAC/C,6BAA6B,mBAAO,CAAC,kBAAM;AAC3C,0CAA0C,mBAAO,CAAC,oEAAmB;AACrE,mCAAmC,mBAAO,CAAC,sDAAY;AACvD,mCAAmC,mBAAO,CAAC,sDAAY;AACvD,mCAAmC,mBAAO,CAAC,sDAAY;AACvD,qCAAqC,mBAAO,CAAC,0DAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,mBAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9jBY;;AAEZ,WAAW,mBAAO,CAAC,8DAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,mBAAmB,8HAA+B;AAClD,yBAAyB,wIAA0C;AACnE,aAAa,mBAAO,CAAC,4FAAc;;AAEnC;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;;AAEA,UAAU,oBAAoB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6EAA6E,IAAI;AACjF,yEAAyE,IAAI;AAC7E,mCAAmC,IAAI;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,wBAAwB,KAAK;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,kCAAkC,aAAa;AACjG;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,UAAU,YAAY;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxKY;;AAEZ,WAAW,mBAAO,CAAC,8DAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,0HAA2B;AAC1C,mBAAmB,wIAAoC;AACvD,qBAAqB,oIAAsC;AAC3D,aAAa,mBAAO,CAAC,4FAAc;;AAEnC;AACA;AACA;AACA;AACA,IAAI;AACJ,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mFAAmF,IAAI;AACvF,+EAA+E,IAAI;AACnF,yCAAyC,IAAI;AAC7C,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,4BAA4B,KAAK;AACjC,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,kCAAkC,aAAa;AACzG;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,aAAa,UAAU,YAAY;AACtF;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;AC1OY;;AAEZ,UAAU,4HAAoC;AAC9C;AACA,UAAU,mBAAO,CAAC,sFAAQ;AAC1B,YAAY,mBAAO,CAAC,gGAAa;AACjC;;;;;;;;;;;;ACNY;;AAEZ,UAAU,2HAAmC;AAC7C,WAAW,mBAAO,CAAC,oFAAO;AAC1B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,4FAAW;AACjC,eAAe,mBAAO,CAAC,4FAAW;;AAElC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtCY;;AAEZ,UAAU,4HAAoC;AAC9C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,8DAAa;AAChC,cAAc,mBAAO,CAAC,4FAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACpEY;;AAEZ,QAAQ,6BAA6B,EAAE,mBAAO,CAAC,wFAAQ;AACvD,QAAQ,6BAA6B,EAAE,mBAAO,CAAC,wFAAQ;AACvD,QAAQ,mCAAmC,EAAE,mBAAO,CAAC,8FAAW;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBY;;AAEZ,UAAU,4HAAoC;AAC9C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,8DAAa;AAChC,cAAc,mBAAO,CAAC,4FAAW;AACjC,mBAAmB,wIAAoC;AACvD,QAAQ,eAAe,EAAE,mBAAO,CAAC,4FAAc;;AAE/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC/DY;;AAEZ,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,8DAAa;AAChC,mBAAmB,wIAAoC;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AClGY;;AAEZ,WAAW,mBAAO,CAAC,8DAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC9BY;;AAEZ,UAAU,4HAAoC;AAC9C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,oFAAO;AAC1B,gBAAgB,mBAAO,CAAC,4FAAW;AACnC;AACA;;AAEA,sBAAsB,mBAAO,CAAC,0GAAiB;AAC/C;AACA;;AAEA,qBAAqB,mBAAO,CAAC,wGAAgB;AAC7C;AACA;;AAEA,mBAAmB,wIAAoC;;AAEvD,QAAQ,eAAe,EAAE,mBAAO,CAAC,4FAAc;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACjFY;AACZ;AACA;AACA,UAAU,4HAAoC;AAC9C,WAAW,mBAAO,CAAC,8DAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,cAAc;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA,EAAE,uBAAuB;AACzB,EAAE;AACF;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/HY;;AAEZ;AACA;AACA,KAAK,mBAAO,CAAC,mFAAM;AACnB;AACA,KAAK,mBAAO,CAAC,uFAAQ;AACrB,KAAK,mBAAO,CAAC,yFAAS;AACtB,KAAK,mBAAO,CAAC,2FAAU;AACvB,KAAK,mBAAO,CAAC,uFAAQ;AACrB,KAAK,mBAAO,CAAC,2FAAU;AACvB,KAAK,mBAAO,CAAC,uFAAQ;AACrB,KAAK,mBAAO,CAAC,qGAAe;AAC5B,KAAK,mBAAO,CAAC,qGAAe;AAC5B,KAAK,mBAAO,CAAC,2FAAU;AACvB;;;;;;;;;;;;ACfY;;AAEZ,UAAU,2HAAmC;AAC7C,iBAAiB,mBAAO,CAAC,8FAAY;;AAErC,wBAAwB,mBAAO,CAAC,oGAAe;AAC/C,0BAA0B,mBAAO,CAAC,8GAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfY;;AAEZ,iBAAiB,mBAAO,CAAC,gFAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVY;;AAEZ,QAAQ,YAAY,EAAE,mBAAO,CAAC,sFAAgB;AAC9C,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,sGAAgB;;AAEnD;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACXY;;AAEZ,QAAQ,YAAY,EAAE,mBAAO,CAAC,sFAAgB;AAC9C,QAAQ,aAAa,EAAE,mBAAO,CAAC,sGAAgB;;AAE/C,mDAAmD;AACnD;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACXY;AACZ,UAAU,2HAAmC;AAC7C,QAAQ,iCAAiC,EAAE,mBAAO,CAAC,gGAAY;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbY;AACZ,WAAW,mBAAO,CAAC,oFAAO;AAC1B,QAAQ,YAAY,EAAE,mBAAO,CAAC,0FAAS;;AAEvC;AACA,qBAAqB;AACrB;AACA,YAAY,yBAAyB;AACrC;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACY;AACZ,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA,mEAAmE,IAAI;AACvE;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpBY;;AAEZ,UAAU,4HAAoC;AAC9C;AACA,UAAU,mBAAO,CAAC,sFAAQ;AAC1B,YAAY,mBAAO,CAAC,gGAAa;AACjC;;;;;;;;;;;;ACNY;;AAEZ,WAAW,mBAAO,CAAC,8DAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,iBAAiB,wHAA2B;AAC5C,mBAAmB,8HAA+B;AAClD,mBAAmB,8HAA+B;AAClD,aAAa,mBAAO,CAAC,4FAAc;;AAEnC;AACA;AACA;;AAEA,UAAU,kCAAkC;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrDY;;AAEZ,WAAW,mBAAO,CAAC,8DAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,aAAa,oHAAuB;AACpC,eAAe,0HAA2B;AAC1C,eAAe,0HAA2B;AAC1C,mBAAmB,wIAAoC;AACvD,aAAa,mBAAO,CAAC,4FAAc;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;AC1EY;;AAEZ,UAAU,4HAAoC;AAC9C,WAAW,mBAAO,CAAC,8DAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,4FAAW;AACjC,mBAAmB,wIAAoC;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACvCY;AACZ,UAAU,2HAAmC;AAC7C,WAAW,mBAAO,CAAC,oFAAO;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACXY;;AAEZ,WAAW,mBAAO,CAAC,8DAAa;AAChC,UAAU,4HAAoC;AAC9C,eAAe,mBAAO,CAAC,4FAAU;;AAEjC;AACA;AACA,kCAAkC,8BAA8B;AAChE;AACA;;AAEA;AACA;AACA,0CAA0C,8BAA8B;AACxE;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACrBY;;AAEZ,WAAW,mBAAO,CAAC,8DAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC7SY;;AAEZ,WAAW,mBAAO,CAAC,oFAAO;AAC1B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA,gCAAgC,cAAc;AAC9C,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sCAAsC,mBAAmB;AACzD;;AAEA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD,qCAAqC,cAAc;AACnD;AACA;AACA;AACA,IAAI;AACJ,wCAAwC;AACxC;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA,+DAA+D,KAAK,oBAAoB,IAAI;AAC5F;AACA;AACA,2DAA2D,KAAK,wBAAwB,IAAI;AAC5F;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC,GAAG;AACH;;AAEA;AACA,UAAU,oBAAoB;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yDAAyD,KAAK,oBAAoB,IAAI;AACtF;AACA;AACA,qDAAqD,KAAK,wBAAwB,IAAI;AACtF;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU,GAAG,IAAI,kCAAkC,KAAK;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzJY;;AAEZ,WAAW,mBAAO,CAAC,8DAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACzBA;AACA;AACA,QAAQ,mBAAO,CAAC,8DAAa;AAC7B,EAAE;AACF,QAAQ,mBAAO,CAAC,cAAI;AACpB;AACA,qBAAqB,mBAAO,CAAC,wFAAc;AAC3C,QAAQ,sBAAsB,EAAE,mBAAO,CAAC,+EAAS;;AAEjD,4CAA4C;AAC5C;AACA,gBAAgB;AAChB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,uBAAuB,KAAK,IAAI,YAAY;AAC5C;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yCAAyC;AACzC;AACA,gBAAgB;AAChB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,uBAAuB,KAAK,IAAI,YAAY;AAC5C;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD;;AAEA;;AAEA;AACA;;AAEA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvFA,2BAA2B,uDAAuD,IAAI;AACtF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;;;;;;;;;;;ACbnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,KAAK;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,mBAAO,CAAC,gHAA2B;AACxD,QAAQ,QAAQ,EAAE,mBAAO,CAAC,0FAAgB;AAC1C,YAAY,mBAAO,CAAC,8FAAkB;AACtC,cAAc,mBAAO,CAAC,gGAAmB;AACzC,eAAe,mBAAO,CAAC,uFAAU;AACjC,cAAc,mBAAO,CAAC,qFAAS;;;;;;;;;;;ACvI/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,MAAM;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,SAAS,GAAG,MAAM;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,oDAAW;AAC/B,wBAAwB,WAAW;;AAEnC,qBAAqB,mBAAO,CAAC,gHAA2B;AACxD,mBAAmB,mBAAO,CAAC,+FAAc;AACzC,cAAc,mBAAO,CAAC,gGAAmB;AACzC,eAAe,mBAAO,CAAC,uFAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0FAAgB;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,iBAAiB,EAAE,QAAQ,OAAO;AAClC,MAAM;AACN;AACA,iBAAiB,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,OAAO;AAC1C,MAAM;AACN;AACA,iBAAiB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AAChC,QAAQ,GAAG,EAAE,GAAG,OAAO;AACvB,MAAM;AACN;AACA,iBAAiB,EAAE,GAAG,EAAE,GAAG;AAC3B,QAAQ,GAAG,EAAE,GAAG,OAAO;AACvB;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,iBAAiB,EAAE,MAAM,GAAG,GAAG,OAAO;AACtC,MAAM;AACN;AACA,mBAAmB,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,OAAO;AAChD,QAAQ;AACR,mBAAmB,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,OAAO;AAC3C;AACA,MAAM;AACN;AACA;AACA;AACA,qBAAqB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AACpC,YAAY,GAAG,EAAE,GAAG,EAAE,GAAG,OAAO;AAChC,UAAU;AACV,qBAAqB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AACpC,YAAY,GAAG,EAAE,GAAG,OAAO;AAC3B;AACA,QAAQ;AACR,mBAAmB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AAClC,UAAU,GAAG,OAAO;AACpB;AACA,MAAM;AACN;AACA;AACA;AACA,qBAAqB,EAAE,GAAG,EAAE,GAAG;AAC/B,WAAW,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,OAAO;AACpC,UAAU;AACV,qBAAqB,EAAE,GAAG,EAAE,GAAG;AAC/B,WAAW,EAAE,GAAG,GAAG,EAAE,GAAG,OAAO;AAC/B;AACA,QAAQ;AACR,mBAAmB,EAAE,GAAG,EAAE,GAAG;AAC7B,UAAU,GAAG,OAAO;AACpB;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,SAAS,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG;AACvC,MAAM;AACN,iBAAiB,EAAE,MAAM,IAAI,GAAG,OAAO;AACvC,MAAM;AACN,iBAAiB,EAAE,GAAG,EAAE,IAAI;AAC5B,QAAQ,GAAG,EAAE,GAAG,OAAO;AACvB;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,GAAG,MAAM,kBAAkB;AAC3C,IAAI;AACJ,gBAAgB,GAAG,GAAG,GAAG,IAAI,kBAAkB;AAC/C,IAAI;AACJ,gBAAgB,KAAK;AACrB,IAAI;AACJ,gBAAgB,KAAK,EAAE,kBAAkB;AACzC;;AAEA;AACA;AACA,IAAI;AACJ,aAAa,QAAQ;AACrB,IAAI;AACJ,aAAa,GAAG,GAAG,QAAQ;AAC3B,IAAI;AACJ,cAAc,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI;AACpC,IAAI;AACJ,aAAa,GAAG,GAAG,GAAG,GAAG,QAAQ;AACjC,IAAI;AACJ,cAAc,GAAG;AACjB;;AAEA,aAAa,MAAM,EAAE,GAAG;AACxB;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;ACtgBA,cAAc,mBAAO,CAAC,gGAAmB;AACzC,QAAQ,+BAA+B,EAAE,mBAAO,CAAC,wGAAuB;AACxE,QAAQ,QAAQ,EAAE,mBAAO,CAAC,0FAAgB;;AAE1C,qBAAqB,mBAAO,CAAC,gHAA2B;AACxD,QAAQ,qBAAqB,EAAE,mBAAO,CAAC,4GAAyB;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,WAAW,GAAG,WAAW,GAAG,WAAW;AAC7D;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9RA,cAAc,mBAAO,CAAC,uFAAS;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;ACLA,WAAW,mBAAO,CAAC,iFAAM;AACzB,YAAY,mBAAO,CAAC,mFAAO;AAC3B,WAAW,mBAAO,CAAC,iFAAM;AACzB,YAAY,mBAAO,CAAC,mFAAO;AAC3B,WAAW,mBAAO,CAAC,iFAAM;AACzB,YAAY,mBAAO,CAAC,mFAAO;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,+CAA+C,GAAG;AAClD;AACA;AACA;;;;;;;;;;;ACnDA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C,cAAc,mBAAO,CAAC,uFAAS;AAC/B,QAAQ,QAAQ,EAAE,mBAAO,CAAC,0FAAgB;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS,GAAG,gBAAgB,GAAG,gBAAgB;AACjE;AACA;;;;;;;;;;;ACnDA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,2FAAW;AACnC;AACA;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C;AACA;;AAEA;;;;;;;;;;;ACJA,cAAc,mBAAO,CAAC,uFAAS;AAC/B,WAAW,mBAAO,CAAC,iFAAM;;AAEzB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtBA,gBAAgB,mBAAO,CAAC,2FAAW;AACnC;AACA;;;;;;;;;;;ACFA,gBAAgB,mBAAO,CAAC,2FAAW;AACnC;AACA;;;;;;;;;;;ACFA,gBAAgB,mBAAO,CAAC,2FAAW;AACnC;AACA;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,gGAAmB;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;;;;;;;;;ACjBA,gBAAgB,mBAAO,CAAC,2FAAW;AACnC;AACA;;;;;;;;;;;ACFA,gBAAgB,mBAAO,CAAC,2FAAW;AACnC;AACA;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C;AACA;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C;AACA;;;;;;;;;;;ACFA,gBAAgB,mBAAO,CAAC,2FAAW;AACnC;AACA;;;;;;;;;;;ACFA,QAAQ,aAAa,EAAE,mBAAO,CAAC,wGAAuB;AACtD,QAAQ,QAAQ,EAAE,mBAAO,CAAC,0FAAgB;AAC1C,eAAe,mBAAO,CAAC,gGAAmB;;AAE1C,qBAAqB,mBAAO,CAAC,gHAA2B;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;;;;;;;;;;AChCA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C;AACA;;;;;;;;;;;ACFA,cAAc,mBAAO,CAAC,uFAAS;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;ACLA,gBAAgB,mBAAO,CAAC,2FAAW;AACnC;AACA;;;;;;;;;;;ACFA,qBAAqB,mBAAO,CAAC,uGAAiB;AAC9C;AACA;;;;;;;;;;;ACFA,cAAc,mBAAO,CAAC,8FAAkB;AACxC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;;;;;;;;;ACTA,qBAAqB,mBAAO,CAAC,uGAAiB;AAC9C;AACA;;;;;;;;;;;ACFA,cAAc,mBAAO,CAAC,uFAAS;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;ACLA;AACA,mBAAmB,mBAAO,CAAC,yFAAe;AAC1C;AACA;AACA;AACA;AACA,uBAAuB,kJAAmD;AAC1E,UAAU,mBAAO,CAAC,+FAAkB;AACpC,sBAAsB,qJAAoD;AAC1E,uBAAuB,sJAAqD;AAC5E,SAAS,mBAAO,CAAC,iGAAmB;AACpC,SAAS,mBAAO,CAAC,iGAAmB;AACpC,SAAS,mBAAO,CAAC,iGAAmB;AACpC,OAAO,mBAAO,CAAC,6FAAiB;AAChC,QAAQ,mBAAO,CAAC,+FAAkB;AAClC,SAAS,mBAAO,CAAC,iGAAmB;AACpC,SAAS,mBAAO,CAAC,iGAAmB;AACpC,SAAS,mBAAO,CAAC,iGAAmB;AACpC,cAAc,mBAAO,CAAC,2GAAwB;AAC9C,WAAW,mBAAO,CAAC,qGAAqB;AACxC,YAAY,mBAAO,CAAC,uGAAsB;AAC1C,gBAAgB,mBAAO,CAAC,iHAA2B;AACnD,gBAAgB,mBAAO,CAAC,iHAA2B;AACnD,QAAQ,mBAAO,CAAC,+FAAkB;AAClC,SAAS,mBAAO,CAAC,iGAAmB;AACpC,MAAM,mBAAO,CAAC,2FAAgB;AAC9B,MAAM,mBAAO,CAAC,2FAAgB;AAC9B,MAAM,mBAAO,CAAC,2FAAgB;AAC9B,OAAO,mBAAO,CAAC,6FAAiB;AAChC,OAAO,mBAAO,CAAC,6FAAiB;AAChC,OAAO,mBAAO,CAAC,6FAAiB;AAChC,OAAO,mBAAO,CAAC,6FAAiB;AAChC,UAAU,mBAAO,CAAC,mGAAoB;AACtC,cAAc,mBAAO,CAAC,uGAAsB;AAC5C,SAAS,mBAAO,CAAC,6FAAiB;AAClC,aAAa,mBAAO,CAAC,yGAAuB;AAC5C,iBAAiB,mBAAO,CAAC,6GAAyB;AAClD,iBAAiB,mBAAO,CAAC,6GAAyB;AAClD,iBAAiB,mBAAO,CAAC,6GAAyB;AAClD,cAAc,mBAAO,CAAC,uGAAsB;AAC5C,cAAc,mBAAO,CAAC,2FAAgB;AACtC,WAAW,mBAAO,CAAC,+FAAkB;AACrC,OAAO,mBAAO,CAAC,uFAAc;AAC7B,OAAO,mBAAO,CAAC,uFAAc;AAC7B,cAAc,mBAAO,CAAC,qGAAqB;AAC3C,iBAAiB,mBAAO,CAAC,iGAAmB;AAC5C,UAAU,mBAAO,CAAC,6FAAiB;AACnC;;;;;;;;;;;AC/CA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACRA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,GAAG,IAAI;AACP;;;;;;;;;;;ACVA,QAAQ,4BAA4B,EAAE,mBAAO,CAAC,8FAAa;AAC3D,cAAc,mBAAO,CAAC,sFAAS;AAC/B;;AAEA;AACA,WAAW,UAAU;AACrB,YAAY,WAAW;AACvB,UAAU,SAAS;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,yBAAyB;AACxD,uBAAuB,yBAAyB;AAChD,uBAAuB,yBAAyB;;AAEhD,oCAAoC,8BAA8B;AAClE,4BAA4B,8BAA8B;AAC1D,4BAA4B,8BAA8B;;AAE1D;AACA;;AAEA,0CAA0C;AAC1C,CAAC,GAAG,4BAA4B;;AAEhC,+CAA+C;AAC/C,CAAC,GAAG,4BAA4B;;AAEhC;AACA;AACA;;AAEA,kCAAkC;AAClC,CAAC,QAAQ,4BAA4B;;AAErC,wCAAwC;AACxC,CAAC,QAAQ,iCAAiC;;AAE1C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,+BAA+B;AAC/B,CAAC,QAAQ,uBAAuB;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B,CAAC,EAAE,kBAAkB;AACrB,eAAe;;AAEf,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;AACA,qCAAqC;AACrC,CAAC,EAAE,uBAAuB;AAC1B,eAAe;;AAEf,yBAAyB,kBAAkB;;AAE3C;;AAEA;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE,mCAAmC,yBAAyB;;AAE5D,uCAAuC,wBAAwB;AAC/D,6BAA6B,wBAAwB;AACrD,6BAA6B,wBAAwB;AACrD,yBAAyB,kBAAkB;AAC3C,kCAAkC;AAClC;;AAEA,4CAA4C,6BAA6B;AACzE,kCAAkC,6BAA6B;AAC/D,kCAAkC,6BAA6B;AAC/D,8BAA8B,uBAAuB;AACrD,uCAAuC;AACvC;;AAEA,0BAA0B,YAAY,MAAM,mBAAmB;AAC/D,+BAA+B,YAAY,MAAM,wBAAwB;;AAEzE;AACA;AACA,yBAAyB;AACzB,oBAAoB,IAAI,EAAE,2BAA2B;AACrD,0BAA0B,IAAI,2BAA2B;AACzD,0BAA0B,IAAI,2BAA2B;AACzD;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,iBAAiB;AACnD,wBAAwB;;AAExB,yBAAyB,iBAAiB,EAAE,mBAAmB;AAC/D,8BAA8B,iBAAiB,EAAE,wBAAwB;;AAEzE;AACA;AACA;;AAEA,kCAAkC,iBAAiB;AACnD,wBAAwB;;AAExB,yBAAyB,iBAAiB,EAAE,mBAAmB;AAC/D,8BAA8B,iBAAiB,EAAE,wBAAwB;;AAEzE;AACA,mCAAmC,YAAY,OAAO,kBAAkB;AACxE,8BAA8B,YAAY,OAAO,iBAAiB;;AAElE;AACA;AACA,uCAAuC;AACvC,CAAC,OAAO,kBAAkB,GAAG,mBAAmB;AAChD,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA,uBAAuB,mBAAmB;AAC1C;;AAEA,yCAAyC,wBAAwB;AACjE;AACA,4BAA4B,wBAAwB;AACpD;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrLA;AACA,gBAAgB,mBAAO,CAAC,wFAAW;AACnC;AACA;;;;;;;;;;;ACHA,cAAc,mBAAO,CAAC,8FAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,wFAAW;AACnC;AACA;AACA;;;;;;;;;;;ACHA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C,cAAc,mBAAO,CAAC,8FAAkB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;ACxBA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C,cAAc,mBAAO,CAAC,8FAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;ACvBA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C,cAAc,mBAAO,CAAC,8FAAkB;AACxC,WAAW,mBAAO,CAAC,4FAAiB;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC5DA,eAAe,mBAAO,CAAC,gGAAmB;AAC1C,mBAAmB,mBAAO,CAAC,wGAAuB;AAClD,QAAQ,MAAM;AACd,cAAc,mBAAO,CAAC,8FAAkB;AACxC,kBAAkB,mBAAO,CAAC,0GAAwB;AAClD,WAAW,mBAAO,CAAC,4FAAiB;AACpC,WAAW,mBAAO,CAAC,4FAAiB;AACpC,YAAY,mBAAO,CAAC,8FAAkB;AACtC,YAAY,mBAAO,CAAC,8FAAkB;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/EA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,6GAA2B;AACrD,gBAAgB,mBAAO,CAAC,yGAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,uBAAuB,IAAI;AAC3B,MAAM;AACN,uBAAuB,IAAI;AAC3B,MAAM;AACN,qBAAqB,KAAK,IAAI,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9CA,cAAc,mBAAO,CAAC,iGAAqB;AAC3C,mBAAmB,mBAAO,CAAC,2GAA0B;AACrD,QAAQ,MAAM;AACd,kBAAkB,mBAAO,CAAC,6GAA2B;AACrD,gBAAgB,mBAAO,CAAC,yGAAyB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnPA,cAAc,mBAAO,CAAC,8FAAkB;;AAExC;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACPA,cAAc,mBAAO,CAAC,8FAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;;;;;;;;;;ACVY;;AAEZ,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG,YAAY,gBAAgB;AAC/B;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,GAAG,YAAY,gBAAgB;AAC/B;;;;;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,aAAa,mBAAO,CAAC,cAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;;;;;ACrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,wBAAwB,mBAAO,CAAC,oCAAe;AAC/C,mBAAmB,mBAAO,CAAC,oFAAU;AACrC,aAAa,mBAAO,CAAC,cAAI;AACzB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,sBAAsB,mBAAO,CAAC,yEAAe;AAC7C,yDAAyD,mBAAO,CAAC,6LAAyE;AAC1I,eAAe,mBAAO,CAAC,2DAAQ;AAC/B,mBAAmB,mBAAO,CAAC,uFAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,aAAa;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;;;;;;;;;;AC9Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,kBAAkB;AACvC,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,mBAAmB,mBAAO,CAAC,oFAAU;AACrC,mBAAmB,mBAAO,CAAC,gCAAa;AACxC,kBAAkB,mBAAO,CAAC,gDAAS;AACnC,mBAAmB,mBAAO,CAAC,qDAAU;AACrC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,iBAAiB,mBAAO,CAAC,4EAAQ;AACjC,iCAAiC,mBAAO,CAAC,+FAA0B;AACnE,6BAA6B,mBAAO,CAAC,uFAAsB;AAC3D,+BAA+B,mBAAO,CAAC,2FAAwB;AAC/D,0BAA0B,mBAAO,CAAC,qGAA6B;AAC/D,eAAe,mBAAO,CAAC,2DAAQ;AAC/B,0BAA0B,mBAAO,CAAC,iFAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,0DAA0D;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B;AACtE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,qBAAqB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,MAAM;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8LAA8L,yBAAyB;AACvN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,mCAAmC;AAClG;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+DAA+D,0BAA0B;AACzF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAgC;AACrD,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,SAAS,SAAS;AACnD;AACA;AACA;AACA,wDAAwD,QAAQ,sBAAsB,QAAQ;AAC9F,sDAAsD,QAAQ,sBAAsB,QAAQ;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB,gBAAgB,WAAW,aAAa,cAAc;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0KAA0K,mBAAmB;AAC7L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oCAAoC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qBAAqB,oCAAoC,mBAAmB,iBAAiB,+CAA+C;AAChM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB,QAAQ;AACvE;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,iCAAiC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,GAAG;AAC9F;AACA;AACA;AACA;AACA,0FAA0F,EAAE;AAC5F;AACA;AACA;AACA,4DAA4D,GAAG;AAC/D;AACA;AACA;AACA;AACA,qEAAqE,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA,wFAAwF,QAAQ,EAAE,wCAAwC;AAC1I;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,2FAA2F,eAAe;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS,yBAAyB,WAAW;AAC7E;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;;ACviBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,qBAAqB,mBAAO,CAAC,uEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kEAAoC;AACpD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS,qBAAqB,gBAAgB;AAClG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yHAAyH,SAAS;AAClI;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;;ACvFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,8BAA8B;AAC7D,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,aAAa,mBAAO,CAAC,cAAI;AACzB;AACA,gBAAgB,mBAAO,CAAC,8DAAgB;AACxC,mBAAmB,mBAAO,CAAC,oFAAU;AACrC,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2IAA2I,kBAAkB,cAAc,qBAAqB;AAChM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6HAA6H,OAAO,cAAc,qBAAqB;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,sCAAsC,wFAAwF;AAC9H;AACA;AACA;AACA;AACA,SAAS;AACT,0BAA0B,YAAY;AACtC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,EAAE;AAC5D,4CAA4C,cAAc,GAAG,KAAK;AAClE;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;;;;;;;;;;;ACzKa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,qBAAqB,mBAAO,CAAC,uEAAc;AAC3C;AACA,sBAAsB,qDAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;;;;ACtCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,mBAAmB,mBAAO,CAAC,oFAAU;AACrC,aAAa,mBAAO,CAAC,cAAI;AACzB,eAAe,mBAAO,CAAC,kBAAM;AAC7B,qBAAqB,mBAAO,CAAC,uEAAc;AAC3C,mBAAmB,mBAAO,CAAC,uFAAsB;AACjD,wBAAwB,mBAAO,CAAC,oCAAe;AAC/C;AACA;AACA;AACA,6BAA6B,6DAA+B;AAC5D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,kBAAkB;AAC9G,2CAA2C,qBAAqB;AAChE,yEAAyE,UAAU;AACnF;AACA;AACA,4FAA4F,EAAE;AAC9F;AACA;AACA;AACA;AACA,2EAA2E,kBAAkB;AAC7F;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA,uEAAuE,EAAE;AACzE;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,gDAAgD;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D,qEAAqE,WAAW;AAChF;AACA,uEAAuE,WAAW;AAClF;AACA,wEAAwE,WAAW;AACnF,SAAS;AACT;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,gCAAgC,wBAAwB,GAAG,8CAA8C;AACzG;AACA;AACA,4BAA4B,YAAY;AACxC;AACA,gDAAgD,UAAU,eAAe,EAAE,QAAQ,GAAG;AACtF,8CAA8C,mEAAmE;AACjH;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA,4BAA4B,SAAS,kCAAkC,eAAe;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,EAAE;AAC3D;AACA;AACA;AACA,qDAAqD,eAAe,KAAK,MAAM;AAC/E,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,sFAAsF,WAAW;AACjG;AACA,yFAAyF,eAAe,IAAI,WAAW;AACvH;AACA;AACA,+BAA+B,6BAA6B;AAC5D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;;ACxLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,wBAAwB,mBAAO,CAAC,oCAAe;AAC/C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,sBAAsB,mBAAO,CAAC,yEAAe;AAC7C,yDAAyD,mBAAO,CAAC,6LAAyE;AAC1I,wCAAwC,mBAAO,CAAC,2JAAwD;AACxG,eAAe,mBAAO,CAAC,2DAAQ;AAC/B,eAAe,mBAAO,CAAC,2DAAQ;AAC/B,mBAAmB,mBAAO,CAAC,uFAAsB;AACjD,mBAAmB,mBAAO,CAAC,oFAAU;AACrC,iDAAiD,mBAAO,CAAC,+HAA0C;AACnG,cAAc,mBAAO,CAAC,gBAAK;AAC3B,eAAe,mBAAO,CAAC,kBAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,0DAA0D,0CAA0C,4BAA4B;AACzM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,gBAAgB,qIAAqI;AACrJ,sBAAsB,wBAAwB,SAAS,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,UAAU,oBAAoB,UAAU;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oBAAoB,UAAU,oBAAoB;AAC9G;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS,YAAY,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,aAAa;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,aAAa;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;AC1Na;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,gBAAgB;AACvC,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,aAAa,mBAAO,CAAC,cAAI;AACzB,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,8BAA8B,mBAAO,CAAC,gHAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yIAAyI;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,gBAAgB,uBAAuB,sBAAsB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;;;;ACzMa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,mBAAmB,mBAAO,CAAC,oFAAU;AACrC,aAAa,mBAAO,CAAC,cAAI;AACzB,uBAAuB,mBAAO,CAAC,kGAAgB;AAC/C,cAAc,mBAAO,CAAC,gBAAK;AAC3B,8BAA8B,mBAAO,CAAC,gHAAuB;AAC7D,kCAAkC,mBAAO,CAAC,wHAA2B;AACrE,wDAAwD,mBAAO,CAAC,oKAAiD;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qBAAqB,IAAI,oBAAoB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,aAAa,cAAc,SAAS,aAAa,QAAQ;AACrI;AACA,6BAA6B,qBAAqB,iBAAiB,2BAA2B,GAAG,2CAA2C;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gBAAgB,KAAK,EAAE;AACnF,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,sBAAsB,mDAAmD;AACzE;AACA,sBAAsB,mDAAmD;AACzE,uEAAuE,eAAe;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,GAAG,kBAAkB;AAC5E;AACA,4JAA4J,MAAM;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD,MAAM,GAAG,aAAa;AACtE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oDAAoD,UAAU,2BAA2B,cAAc;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpQa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sDAAsD;AACtD,mBAAmB,mBAAO,CAAC,oFAAU;AACrC,iCAAiC,mBAAO,CAAC,sHAA0B;AACnE,eAAe,mBAAO,CAAC,kBAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC;AACrC,iCAAiC,mBAAO,CAAC,sHAA0B;AACnE;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;;;;;;;;;;ACVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qDAAqD;AACrD,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;;;;;;;;;;;ACzFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,qBAAqB;AACjD;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA,YAAY,2DAA2D;AACvE;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA,sCAAsC,SAAS,qCAAqC,gCAAgC,SAAS,UAAU;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAA6D,MAAM,mBAAmB;AACjH;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM,cAAc,SAAS,UAAU,8BAA8B,2CAA2C,SAAS;AAChL,wBAAwB,qBAAqB,QAAQ,mBAAmB,MAAM,iBAAiB,QAAQ,cAAc;AACrH,wBAAwB,2BAA2B,QAAQ,yBAAyB,MAAM,uBAAuB,QAAQ,oBAAoB;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,SAAS,eAAe,KAAK;AAC/G,4BAA4B,UAAU,yBAAyB,gBAAgB;AAC/E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,8CAA8C;AAC/E,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,uBAAuB,mBAAO,CAAC,kGAAgB;AAC/C,8BAA8B,mBAAO,CAAC,gHAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA,yBAAyB,WAAW,GAAG,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW,GAAG,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,0FAA0F,YAAY;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,oBAAoB;AACxG;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;;;;;;;;;;AC/Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,qBAAqB,GAAG,wBAAwB;AAC/E,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,wBAAwB;AACxB;AACA,WAAW,uEAAyC;AACpD;AACA,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAA+B;AACvD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;;;;;;;;;;;AC9Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,uBAAuB,GAAG,gBAAgB,GAAG,yBAAyB,GAAG,kBAAkB,GAAG,kBAAkB;AAC3O,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,qDAAoD,EAAE,qCAAqC,oDAAoD,EAAC;AAChJ,mBAAmB,mBAAO,CAAC,uEAAc;AACzC,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,iBAAiB,mBAAO,CAAC,uFAAsB;AAC/C,4CAA2C,EAAE,qCAAqC,+BAA+B,EAAC;AAClH,wBAAwB,mBAAO,CAAC,iFAAmB;AACnD,mDAAkD,EAAE,qCAAqC,6CAA6C,EAAC;AACvI,mBAAmB,mBAAO,CAAC,uEAAc;AACzC,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,oBAAoB,mBAAO,CAAC,yEAAe;AAC3C,+CAA8C,EAAE,qCAAqC,qCAAqC,EAAC;AAC3H;AACA;AACA;AACA;AACA;AACA,4BAA4B,4GAAoC;AAChE;AACA;AACA,4BAA4B,yGAAkC;AAC9D;AACA;AACA,4BAA4B,wHAA4C;AACxE;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAC;AACF,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,8CAA8C;AACrE,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,0BAA0B,mBAAO,CAAC,qGAA6B;AAC/D,4BAA4B,mBAAO,CAAC,yGAA+B;AACnE,0BAA0B,mBAAO,CAAC,qGAA6B;AAC/D,yBAAyB,mBAAO,CAAC,mGAA4B;AAC7D,yBAAyB,mBAAO,CAAC,mGAA4B;AAC7D,gCAAgC,mBAAO,CAAC,iHAAmC;AAC3E;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,SAAS;AACpF;AACA;AACA,oBAAoB;AACpB;;;;;;;;;;;ACpEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,kBAAkB,mBAAO,CAAC,4FAAkC;AAC5D,cAAc,mBAAO,CAAC,gBAAK;AAC3B,eAAe,mBAAO,CAAC,4DAAS;AAChC,mBAAmB,mBAAO,CAAC,6EAAY;AACvC;AACA;AACA;AACA;AACA,mEAAmE,kBAAkB,GAAG,iBAAiB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,gBAAgB,2BAA2B,gBAAgB;AACjI;AACA;AACA,mFAAmF,gBAAgB,sBAAsB,yDAAyD;AAClL;AACA,2EAA2E,kBAAkB,GAAG,iBAAiB,GAAG,iBAAiB;AACrI;AACA;AACA;AACA;AACA,wLAAwL,qBAAqB;AAC7M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;;;;;;;;;;AC3Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,eAAe,mBAAO,CAAC,4DAAS;AAChC,mBAAmB,mBAAO,CAAC,6EAAY;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,cAAc;AAC9B,uFAAuF,MAAM,GAAG,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,gBAAgB,kCAAkC,qBAAqB;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,oCAAoC,MAAM,UAAU,KAAK,aAAa,aAAa;AACnF;AACA;AACA,yBAAyB;AACzB;;;;;;;;;;;ACzCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,eAAe,mBAAO,CAAC,4DAAS;AAChC,mBAAmB,mBAAO,CAAC,6EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,kFAAkF,YAAY,iBAAiB,qBAAqB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;;;;;;;;;;AClDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,sBAAsB,GAAG,0BAA0B;AACjF,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,eAAe,mBAAO,CAAC,4EAAQ;AAC/B,cAAc,mBAAO,CAAC,gBAAK;AAC3B,eAAe,mBAAO,CAAC,4DAAS;AAChC,mBAAmB,mBAAO,CAAC,6EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,OAAO;AACrG;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,cAAc;AACvF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,qBAAqB,WAAW,QAAQ;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,aAAa,mCAAmC,eAAe,KAAK,qBAAqB;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,+BAA+B,qCAAqC,cAAc,GAAG,aAAa,YAAY;AAC9G;AACA,0DAA0D,4BAA4B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,IAAI,gDAAgD,qBAAqB;AACvK;AACA;AACA;AACA,mBAAmB,mBAAmB,GAAG,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc,YAAY,IAAI,GAAG,SAAS;AAC5D;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;;;;AC/Ia;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,eAAe,mBAAO,CAAC,4DAAS;AAChC,mBAAmB,mBAAO,CAAC,6EAAY;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8EAA8E,2BAA2B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sFAAsF,gBAAgB,kCAAkC,qBAAqB;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C,mCAAmC,QAAQ,aAAa,QAAQ,cAAc,SAAS,aAAa,aAAa;AACjH;AACA;AACA,sBAAsB;AACtB;;;;;;;;;;;AC1Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,kBAAkB,mBAAO,CAAC,gDAAS;AACnC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,gBAAK;AAC3B,eAAe,mBAAO,CAAC,4DAAS;AAChC,yBAAyB,mBAAO,CAAC,yFAAkB;AACnD,mBAAmB,mBAAO,CAAC,6EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,aAAa,iBAAiB,yCAAyC;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,aAAa,mCAAmC,IAAI,KAAK,qBAAqB;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,IAAI,gDAAgD,qBAAqB;AACvK;AACA;AACA;AACA,oDAAoD,mBAAmB,GAAG,kBAAkB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,KAAK,QAAQ,2CAA2C;AACpI;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B;;;;;;;;;;;AC7Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,mBAAmB,GAAG,uBAAuB,GAAG,gBAAgB,GAAG,gBAAgB;AAC1G,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,kBAAkB,mBAAO,CAAC,gDAAS;AACnC,eAAe,mBAAO,CAAC,4DAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,EAAE,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,+EAA+E,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,IAAI;AAC5G;AACA;AACA,gBAAgB;AAChB;AACA;AACA,+EAA+E,aAAa,mCAAmC,eAAe;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,aAAa,mCAAmC,eAAe,KAAK,qBAAqB,aAAa,QAAQ;AAC7L;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oEAAoE,qDAAqD;AACzH;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qHAAqH,mDAAmD;AACxK;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;;;;ACrIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,0BAA0B,GAAG,sBAAsB,GAAG,kBAAkB;AAChG;AACA,cAAc,mBAAO,CAAC,gBAAK;AAC3B;AACA,qBAAqB,mBAAO,CAAC,wEAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA,sBAAsB;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,0BAA0B;AAC1B;AACA,6CAA6C,iBAAiB;AAC9D,6CAA6C,gFAAgF;AAC7H;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;;ACzCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,+BAA+B,mBAAO,CAAC,8EAAsB;AAC7D,wBAAwB,mBAAO,CAAC,oCAAe;AAC/C,WAAW,mBAAO,CAAC,cAAI;AACvB;AACA,YAAY,qIAAqI;AACjJ,kBAAkB,wBAAwB,SAAS,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA,iGAAiG,KAAK;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,gDAAgD,sEAAsE;AAC/K;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,2BAA2B;AAC7E,sGAAsG,OAAO;AAC7G;AACA;AACA;AACA,yEAAyE,MAAM;AAC/E;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA,+HAA+H,oBAAoB;AACnJ;AACA;AACA,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,OAAO;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,qBAAqB,mBAAO,CAAC,8DAAgB;;AAE7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO,EAAE,0BAA0B;AACxD;;AAEA;AACA,gBAAgB,UAAU,GAAG,UAAU;AACvC,IAAI;AACJ;AACA;;AAEA;AACA,eAAe,OAAO,EAAE,OAAO;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,yBAAyB;AACzD;;AAEA;AACA;;AAEA;AACA,aAAa,MAAM,GAAG,KAAK;AAC3B;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,EAAE,gBAAgB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;;AAEA;AACA;;AAEA,uDAAuD;AACvD;AACA;AACA;;;AAGA;AACA,aAAa,MAAM;AACnB,aAAa,IAAI;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,sBAAsB;AACxD;;AAEA;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;;AAEA;AACA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxPa;;AAEb,aAAa,mBAAO,CAAC,gDAAS;AAC9B,uBAAuB,uDAA6B;AACpD,cAAc,8CAAsB;;AAEpC;AACA;AACA,oBAAoB,QAAQ;AAC5B,2BAA2B;AAC3B,qCAAqC,EAAE;;AAEvC;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,gCAAgC,uBAAuB;;AAEvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;;;;;;;;;;;ACzCY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;ACtBA,SAAS,mBAAO,CAAC,cAAI;AACrB,gBAAgB,mBAAO,CAAC,+DAAgB;AACxC,aAAa,mBAAO,CAAC,yEAAqB;AAC1C,YAAY,mBAAO,CAAC,uDAAY;;AAEhC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,MAAM,iDAAuB;AAC7B,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5aA,aAAa,oDAAwB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrHA,gBAAgB,mBAAO,CAAC,4BAAW;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC3Va;;AAEb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,IAA6B;AACrC;AACA,MAAM,KAAK,EAEN;AACL,CAAC;;;;;;;;;;;;ACzIY;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,yBAAyB,mBAAO,CAAC,oEAAmB;;AAEpD;;AAEA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,sDAAY;AACpC,cAAc,EAAE,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,0BAA0B;AAC7E,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACxCa;;;AAGb,aAAa,mBAAO,CAAC,0DAAc;AACnC,aAAa,mBAAO,CAAC,0DAAc;;;AAGnC;AACA;AACA;AACA;AACA;AACA;;;AAGA,iGAA0D;AAC1D,uGAA4D;AAC5D,kIAAqE;AACrE,sHAAiE;AACjE,sHAAiE;AACjE,+HAAoE;AACpE,mBAAmB;AACnB,sBAAsB;AACtB,mBAAmB;AACnB,oHAA+D;;AAE/D;AACA,oBAAoB;AACpB,aAAa,mBAAO,CAAC,oEAAmB;AACxC,aAAa,mBAAO,CAAC,kEAAkB;AACvC,aAAa,mBAAO,CAAC,8DAAgB;AACrC,aAAa,mBAAO,CAAC,gEAAiB;AACtC,aAAa,mBAAO,CAAC,kEAAkB;AACvC,aAAa,mBAAO,CAAC,8DAAgB;AACrC,aAAa,mBAAO,CAAC,0EAAsB;AAC3C,aAAa,mBAAO,CAAC,gEAAiB;AACtC,aAAa,mBAAO,CAAC,8DAAgB;AACrC,aAAa,mBAAO,CAAC,kEAAkB;AACvC,aAAa,mBAAO,CAAC,gEAAiB;AACtC,aAAa,mBAAO,CAAC,8DAAgB;AACrC,aAAa,mBAAO,CAAC,8DAAgB;AACrC;;AAEA;AACA,uBAAuB;AACvB,0BAA0B;AAC1B,uBAAuB;;;;;;;;;;;;AC9CV;;;AAGb;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA,wBAAwB;AACxB,uBAAuB;AACvB,sBAAsB;AACtB,qBAAqB;AACrB,6BAA6B;AAC7B,qBAAqB;;;;;;;;;;;;AC1DR;;AAEb;;AAEA,0BAA0B,mBAAO,CAAC,sDAAU;AAC5C,0BAA0B,mBAAO,CAAC,4DAAa;AAC/C,0BAA0B,mBAAO,CAAC,sEAAkB;;AAEpD;AACA;;AAEA;AACA,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC;AACtC,sCAAsC,KAAK;AAC3C,sCAAsC;AACtC,sCAAsC,KAAK;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAwC,gBAAgB;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uDAAuD,gBAAgB;AACvE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,gBAAgB;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,gBAAgB;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,gBAAgB;;AAEjE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;;AAEA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,iDAAiD,gBAAgB;AACjE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,GAAG;AAChC;;AAEA;AACA;;AAEA;;AAEA,4CAA4C,gBAAgB;AAC5D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA,QAAQ;AACR;;AAEA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,kCAAkC,WAAW;AAC7C;;AAEA;;AAEA;AACA;;AAEA,mBAAmB;;;;;;;;;;;;ACp8BnB;AACA;AACa;;;AAGb;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACtDa;;AAEb;;AAEA,0BAA0B,mBAAO,CAAC,sDAAU;AAC5C,0BAA0B,mBAAO,CAAC,4DAAa;AAC/C,0BAA0B,mBAAO,CAAC,wDAAW;AAC7C,0BAA0B,mBAAO,CAAC,sEAAkB;;;AAGpD;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA,oDAAoD,EAAE,eAAe,EAAE,YAAY;;;AAGnF,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAoD,qBAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;;AAEA,gDAAgD,kBAAkB;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,kBAAkB;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA,MAAM;AACN;;AAEA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;;AAEA,QAAQ;AACR;AACA;;AAEA,eAAe,eAAe;AAC9B;;AAEA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;;AAEA,QAAQ;AACR;AACA;;AAEA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA,MAAM;AACN;;AAEA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA,IAAI,yBAAyB;AAC7B,sBAAsB,KAAK;AAC3B;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,MAAM;AACN;AACA,6EAA6E;AAC7E,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,QAAQ;AACR,8BAA8B;AAC9B;AACA;;AAEA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ;AACR;AACA;AACA;;AAEA,QAAQ;AACR,6DAA6D,sBAAsB;AACnF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV,oEAAoE;;AAEpE,UAAU;AACV;AACA;AACA,uBAAuB;AACvB;;AAEA,QAAQ;AACR,+DAA+D;;AAE/D,QAAQ;AACR;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;;AAEA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,IAAI;AACJ;;AAEA,IAAI;AACJ;;AAEA,IAAI;AACJ;;AAEA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;;AAEA,mEAAmE,0BAA0B;AAC7F;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,0DAA0D,0BAA0B;AACpF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8EAA8E;AAC9E;;AAEA,kDAAkD;AAClD;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iDAAiD,gBAAgB;AACjE;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA,sBAAsB;AACtB,mBAAmB;;;;;;;;;;;;AC9rDN;;AAEb;;AAEA,oBAAoB,mBAAO,CAAC,4DAAa;AACzC,oBAAoB,mBAAO,CAAC,kDAAQ;;;AAGpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;;AAEA,IAAI;AACJ,uBAAuB,kEAAkE;AACzF;AACA;;AAEA,IAAI;AACJ;AACA,iCAAiC,kCAAkC;AACnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;;;AAGa;;;AAGb,+FAAkC;;;;;;;;;;;;ACVlC;AACA;AACA;AACA;AACA;;;AAGa;;;AAGb,iBAAiB,uFAAwB;AACzC;AACA,IAAI,mBAAO,CAAC,uEAAmB;AAC/B,IAAI,mBAAO,CAAC,+DAAe;AAC3B;AACA;AACA,IAAI,mBAAO,CAAC,iEAAgB;AAC5B,IAAI,mBAAO,CAAC,6DAAc;AAC1B,IAAI,mBAAO,CAAC,+DAAe;AAC3B,IAAI,mBAAO,CAAC,2DAAa;AACzB;AACA,CAAC;;;;;;;;;;;;ACrBD;AACA;;;AAGa;;;AAGb,aAAa,mBAAO,CAAC,uDAAW;;;AAGhC;AACA;AACA,IAAI,mBAAO,CAAC,2DAAa;AACzB,IAAI,mBAAO,CAAC,2DAAa;AACzB,IAAI,mBAAO,CAAC,2DAAa;AACzB;AACA,CAAC;;;;;;;;;;;;AChBD;AACA;AACA;AACA;AACA;AACA;;;AAGa;;;AAGb,iBAAiB,+FAA4B;AAC7C;AACA,IAAI,mBAAO,CAAC,6DAAc;AAC1B,IAAI,mBAAO,CAAC,6DAAc;AAC1B,IAAI,mBAAO,CAAC,2DAAa;AACzB,IAAI,mBAAO,CAAC,+DAAe;AAC3B;AACA,CAAC;;;;;;;;;;;;AClBY;;;AAGb,aAAa,mBAAO,CAAC,sDAAU;;;AAG/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;ACpGa;;AAEb,oBAAoB,mBAAO,CAAC,4DAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,gCAAgC;AAChC;AACA;AACA,iEAAiE;AACjE,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjEa;;AAEb;;;AAGA,WAAW,mBAAO,CAAC,mDAAS;;;AAG5B;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA,gBAAgB,WAAW;AAC3B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC5HY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE,mCAAmC,mCAAmC;AACtE,mCAAmC;AACnC,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;AClCY;;AAEb,aAAa,mBAAO,CAAC,uDAAW;AAChC,aAAa,mBAAO,CAAC,mDAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AChGY;;AAEb,aAAa,mBAAO,CAAC,uDAAW;AAChC,aAAa,mBAAO,CAAC,mDAAS;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8EAA8E;AAChH,kCAAkC,gFAAgF;AAClH,kCAAkC,0BAA0B;AAC5D;AACA,kCAAkC;AAClC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC3JY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA,+BAA+B;AAC/B,CAAC;;;;;;;;;;;;ACPY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACXY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C,6BAA6B,gBAAgB;AAC7C,6BAA6B,gBAAgB;AAC7C,6BAA6B,gBAAgB;AAC7C,6BAA6B;AAC7B,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;AClCY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,gBAAgB;AAC1D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC3CY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,0CAA0C,gBAAgB;AAC1D;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,0CAA0C,gBAAgB;AAC1D;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACpDY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA,+BAA+B;AAC/B,CAAC;;;;;;;;;;;;ACPY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC5BY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA,+BAA+B;AAC/B,CAAC;;;;;;;;;;;;ACPY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA,mBAAmB;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACvFD;AACA,qVAAqV,EAAE,EAAE;AACzV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,UAAU,cAAc;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,UAAU,cAAc;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,UAAU,cAAc;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,UAAU,cAAc;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,UAAU,aAAa;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,UAAU,eAAe;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,UAAU,cAAc;AACjD;AACA;AACA;;AAEA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA,uCAAuC,IAAI;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,UAAU,IAAI,UAAU,MAAM;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,gBAAgB,SAAS;AACzB,aAAa,EAAE,SAAS,EAAE;AAC1B;;AAEA,qBAAqB,mBAAmB,GAAG,UAAU;AACrD;AACA,0CAA0C,IAAI;AAC9C;;AAEA;AACA,yBAAyB,UAAU,IAAI,UAAU,MAAM;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA,KAAK;AACL,6CAA6C,kBAAkB;AAC/D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnSa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,KAAK,IAAI,QAAQ,EAAE,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,SAAS,MAAM,SAAS,EAAE,UAAU,MAAM,SAAS;;AAElG;AACA;;AAEA;;;;;;;;;;;;ACtCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,GAAG;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA,kBAAkB,QAAQ,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACl6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB,OAAO;AACzB,0BAA0B,gBAAgB,QAAQ,GAAG;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,KAA0B;;AAE5C;AACA,gCAAgC,QAAa;;AAE7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB,QAAQ,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC79BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,GAAG;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB,QAAQ,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA,WAAW,QAAQ,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACh/BY;;AAEZ;AACA,gBAAgB,mBAAO,CAAC,kDAAS;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4BAA4B;;AAE5B,kBAAkB;AAClB,qBAAqB;;AAErB;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7UA,gBAAgB,mBAAO,CAAC,gEAAmB;AAC3C,gBAAgB,mBAAO,CAAC,gEAAmB;;AAE3C,OAAO,gCAAgC,EAAE,mBAAO,CAAC,0EAAwB;AACzE,OAAO,gCAAgC,EAAE,mBAAO,CAAC,0EAAwB;AACzE,OAAO,0BAA0B,EAAE,mBAAO,CAAC,oEAAqB;;;AAGhE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9BA,OAAO,SAAS,EAAE,mBAAO,CAAC,kBAAM;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;AC5BlB,OAAO,SAAS,EAAE,mBAAO,CAAC,kBAAM;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,UAAU,UAAU;AACzB,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;AC/DlB,OAAO,SAAS,EAAE,mBAAO,CAAC,kBAAM;AAChC,OAAO,wBAAwB,EAAE,mBAAO,CAAC,8DAAgB;AACzD,OAAO,gCAAgC,EAAE,mBAAO,CAAC,sEAAoB;;AAErE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;ACtClB,QAAQ,YAAY,EAAE,mBAAO,CAAC,kBAAM;AACpC,WAAW,mBAAO,CAAC,cAAI;AACvB;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtBA;AACA,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,kBAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC5BA,WAAW,mBAAO,CAAC,cAAI;;AAEvB;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB;;;;;;;;;;;ACTlB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACjKA,iBAAiB,mBAAO,CAAC,kDAAU;AACnC,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,WAAW,mBAAO,CAAC,cAAI;AACvB,WAAW,mBAAO,CAAC,cAAI;;AAEvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClCa;;AAEb,wGAA2C;;;;;;;;;;;;ACF9B;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA,0BAA0B,UAAU;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,6BAA6B,cAAc;AAC3C,sBAAsB,aAAa,IAAI,EAAE,WAAW;AACpD,qBAAqB,YAAY;AACjC,sBAAsB,aAAa,EAAE,WAAW;AAChD,2BAA2B,aAAa,IAAI,EAAE,WAAW;AACzD,4BAA4B,WAAW;AACvC,2BAA2B,cAAc;AACzC,gBAAgB,MAAM;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;AACA,WAAW,aAAa;AACxB,iBAAiB,aAAa,IAAI,MAAM,UAAU;AAClD,gBAAgB,YAAY;AAC5B,uBAAuB,UAAU,IAAI,aAAa,IAAI,MAAM,UAAU;AACtE,sBAAsB,aAAa,IAAI,MAAM,UAAU;AACvD,uBAAuB,aAAa,IAAI,MAAM,UAAU;AACxD,sBAAsB,UAAU;AAChC,yBAAyB,UAAU;AACnC,qBAAqB,UAAU;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa,EAAE;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,6CAA6C;AAC7C,kCAAkC;AAClC;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,+CAA+C,WAAW,IAAI;AAC3E,aAAa,yCAAyC;AACtD,aAAa,wCAAwC;AACrD,aAAa,wCAAwC;AACrD,aAAa;AACb;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AClLa;;AAEb,kBAAkB,mBAAO,CAAC,8DAAa;AACvC,cAAc,mBAAO,CAAC,sDAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe;;AAEnC;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,KAAK,KAAK,KAAK,eAAe,KAAK;AACvD;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;AACA,2CAA2C,IAAI,oCAAoC,IAAI;AACvF;;AAEA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,eAAe,QAAQ,QAAQ,aAAa,EAAE,oCAAoC;AAClF;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA,WAAW,mDAAmD;AAC9D,WAAW,wDAAwD;AACnE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,YAAY;AAClD;;AAEA;AACA,wEAAwE,OAAO;AAC/E;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA,yCAAyC,8BAA8B;;AAEvE,mCAAmC,WAAW,GAAG,YAAY;AAC7D;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,6CAA6C;AACxD;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B,KAAK;;AAEL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,MAAM;AAC3B;;AAEA;AACA,qBAAqB,MAAM;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,0DAA0D;AACvE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,MAAM;AAC3B,QAAQ;AACR;AACA;;AAEA,aAAa,wBAAwB;AACrC;AACA;;AAEA;AACA;AACA,eAAe,kCAAkC,MAAM,GAAG;AAC1D;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,kCAAkC,MAAM,GAAG;AAC1D;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,MAAM;AAC1B;;AAEA;AACA,eAAe,OAAO;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ,EAAE,QAAQ,GAAG,WAAW;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;;AAEA;AACA,eAAe,oCAAoC;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,8BAA8B;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA,aAAa,6CAA6C;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,0CAA0C;AACzD;AACA;;AAEA,aAAa,yCAAyC;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,MAAM;AAC9B;;AAEA,eAAe,6BAA6B;AAC5C;AACA;;AAEA;AACA,eAAe,4CAA4C;AAC3D;AACA;;AAEA,aAAa,qCAAqC;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,2CAA2C;AAC1D;AACA;;AAEA;AACA,eAAe,qBAAqB;AACpC;AACA;;AAEA,aAAa,mCAAmC;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA;;AAEA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,MAAM;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,iCAAiC;AAChD;AACA;;AAEA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,aAAa;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,aAAa;;AAE1C;AACA,yBAAyB,eAAe,EAAE,cAAc,GAAG,cAAc,EAAE,IAAI;AAC/E;;AAEA;AACA;;AAEA;;AAEA,eAAe,uCAAuC;AACtD;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,cAAc,GAAG,eAAe,EAAE,cAAc;AAC9E;AACA;AACA;AACA,eAAe,uCAAuC;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ;AACR;AACA;;AAEA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qFAAqF;AACrF,oDAAoD;AACpD;AACA;;AAEA;AACA,WAAW,2CAA2C,cAAc,IAAI;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C,IAAI,oCAAoC,IAAI;AACvF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,eAAe,KAAK;AACpB;;AAEA;AACA;AACA,eAAe,QAAQ,QAAQ,aAAa,EAAE,oCAAoC;AAClF;;AAEA;AACA;AACA;AACA,kBAAkB,MAAM,EAAE,SAAS,EAAE,KAAK;;AAE1C;AACA,kBAAkB,YAAY,EAAE,SAAS,EAAE,KAAK;;AAEhD;AACA,kBAAkB,MAAM,EAAE,KAAK,EAAE,YAAY,EAAE,SAAS,EAAE,KAAK;;AAE/D;AACA,kBAAkB,MAAM,EAAE,KAAK,EAAE,cAAc,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK;;AAE5E;AACA;;AAEA;AACA,qBAAqB,MAAM,EAAE,eAAe,EAAE,cAAc,IAAI,SAAS,EAAE,SAAS,EAAE,KAAK;;AAE3F;AACA,qBAAqB,MAAM,EAAE,eAAe,EAAE,cAAc,IAAI,SAAS,EAAE,KAAK,EAAE,YAAY,EAAE,SAAS,EAAE,KAAK;;AAEhH;AACA,qBAAqB,MAAM,EAAE,eAAe,EAAE,cAAc,IAAI,YAAY,EAAE,SAAS,EAAE,KAAK;;AAE9F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;;AAEA;AACA;;AAEA;;;;;;;;;;;;AClkCa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,aAAa,mBAAO,CAAC,oDAAQ;AAC7B,cAAc,mBAAO,CAAC,sDAAS;AAC/B,cAAc,mBAAO,CAAC,sDAAS;AAC/B,kBAAkB,mBAAO,CAAC,8DAAa;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,YAAY,WAAW;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,YAAY,yBAAyB,0CAA0C,aAAa;AAC5F,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;;AAEA,2CAA2C,cAAc,IAAI;AAC7D;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,iDAAiD;AACjD;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA,0BAA0B,8BAA8B;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,QAAQ,KAAK,aAAa,GAAG,OAAO;AACtD;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrVa;;AAEb,cAAc,mBAAO,CAAC,sDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8DAAa;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACtYa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8DAAa;;AAEzB,gBAAgB;AAChB,qBAAqB;AACrB,mBAAmB;AACnB,mBAAmB;AACnB,sBAAsB;;AAEtB,yBAAyB;AACzB;AACA;AACA,GAAG;AACH;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA,YAAY,oBAAoB,IAAI,iBAAiB;AACrD;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB,cAAc;AACrD;AACA;;AAEA,kBAAkB,QAAQ,KAAK,MAAM,GAAG,OAAO;AAC/C;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;;;;;;;;;;;AC/Da;;AAEb,WAAW,mBAAO,CAAC,cAAI;AACvB,QAAQ,WAAW,EAAE,mBAAO,CAAC,sBAAQ;AACrC,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B,QAAQ,YAAY,EAAE,mBAAO,CAAC,kBAAM;AACpC,kBAAkB,mBAAO,CAAC,oDAAW;;AAErC;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,WAAW;AACzB,cAAc,YAAY;AAC1B,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB,YAAY,aAAa;;AAEzB;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,0BAA0B;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK,eAAe,cAAc;AAC/E;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,WAAW;AACzB,cAAc,WAAW;AACzB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B;AACA,oCAAoC;AACpC;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,iEAAiE,qBAAqB;AACtF;;AAEA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACzRA,CAAC,kBAAkB;AACnB,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,WAAW;AAClC;AACA,0BAA0B,mBAAmB,aAAa;AAC1D,yBAAyB,yBAAyB;AAClD,yBAAyB;AACzB;;AAEA;AACA;AACA,aAAa,oDAAwB;AACrC,IAAI;AACJ;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,iBAAiB,2EAAuC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,YAAY,OAAO,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA,CAAC,EAAE,MAA8B,GAAG,CAAa,CAAC;;;;;;;;;;;AC5hDlD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,2DAAc;AACtC;;AAEA,WAAW,mBAAO,CAAC,sBAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE,qBAAqB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE,sBAAsB;AACxB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,EAAE,mBAAmB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDa;AACb,WAAW,mBAAO,CAAC,cAAI;AACvB,YAAY,mBAAO,CAAC,gBAAK;AACzB,gBAAgB,mBAAO,CAAC,kDAAU;;AAElC,OAAO,KAAK;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,iBAAiB,mBAAO,CAAC,oDAAW;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;AACpC,IAAI;AACJ,yBAAyB,aAAa;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;;AAEA,MAAM;AACN;;AAEA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,SAAS;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE,kCAAkC;AACjD;AACA;AACA;;AAEA;AACA,aAAa,EAAE,EAAE,yBAAyB,EAAE,EAAE;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA,wBAAwB,IAAI,MAAM,OAAO,EAAE,MAAM;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD;;AAExD;AACA;AACA;;AAEA;;;;;;;;;;;AC/RA,uEAAuE;AACvE,MAAM,EAAC,GAAG,EAAE,aAAa,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAC,GAAG,mBAAO,CAAC,0BAAU,CAAC;AACrE,MAAM,IAAI,GAAG,mBAAO,CAAC,kBAAM,CAAC;AAC5B,IAAI,EAAE,GAAG,mBAAO,CAAC,cAAI,CAAC,CAAC;AACvB,MAAM,QAAQ,GAAG,mBAAO,CAAC,4EAAmB,CAAC,CAAC;AAC9C,MAAM,EAAE,MAAM,EAAE,GAAG,mBAAO,CAAC,8DAAc,CAAC,CAAC;AAC3C,MAAM,aAAa,GAAG,mBAAO,CAAC,8EAAwB,CAAC,CAAC;AACxD,MAAM,GAAG,GAAG,mBAAO,CAAC,8DAAc,CAAC,CAAC;AACpC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,GAAG,MAAM;AAClC,MAAM,EAAE,WAAW,EAAE,GAAG,mBAAO,CAAC,qEAAkB,CAAC,CAAC;AACpD,WAAW,CAAC,MAAM,GAAG,GAAG,CAAC;AAEzB,qCAAqC;AACrC,IAAI,IAAI,GAAG,GAAG,CAAC,yBAAyB,EAAE,CAAC;AAC3C,IAAI,CAAC,IAAI,EAAE;IACT,GAAG,CAAC,IAAI,EAAE,CAAC;CACZ;KAAM;IACL,GAAG,CAAC,EAAE,CAAC,iBAAiB,EAAE,GAAG,EAAE;QAC7B,gBAAgB,EAAE,CAAC;IACrB,CAAC,CAAC,CAAC;CACJ;AAED,0CAA0C;AAC1C,IAAI,WAAW,GAAG,QAAQ,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;AACpD,IAAI,WAAW,IAAI,IAAI;IAAE,WAAW,GAAG,IAAI,CAAC,CAAE,oBAAoB;AAClE,GAAG,CAAC,oBAAoB,CAAC,EAAC,WAAW,EAAE,WAAW,EAAC,CAAC,CAAC;AAGrD,uBAAuB;AACvB,WAAW,CAAC,aAAa,CAAC,mBAAmB,EAAE,GAAG,EAAE;IAClD,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;KACjD;AACH,CAAC,CAAC,CAAC;AAGH,SAAS,eAAe;IACtB,IAAI,QAAQ,GAAG,mBAAO,CAAC,0BAAU,CAAC,CAAC;IACnC,IAAI,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;IAC7B,IAAI,OAAO,GAAG,MAAM,CAAC,iBAAiB,EAAE,CAAC;IACzC,IAAI,EAAE,GAAG,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC;IACrC,IAAI,EAAE,GAAG,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC;IAEpC,IAAI,EAAE,GAAG,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;IACjC,IAAI,EAAE,GAAG,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;IAEjC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;IAChB,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;IAEhB,UAAU,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAE7B,UAAU,CAAC,IAAI,EAAE,CAAC;IAClB,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;IAChC,UAAU,CAAC,KAAK,EAAE,CAAC;AACrB,CAAC;AAGD,IAAI,UAAU,CAAC;AACf,SAAS,gBAAgB;IACvB,IAAI,UAAU,IAAI,IAAI,EAAE;QACtB,eAAe,EAAE,CAAC;QAClB,OAAO;KACR;IAED,sDAAsD;IACtD,IAAI,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,CAAC;IAE9D,kCAAkC;IAClC,IAAI,MAAM,GAAG,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,CAAC;IAC7D,IAAI,KAAK,CAAC,MAAM,CAAC,EAAE;QACjB,MAAM,GAAG,GAAG,CAAC;KACd;IAED,IAAI,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC,CAAC;IAC3D,IAAI,KAAK,CAAC,KAAK,CAAC,EAAE;QAChB,KAAK,GAAG,GAAG,CAAC;KACb;IAED,6BAA6B;IAC7B,UAAU,GAAG,IAAI,aAAa,CAAC;QAC7B,KAAK,EAAE,KAAK;QACZ,MAAM,EAAE,MAAM;QACd,SAAS,EAAE,GAAG;QACd,QAAQ,EAAE,GAAG;QACb,KAAK,EAAE,KAAK;QACZ,eAAe,EAAE,OAAO;QACxB,IAAI,EAAE,KAAK;QACX,IAAI,EAAE,SAAS,GAAG,qBAAqB;QAGvC,cAAc,EAAE;YACd,eAAe,EAAE,IAAI;YACrB,gBAAgB,EAAE,KAAK;YACvB,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,YAAY,CAAC;YAC3C,WAAW,EAAE,IAAI;SAClB;KACF,CAAC,CAAC;IACH,UAAU,CAAC,UAAU,EAAE,CAAC;IAExB,sCAAsC;IACtC,UAAU,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;IACtC,wCAAwC;IACxC,mBAAmB;IACnB,MAAM;IAGN,UAAU,CAAC,EAAE,CAAC,eAAe,EAAE,GAAG,EAAE;QAClC,eAAe,EAAE,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,EAAE;QAC3B,CAAC,CAAC,cAAc,EAAE,CAAC;QACnB,UAAU,CAAC,QAAQ,EAAE,CAAC;QACtB,UAAU,CAAC,IAAI,EAAE,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE,EAAE;QAC7B,IAAI,IAAI,GAAG,UAAU,CAAC,OAAO,EAAE,CAAC;QAChC,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QACpB,IAAI,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QAErB,QAAQ,CAAC,OAAO,CAAC,mBAAmB,EAAE,MAAM,CAAC,CAAC;QAC9C,QAAQ,CAAC,OAAO,CAAC,kBAAkB,EAAE,KAAK,CAAC,CAAC;IAE9C,CAAC,CAAC,CAAC;IAEH,4DAA4D;IAC5D,UAAU,CAAC,IAAI,CAAC,eAAe,EAAE,GAAG,EAAE;QACpC,WAAW,CAAC,wBAAwB,EAAE,CAAC;IACzC,CAAC,CAAC,CAAC;IAEH,aAAa,CAAC,QAAQ,CAAC,UAAU,EAAE,cAAc,EAAE,GAAG,EAAE;QACtD,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC;YAClC,IAAI,EAAE,QAAQ;SACf,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,cAAc;IACrB,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,yBAAyB,CAAC,CAAC;IAC/D,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC9B,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,CAAC;QACzC,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE;gBAC3C,gBAAgB,EAAE,CAAC;YACrB,CAAC,EAAE;QACH,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,UAAU,EAAE,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE;gBAC5D,oBAAoB;YACtB,CAAC,EAAE;QACH,EAAE,IAAI,EAAE,WAAW,EAAC;QACpB,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE;gBAC3C,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC;gBAEvB,YAAY,CAAC,UAAU,EAAE,CAAC;gBAE1B,GAAG,CAAC,IAAI,EAAE,CAAC;gBACX,OAAO,CAAC,IAAI,EAAE,CAAC;YACjB,CAAC,EAAC;KACH,CAAC;IACF,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC;IACrC,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;IAEjC,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;QACpB,GAAG,CAAC,KAAK,CAAC,YAAY,CAAC;QACvB,gBAAgB,EAAE,CAAC;IACrB,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,EAAE,CAAC,aAAa,EAAE,GAAG,EAAE;QAC1B,GAAG,CAAC,KAAK,CAAC,aAAa,CAAC;QACxB,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC1B,CAAC,CAAC;AACJ,CAAC;AAGD,wDAAwD;AACxD,yDAAyD;AACzD,sDAAsD;AACtD,GAAG,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE;IACxB,cAAc,EAAE,CAAC;IAGnB,kDAAkD;IAClD,sBAAsB;IAItB,GAAG,CAAC,EAAE,CAAC,UAAU,EAAE;QACf,iEAAiE;QACjE,4DAA4D;QAC5D,IAAI,aAAa,CAAC,aAAa,EAAE,CAAC,MAAM,KAAK,CAAC;YAAE,gBAAgB,EAAE;IACpE,CAAC,CAAC;AACJ,CAAC,CAAC,CAAC;AAEH,GAAG,CAAC,EAAE,CAAC,mBAAmB,EAAE,CAAC,CAAC,EAAE,EAAE;IAChC,GAAG,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC;AAElC,CAAC,CAAC,CAAC;AAEH,GAAG,CAAC,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;IACvB,GAAG,CAAC,KAAK,CAAC,wBAAwB,CAAC;AACrC,CAAC,CAAC;AAEF,GAAG,CAAC,EAAE,CAAC,aAAa,EAAE,CAAC,CAAC,EAAE,EAAE;IAC1B,oFAAoF;IACpF,CAAC,CAAC,cAAc,GAAG,KAAK,CAAC;IACzB,GAAG,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;IAC9B,YAAY,CAAC,UAAU,EAAE,CAAC;IAC1B,IAAI,CAAC,KAAK,EAAE,CAAC;AACf,CAAC,CAAC;AAEF,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE;IAC9C,QAAQ,CAAC,OAAO,CAAC,mBAAmB,EAAE,QAAQ,CAAC,CAAC;IAChD,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,cAAc,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;KAC/C;AACH,CAAC,CAAC,CAAC;AAEH,OAAO,CAAC,EAAE,CAAC,kBAAkB,EAAE,CAAC,CAAC,EAAE,WAAW,EAAE,EAAE;IAChD,GAAG,CAAC,oBAAoB,CAAC,EAAC,WAAW,EAAE,WAAW,EAAC,CAAC,CAAC;AACvD,CAAC,CAAC,CAAC;AAGH,oDAAoD;AACpD,OAAO,CAAC,EAAE,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE;IAC1C,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AAC1B,CAAC,CAAC,CAAC;AAEH,oDAAoD;AACpD,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE;IAC/C,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;IACxB,CAAC,CAAC,WAAW,GAAG,IAAI,CAAC;AACvB,CAAC,CAAC,CAAC;AAEH,OAAO,CAAC,EAAE,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;IACzC,IAAI,GAAG,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACjC,KAAK,CAAC,WAAW,GAAG,GAAG,CAAC;AAC1B,CAAC,CAAC,CAAC;AAGH,OAAO,CAAC,EAAE,CAAC,eAAe,EAAE,GAAG,EAAE;IAC/B,+BAA+B;AACjC,CAAC,CAAC,CAAC;AAEH,OAAO,CAAC,EAAE,CAAC,0BAA0B,EAAE,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE;IACnD,IAAI,qBAAqB,GAAG,OAAO,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC;IAElE,oDAAoD;IACpD,IAAI,aAAa,IAAI,IAAI,EAAE;QACzB,aAAa,CAAC,WAAW,CAAC,IAAI,CAAC,kBAAkB,EAAE,qBAAqB,CAAC,CAAC;KAC3E;AACH,CAAC,CAAC,CAAC;AAGH,OAAO,CAAC,EAAE,CAAC,iBAAiB,EAAE,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE;IAC1C,aAAa,CAAC,MAAM,CAAC,CAAC;AACxB,CAAC,CAAC,CAAC;AAEH,KAAK,UAAU,aAAa,CAAC,MAAM;IACjC,GAAG,CAAC,IAAI,CAAC,mCAAmC,MAAM,EAAE,CAAC;IACrD,8CAA8C;IAC9C,IAAI,MAAM,GAAG;QACX,IAAI,EAAE,GAAG;QACT,IAAI,EAAE,GAAG;QACT,OAAO,EAAE,CAAC,CAAC;QACX,IAAI,EAAE,CAAC,CAAC,CAAG,UAAU;KACtB;IAED,IAAI;QACF,IAAI,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;YACzB,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACnC,GAAG,CAAC,IAAI,CAAC,oBAAoB,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;YAC5C,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACpC,GAAG,CAAC,IAAI,CAAC,wBAAwB,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;YAChD,IAAI,KAAK,GAAG,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAChC,MAAM,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;YACzB,GAAG,CAAC,IAAI,CAAC,cAAc,MAAM,CAAC,IAAI,QAAQ,CAAC;YAE3C,oDAAoD;YACpD,GAAG,CAAC,IAAI,CAAC,0BAA0B,CAAC;YACpC,IAAI,gBAAgB,GAAG,yDAAyD,MAAM,GAAG,CAAC;YAC1F,IAAI,gBAAgB,GAAG;gBACrB,gBAAgB;gBAChB,iBAAiB,EAAE,EAAE;aACtB;YACD,MAAM,IAAI,GAAG,mBAAO,CAAC,mIAAM,CAAC,CAAC;YAC7B,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;YAExD,IAAI,MAAM,GAAG,MAAM,UAAU,CAAC,KAAK,CAAC,+CAA+C,CAAC,CAAC;YACrF,4BAA4B;YAC5B,IAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;YAC/B,GAAG,CAAC,IAAI,CAAC,gBAAgB,KAAK,UAAU,CAAC;YACzC,MAAM,CAAC,OAAO,GAAG,KAAK,CAAC;SACxB;aAAM;YACL,GAAG,CAAC,IAAI,CAAC,iCAAiC,MAAM,EAAE,CAAC,CAAC;YACpD,MAAK,CAAC,+BAA+B,CAAC;SACvC;KACF;IAAC,OAAO,GAAG,EAAE;QACZ,MAAM,CAAC,KAAK,GAAG,GAAG,CAAC;KACpB;YAAS;QACR,2CAA2C;QAC3C,IAAI,UAAU,EAAE;YACd,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;SACvD;KACF;AACH,CAAC;AAKD,8BAA8B;AAC9B,MAAM,YAAY,GAAG,mBAAO,CAAC,8IAAiB,CAAC,CAAC;AAChD,MAAM,YAAY,GAAG,IAAI,YAAY,EAAE,CAAC;AACxC,YAAY,CAAC,WAAW,CAAC,cAAc,EAAE,IAAI,CAAC,EAAE;IAC9C,GAAG,CAAC,KAAK,CAAC,6BAA6B,IAAI,EAAE,CAAC,CAAC;IAC/C,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;KACnD;AACH,CAAC,CAAC,CAAC;AAEH,YAAY,CAAC,WAAW,CAAC,iBAAiB,EAAE,IAAI,CAAC,EAAE;IACjD,GAAG,CAAC,KAAK,CAAC,gCAAgC,IAAI,EAAE,CAAC,CAAC;IAClD,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;KACtD;AACH,CAAC,CAAC,CAAC;AAEH,YAAY,CAAC,WAAW,CAAC,iBAAiB,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE;IAC7D,GAAG,CAAC,KAAK,CAAC,gCAAgC,IAAI,KAAK,QAAQ,EAAE,CAAC,CAAC;IAC/D,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;KAChE;AACH,CAAC,CAAC,CAAC;AAEH,YAAY,CAAC,WAAW,CAAC,gBAAgB,EAAE,IAAI,CAAC,EAAE;IAChD,GAAG,CAAC,KAAK,CAAC,+BAA+B,IAAI,EAAE,CAAC;IAChD,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;KACrD;AACH,CAAC,CAAC,CAAC;AAEH,YAAY,CAAC,WAAW,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;IACtD,IAAI,MAAM,GAAG,kBAAkB;IAC/B,IAAI,UAAU,GAAG,GAAG,CAAC;IACrB,sEAAsE;IACtE,IAAI,GAAG,CAAC,WAAW,CAAC,IAAI,GAAG,OAAO,EAAE;QAClC,IAAI,GAAG,CAAC,OAAO;YAAE,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC;QAC1C,6CAA6C;QAC7C,IAAI,GAAG,CAAC,UAAU,IAAI,IAAI,IAAI,GAAG,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;YACvD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC9C,IAAI,MAAM,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC/B,UAAU,GAAG,GAAG,UAAU,uBAAuB,MAAM,CAAC,IAAI,KAAK,MAAM,CAAC,OAAO,EAAE,CAAC;aACnF;SACF;QACD,IAAI,GAAG,CAAC,QAAQ,EAAE;YAChB,UAAU,GAAG,GAAG,UAAU,iCAAiC,GAAG,CAAC,QAAQ,EAAE,CAAC;SAC3E;QACD,IAAI,GAAG,CAAC,eAAe,EAAE;YACvB,UAAU,GAAG,GAAG,UAAU,sCAAsC,GAAG,CAAC,eAAe,EAAE,CAAC;SACvF;KACF;IACD,GAAG,CAAC,KAAK,CAAC,8BAA8B,IAAI,EAAE,CAAC;IAC/C,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;KACxE;AACH,CAAC,CAAC,CAAC;AAEH,YAAY,CAAC,WAAW,EAAE,CAAC;AAG3B,OAAO,CAAC,EAAE,CAAC,iBAAiB,EAAE,CAAC,CAAC,EAAE,UAAU,EAAE,EAAE;IAC9C,GAAG,CAAC,IAAI,CAAC,yBAAyB,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;IACrD,mDAAmD;IACnD,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;AACrC,CAAC,CAAC,CAAC;AAEH,OAAO,CAAC,EAAE,CAAC,oBAAoB,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;IAC3C,wDAAwD;IACxD,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;AAClC,CAAC,CAAC,CAAC;AAEH,OAAO,CAAC,EAAE,CAAC,oBAAoB,EAAE,CAAC,CAAC,EAAE,EAAE;IACrC,IAAI,MAAM,GAAG,wDAA0B,CAAC;IACxC,MAAM,OAAO,GAAG,MAAM,CAAC,kBAAkB,CAAC,UAAU,EAAE,EAAC,UAAU,EAAE,CAAC,eAAe,CAAC,EAAC,CAAC,CAAC;IACvF,CAAC,CAAC,WAAW,GAAG,OAAO,CAAC;AAC1B,CAAC,CAAC,CAAC;AAEH,OAAO,CAAC,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;IAC3B,WAAW,CAAC,cAAc,EAAE,CAAC;AAC/B,CAAC,CAAC,CAAC;AAGH,2DAA2D;AAC3D,IAAI,IAAI,GAAG,mBAAO,CAAC,8DAAa,CAAC,CAAC;AAClC,IAAI,OAAO,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC;AACjD,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC;AAC7B,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;IACrB,IAAI,UAAU,EAAE;QACd,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;KAC/C;AACH,CAAC,CAAC,CAAC;AACH,IAAI,CAAC,KAAK,EAAE,CAAC;;;;;;;;;;;AC9Yb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0FAA+B;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;;;;;;;;;;ACxBY;AACZ;AACA,mBAAmB;AACnB,0BAA0B;AAC1B,6BAA6B;;AAE7B,WAAW,mBAAO,CAAC,cAAI;AACvB,oBAAoB,mBAAO,CAAC,8DAAa;AACzC,eAAe,mBAAO,CAAC,wDAAa;AACpC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,qBAAqB,mBAAO,CAAC,4DAAe;AAC5C,2BAA2B,mBAAO,CAAC,0EAAsB;AACzD,QAAQ,YAAY,EAAE,mBAAO,CAAC,kBAAM;AACpC;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,mBAAO,CAAC,sCAAgB;;AAElD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2DAA2D;AAC3D;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClQY;AACZ;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;;;;;;;;;;;;ACPY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,0CAA0C,OAAO;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA,gCAAgC,iBAAiB;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6BAA6B;AACnE;AACA;AACA,SAAS,2BAA2B;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;AACA;AACA,SAAS,6BAA6B;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,8BAA8B;AACpE;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,EAAE,mBAAO,CAAC,yDAAe;AACzB,EAAE;;;;;;;;;;;;ACzaF;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WC5BA;WACA;WACA;WACA;WACA;;;;;UEJA;UACA;UACA;UACA","sources":["webpack://file_renamer/./node_modules/anymatch/index.js","webpack://file_renamer/./node_modules/binary-extensions/index.js","webpack://file_renamer/./node_modules/braces/index.js","webpack://file_renamer/./node_modules/braces/lib/compile.js","webpack://file_renamer/./node_modules/braces/lib/constants.js","webpack://file_renamer/./node_modules/braces/lib/expand.js","webpack://file_renamer/./node_modules/braces/lib/parse.js","webpack://file_renamer/./node_modules/braces/lib/stringify.js","webpack://file_renamer/./node_modules/braces/lib/utils.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/CancellationToken.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/ProgressCallbackTransform.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/bintray.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/httpExecutor.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/index.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/publishOptions.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/rfc2253Parser.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/uuid.js","webpack://file_renamer/./node_modules/builder-util-runtime/out/xml.js","webpack://file_renamer/./node_modules/chokidar/index.js","webpack://file_renamer/./node_modules/chokidar/lib/constants.js","webpack://file_renamer/./node_modules/chokidar/lib/fsevents-handler.js","webpack://file_renamer/./node_modules/chokidar/lib/nodefs-handler.js","webpack://file_renamer/./node_modules/debug/src/browser.js","webpack://file_renamer/./node_modules/debug/src/common.js","webpack://file_renamer/./node_modules/debug/src/index.js","webpack://file_renamer/./node_modules/debug/src/node.js","webpack://file_renamer/./node_modules/electron-is-accelerator/index.js","webpack://file_renamer/./node_modules/electron-localshortcut/index.js","webpack://file_renamer/./node_modules/electron-log/src/catchErrors.js","webpack://file_renamer/./node_modules/electron-log/src/electronApi.js","webpack://file_renamer/./node_modules/electron-log/src/index.js","webpack://file_renamer/./node_modules/electron-log/src/log.js","webpack://file_renamer/./node_modules/electron-log/src/scope.js","webpack://file_renamer/./node_modules/electron-log/src/transform/index.js","webpack://file_renamer/./node_modules/electron-log/src/transform/object.js","webpack://file_renamer/./node_modules/electron-log/src/transform/style.js","webpack://file_renamer/./node_modules/electron-log/src/transform/template.js","webpack://file_renamer/./node_modules/electron-log/src/transports/console.js","webpack://file_renamer/./node_modules/electron-log/src/transports/file/file.js","webpack://file_renamer/./node_modules/electron-log/src/transports/file/index.js","webpack://file_renamer/./node_modules/electron-log/src/transports/file/packageJson.js","webpack://file_renamer/./node_modules/electron-log/src/transports/file/variables.js","webpack://file_renamer/./node_modules/electron-log/src/transports/ipc.js","webpack://file_renamer/./node_modules/electron-log/src/transports/remote.js","webpack://file_renamer/./node_modules/electron-settings/dist/settings.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/copy/copy-sync.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/copy/copy.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/copy/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/empty/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/ensure/file.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/ensure/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/ensure/link.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink-type.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/ensure/symlink.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/fs/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/json/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/json/jsonfile.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/json/output-json-sync.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/json/output-json.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/make-dir.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/mkdirs/utils.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/move/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/move/move-sync.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/move/move.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/output-file/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/path-exists/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/remove/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/remove/rimraf.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/util/stat.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/fs-extra/lib/util/utimes.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/jsonfile/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/jsonfile/utils.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/classes/comparator.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/classes/range.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/classes/semver.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/clean.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/cmp.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/coerce.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/compare-build.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/compare-loose.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/compare.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/diff.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/eq.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/gt.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/gte.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/inc.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/lt.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/lte.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/major.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/minor.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/neq.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/parse.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/patch.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/prerelease.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/rcompare.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/rsort.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/satisfies.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/sort.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/functions/valid.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/index.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/internal/constants.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/internal/debug.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/internal/identifiers.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/internal/parse-options.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/internal/re.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/gtr.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/intersects.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/ltr.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/max-satisfying.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/min-satisfying.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/min-version.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/outside.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/simplify.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/subset.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/to-comparators.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/semver/ranges/valid.js","webpack://file_renamer/./node_modules/electron-updater/node_modules/universalify/index.js","webpack://file_renamer/./node_modules/electron-updater/out/AppAdapter.js","webpack://file_renamer/./node_modules/electron-updater/out/AppImageUpdater.js","webpack://file_renamer/./node_modules/electron-updater/out/AppUpdater.js","webpack://file_renamer/./node_modules/electron-updater/out/BaseUpdater.js","webpack://file_renamer/./node_modules/electron-updater/out/DownloadedUpdateHelper.js","webpack://file_renamer/./node_modules/electron-updater/out/ElectronAppAdapter.js","webpack://file_renamer/./node_modules/electron-updater/out/MacUpdater.js","webpack://file_renamer/./node_modules/electron-updater/out/NsisUpdater.js","webpack://file_renamer/./node_modules/electron-updater/out/differentialDownloader/DataSplitter.js","webpack://file_renamer/./node_modules/electron-updater/out/differentialDownloader/DifferentialDownloader.js","webpack://file_renamer/./node_modules/electron-updater/out/differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader.js","webpack://file_renamer/./node_modules/electron-updater/out/differentialDownloader/GenericDifferentialDownloader.js","webpack://file_renamer/./node_modules/electron-updater/out/differentialDownloader/ProgressDifferentialDownloadCallbackTransform.js","webpack://file_renamer/./node_modules/electron-updater/out/differentialDownloader/downloadPlanBuilder.js","webpack://file_renamer/./node_modules/electron-updater/out/differentialDownloader/multipleRangeDownloader.js","webpack://file_renamer/./node_modules/electron-updater/out/electronHttpExecutor.js","webpack://file_renamer/./node_modules/electron-updater/out/main.js","webpack://file_renamer/./node_modules/electron-updater/out/providerFactory.js","webpack://file_renamer/./node_modules/electron-updater/out/providers/BintrayProvider.js","webpack://file_renamer/./node_modules/electron-updater/out/providers/BitbucketProvider.js","webpack://file_renamer/./node_modules/electron-updater/out/providers/GenericProvider.js","webpack://file_renamer/./node_modules/electron-updater/out/providers/GitHubProvider.js","webpack://file_renamer/./node_modules/electron-updater/out/providers/KeygenProvider.js","webpack://file_renamer/./node_modules/electron-updater/out/providers/PrivateGitHubProvider.js","webpack://file_renamer/./node_modules/electron-updater/out/providers/Provider.js","webpack://file_renamer/./node_modules/electron-updater/out/util.js","webpack://file_renamer/./node_modules/electron-updater/out/windowsExecutableCodeSignatureVerifier.js","webpack://file_renamer/./node_modules/fill-range/index.js","webpack://file_renamer/./node_modules/glob-parent/index.js","webpack://file_renamer/./node_modules/graceful-fs/clone.js","webpack://file_renamer/./node_modules/graceful-fs/graceful-fs.js","webpack://file_renamer/./node_modules/graceful-fs/legacy-streams.js","webpack://file_renamer/./node_modules/graceful-fs/polyfills.js","webpack://file_renamer/./node_modules/has-flag/index.js","webpack://file_renamer/./node_modules/imurmurhash/imurmurhash.js","webpack://file_renamer/./node_modules/is-binary-path/index.js","webpack://file_renamer/./node_modules/is-extglob/index.js","webpack://file_renamer/./node_modules/is-glob/index.js","webpack://file_renamer/./node_modules/is-number/index.js","webpack://file_renamer/./node_modules/is-typedarray/index.js","webpack://file_renamer/./node_modules/js-yaml/index.js","webpack://file_renamer/./node_modules/js-yaml/lib/common.js","webpack://file_renamer/./node_modules/js-yaml/lib/dumper.js","webpack://file_renamer/./node_modules/js-yaml/lib/exception.js","webpack://file_renamer/./node_modules/js-yaml/lib/loader.js","webpack://file_renamer/./node_modules/js-yaml/lib/schema.js","webpack://file_renamer/./node_modules/js-yaml/lib/schema/core.js","webpack://file_renamer/./node_modules/js-yaml/lib/schema/default.js","webpack://file_renamer/./node_modules/js-yaml/lib/schema/failsafe.js","webpack://file_renamer/./node_modules/js-yaml/lib/schema/json.js","webpack://file_renamer/./node_modules/js-yaml/lib/snippet.js","webpack://file_renamer/./node_modules/js-yaml/lib/type.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/binary.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/bool.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/float.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/int.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/map.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/merge.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/null.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/omap.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/pairs.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/seq.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/set.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/str.js","webpack://file_renamer/./node_modules/js-yaml/lib/type/timestamp.js","webpack://file_renamer/./node_modules/keyboardevent-from-electron-accelerator/index.js","webpack://file_renamer/./node_modules/keyboardevents-areequal/index.js","webpack://file_renamer/./node_modules/lazy-val/out/main.js","webpack://file_renamer/./node_modules/lodash.escaperegexp/index.js","webpack://file_renamer/./node_modules/lodash.get/index.js","webpack://file_renamer/./node_modules/lodash.has/index.js","webpack://file_renamer/./node_modules/lodash.isequal/index.js","webpack://file_renamer/./node_modules/lodash.set/index.js","webpack://file_renamer/./node_modules/lodash.unset/index.js","webpack://file_renamer/./node_modules/lru-cache/index.js","webpack://file_renamer/./node_modules/mkdirp/index.js","webpack://file_renamer/./node_modules/mkdirp/lib/find-made.js","webpack://file_renamer/./node_modules/mkdirp/lib/mkdirp-manual.js","webpack://file_renamer/./node_modules/mkdirp/lib/mkdirp-native.js","webpack://file_renamer/./node_modules/mkdirp/lib/opts-arg.js","webpack://file_renamer/./node_modules/mkdirp/lib/path-arg.js","webpack://file_renamer/./node_modules/mkdirp/lib/use-native.js","webpack://file_renamer/./node_modules/ms/index.js","webpack://file_renamer/./node_modules/nodejs-tail/nodejs-tail.js","webpack://file_renamer/./node_modules/normalize-path/index.js","webpack://file_renamer/./node_modules/picomatch/index.js","webpack://file_renamer/./node_modules/picomatch/lib/constants.js","webpack://file_renamer/./node_modules/picomatch/lib/parse.js","webpack://file_renamer/./node_modules/picomatch/lib/picomatch.js","webpack://file_renamer/./node_modules/picomatch/lib/scan.js","webpack://file_renamer/./node_modules/picomatch/lib/utils.js","webpack://file_renamer/./node_modules/readdirp/index.js","webpack://file_renamer/./node_modules/sax/lib/sax.js","webpack://file_renamer/./node_modules/signal-exit/index.js","webpack://file_renamer/./node_modules/signal-exit/signals.js","webpack://file_renamer/./node_modules/supports-color/index.js","webpack://file_renamer/./node_modules/to-regex-range/index.js","webpack://file_renamer/./src/main.ts","webpack://file_renamer/./node_modules/typedarray-to-buffer/index.js","webpack://file_renamer/./node_modules/write-file-atomic/index.js","webpack://file_renamer/./node_modules/yallist/iterator.js","webpack://file_renamer/./node_modules/yallist/yallist.js","webpack://file_renamer/external node-commonjs \"assert\"","webpack://file_renamer/external node-commonjs \"child_process\"","webpack://file_renamer/external node-commonjs \"constants\"","webpack://file_renamer/external node-commonjs \"crypto\"","webpack://file_renamer/external node-commonjs \"electron\"","webpack://file_renamer/external node-commonjs \"events\"","webpack://file_renamer/external node-commonjs \"fs\"","webpack://file_renamer/external node-commonjs \"fs/promises\"","webpack://file_renamer/external node-commonjs \"http\"","webpack://file_renamer/external node-commonjs \"https\"","webpack://file_renamer/external node-commonjs \"os\"","webpack://file_renamer/external node-commonjs \"path\"","webpack://file_renamer/external node-commonjs \"querystring\"","webpack://file_renamer/external node-commonjs \"stream\"","webpack://file_renamer/external node-commonjs \"string_decoder\"","webpack://file_renamer/external node-commonjs \"tty\"","webpack://file_renamer/external node-commonjs \"url\"","webpack://file_renamer/external node-commonjs \"util\"","webpack://file_renamer/external node-commonjs \"worker_threads\"","webpack://file_renamer/external node-commonjs \"zlib\"","webpack://file_renamer/webpack/bootstrap","webpack://file_renamer/webpack/runtime/node module decorator","webpack://file_renamer/webpack/before-startup","webpack://file_renamer/webpack/startup","webpack://file_renamer/webpack/after-startup"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n","module.exports = require('./binary-extensions.json');\n","'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n","'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n","'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n","'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n","'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n","'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CancellationError = exports.CancellationToken = void 0;\nconst events_1 = require(\"events\");\nclass CancellationToken extends events_1.EventEmitter {\n    // babel cannot compile ... correctly for super calls\n    constructor(parent) {\n        super();\n        this.parentCancelHandler = null;\n        this._parent = null;\n        this._cancelled = false;\n        if (parent != null) {\n            this.parent = parent;\n        }\n    }\n    get cancelled() {\n        return this._cancelled || (this._parent != null && this._parent.cancelled);\n    }\n    set parent(value) {\n        this.removeParentCancelHandler();\n        this._parent = value;\n        this.parentCancelHandler = () => this.cancel();\n        this._parent.onCancel(this.parentCancelHandler);\n    }\n    cancel() {\n        this._cancelled = true;\n        this.emit(\"cancel\");\n    }\n    onCancel(handler) {\n        if (this.cancelled) {\n            handler();\n        }\n        else {\n            this.once(\"cancel\", handler);\n        }\n    }\n    createPromise(callback) {\n        if (this.cancelled) {\n            return Promise.reject(new CancellationError());\n        }\n        const finallyHandler = () => {\n            if (cancelHandler != null) {\n                try {\n                    this.removeListener(\"cancel\", cancelHandler);\n                    cancelHandler = null;\n                }\n                catch (ignore) {\n                    // ignore\n                }\n            }\n        };\n        let cancelHandler = null;\n        return new Promise((resolve, reject) => {\n            let addedCancelHandler = null;\n            cancelHandler = () => {\n                try {\n                    if (addedCancelHandler != null) {\n                        addedCancelHandler();\n                        addedCancelHandler = null;\n                    }\n                }\n                finally {\n                    reject(new CancellationError());\n                }\n            };\n            if (this.cancelled) {\n                cancelHandler();\n                return;\n            }\n            this.onCancel(cancelHandler);\n            callback(resolve, reject, (callback) => {\n                addedCancelHandler = callback;\n            });\n        })\n            .then(it => {\n            finallyHandler();\n            return it;\n        })\n            .catch(e => {\n            finallyHandler();\n            throw e;\n        });\n    }\n    removeParentCancelHandler() {\n        const parent = this._parent;\n        if (parent != null && this.parentCancelHandler != null) {\n            parent.removeListener(\"cancel\", this.parentCancelHandler);\n            this.parentCancelHandler = null;\n        }\n    }\n    dispose() {\n        try {\n            this.removeParentCancelHandler();\n        }\n        finally {\n            this.removeAllListeners();\n            this._parent = null;\n        }\n    }\n}\nexports.CancellationToken = CancellationToken;\nclass CancellationError extends Error {\n    constructor() {\n        super(\"cancelled\");\n    }\n}\nexports.CancellationError = CancellationError;\n//# sourceMappingURL=CancellationToken.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProgressCallbackTransform = void 0;\nconst stream_1 = require(\"stream\");\nclass ProgressCallbackTransform extends stream_1.Transform {\n    constructor(total, cancellationToken, onProgress) {\n        super();\n        this.total = total;\n        this.cancellationToken = cancellationToken;\n        this.onProgress = onProgress;\n        this.start = Date.now();\n        this.transferred = 0;\n        this.delta = 0;\n        this.nextUpdate = this.start + 1000;\n    }\n    _transform(chunk, encoding, callback) {\n        if (this.cancellationToken.cancelled) {\n            callback(new Error(\"cancelled\"), null);\n            return;\n        }\n        this.transferred += chunk.length;\n        this.delta += chunk.length;\n        const now = Date.now();\n        if (now >= this.nextUpdate && this.transferred !== this.total /* will be emitted on _flush */) {\n            this.nextUpdate = now + 1000;\n            this.onProgress({\n                total: this.total,\n                delta: this.delta,\n                transferred: this.transferred,\n                percent: (this.transferred / this.total) * 100,\n                bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1000)),\n            });\n            this.delta = 0;\n        }\n        callback(null, chunk);\n    }\n    _flush(callback) {\n        if (this.cancellationToken.cancelled) {\n            callback(new Error(\"cancelled\"));\n            return;\n        }\n        this.onProgress({\n            total: this.total,\n            delta: this.delta,\n            transferred: this.total,\n            percent: 100,\n            bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1000)),\n        });\n        this.delta = 0;\n        callback(null);\n    }\n}\nexports.ProgressCallbackTransform = ProgressCallbackTransform;\n//# sourceMappingURL=ProgressCallbackTransform.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BintrayClient = void 0;\nconst httpExecutor_1 = require(\"./httpExecutor\");\nclass BintrayClient {\n    constructor(options, httpExecutor, cancellationToken, apiKey) {\n        this.httpExecutor = httpExecutor;\n        this.cancellationToken = cancellationToken;\n        this.requestHeaders = null;\n        if (options.owner == null) {\n            throw new Error(\"owner is not specified\");\n        }\n        if (options.package == null) {\n            throw new Error(\"package is not specified\");\n        }\n        this.repo = options.repo || \"generic\";\n        this.packageName = options.package;\n        this.owner = options.owner;\n        this.user = options.user || options.owner;\n        this.component = options.component || null;\n        this.distribution = options.distribution || \"stable\";\n        this.auth = apiKey == null ? null : `Basic ${Buffer.from(`${this.user}:${apiKey}`).toString(\"base64\")}`;\n        this.basePath = `/packages/${this.owner}/${this.repo}/${this.packageName}`;\n    }\n    setRequestHeaders(value) {\n        this.requestHeaders = value;\n    }\n    bintrayRequest(path, auth, data = null, cancellationToken, method) {\n        return httpExecutor_1.parseJson(this.httpExecutor.request(httpExecutor_1.configureRequestOptions({ hostname: \"api.bintray.com\", path, headers: this.requestHeaders || undefined }, auth, method), cancellationToken, data));\n    }\n    getVersion(version) {\n        return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken);\n    }\n    getVersionFiles(version) {\n        return this.bintrayRequest(`${this.basePath}/versions/${version}/files`, this.auth, null, this.cancellationToken);\n    }\n    createVersion(version) {\n        return this.bintrayRequest(`${this.basePath}/versions`, this.auth, {\n            name: version,\n        }, this.cancellationToken);\n    }\n    deleteVersion(version) {\n        return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken, \"DELETE\");\n    }\n}\nexports.BintrayClient = BintrayClient;\n//# sourceMappingURL=bintray.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.safeStringifyJson = exports.configureRequestOptions = exports.safeGetHeader = exports.DigestTransform = exports.configureRequestUrl = exports.configureRequestOptionsFromUrl = exports.HttpExecutor = exports.parseJson = exports.HttpError = exports.createHttpError = void 0;\nconst crypto_1 = require(\"crypto\");\nconst debug_1 = require(\"debug\");\nconst fs_1 = require(\"fs\");\nconst stream_1 = require(\"stream\");\nconst url_1 = require(\"url\");\nconst CancellationToken_1 = require(\"./CancellationToken\");\nconst index_1 = require(\"./index\");\nconst ProgressCallbackTransform_1 = require(\"./ProgressCallbackTransform\");\nconst debug = debug_1.default(\"electron-builder\");\nfunction createHttpError(response, description = null) {\n    return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` +\n        (description == null ? \"\" : \"\\n\" + JSON.stringify(description, null, \"  \")) +\n        \"\\nHeaders: \" +\n        safeStringifyJson(response.headers), description);\n}\nexports.createHttpError = createHttpError;\nconst HTTP_STATUS_CODES = new Map([\n    [429, \"Too many requests\"],\n    [400, \"Bad request\"],\n    [403, \"Forbidden\"],\n    [404, \"Not found\"],\n    [405, \"Method not allowed\"],\n    [406, \"Not acceptable\"],\n    [408, \"Request timeout\"],\n    [413, \"Request entity too large\"],\n    [500, \"Internal server error\"],\n    [502, \"Bad gateway\"],\n    [503, \"Service unavailable\"],\n    [504, \"Gateway timeout\"],\n    [505, \"HTTP version not supported\"],\n]);\nclass HttpError extends Error {\n    constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {\n        super(message);\n        this.statusCode = statusCode;\n        this.description = description;\n        this.name = \"HttpError\";\n        this.code = `HTTP_ERROR_${statusCode}`;\n    }\n    isServerError() {\n        return this.statusCode >= 500 && this.statusCode <= 599;\n    }\n}\nexports.HttpError = HttpError;\nfunction parseJson(result) {\n    return result.then(it => (it == null || it.length === 0 ? null : JSON.parse(it)));\n}\nexports.parseJson = parseJson;\nclass HttpExecutor {\n    constructor() {\n        this.maxRedirects = 10;\n    }\n    request(options, cancellationToken = new CancellationToken_1.CancellationToken(), data) {\n        configureRequestOptions(options);\n        const json = data == null ? undefined : JSON.stringify(data);\n        const encodedData = json ? Buffer.from(json) : undefined;\n        if (encodedData != null) {\n            debug(json);\n            const { headers, ...opts } = options;\n            options = {\n                method: \"post\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Content-Length\": encodedData.length,\n                    ...headers,\n                },\n                ...opts,\n            };\n        }\n        return this.doApiRequest(options, cancellationToken, it => it.end(encodedData));\n    }\n    doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {\n        if (debug.enabled) {\n            debug(`Request: ${safeStringifyJson(options)}`);\n        }\n        return cancellationToken.createPromise((resolve, reject, onCancel) => {\n            const request = this.createRequest(options, (response) => {\n                try {\n                    this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n            this.addErrorAndTimeoutHandlers(request, reject);\n            this.addRedirectHandlers(request, options, reject, redirectCount, options => {\n                this.doApiRequest(options, cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);\n            });\n            requestProcessor(request, reject);\n            onCancel(() => request.abort());\n        });\n    }\n    // noinspection JSUnusedLocalSymbols\n    // eslint-disable-next-line\n    addRedirectHandlers(request, options, reject, redirectCount, handler) {\n        // not required for NodeJS\n    }\n    addErrorAndTimeoutHandlers(request, reject) {\n        this.addTimeOutHandler(request, reject);\n        request.on(\"error\", reject);\n        request.on(\"aborted\", () => {\n            reject(new Error(\"Request has been aborted by the server\"));\n        });\n    }\n    handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor) {\n        var _a;\n        if (debug.enabled) {\n            debug(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);\n        }\n        // we handle any other >= 400 error on request end (read detailed message in the response body)\n        if (response.statusCode === 404) {\n            // error is clear, we don't need to read detailed error description\n            reject(createHttpError(response, `method: ${options.method || \"GET\"} url: ${options.protocol || \"https:\"}//${options.hostname}${options.port ? `:${options.port}` : \"\"}${options.path}\n\nPlease double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.\n`));\n            return;\n        }\n        else if (response.statusCode === 204) {\n            // on DELETE request\n            resolve();\n            return;\n        }\n        const code = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0;\n        const shouldRedirect = code >= 300 && code < 400;\n        const redirectUrl = safeGetHeader(response, \"location\");\n        if (shouldRedirect && redirectUrl != null) {\n            if (redirectCount > this.maxRedirects) {\n                reject(this.createMaxRedirectError());\n                return;\n            }\n            this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);\n            return;\n        }\n        response.setEncoding(\"utf8\");\n        let data = \"\";\n        response.on(\"error\", reject);\n        response.on(\"data\", (chunk) => (data += chunk));\n        response.on(\"end\", () => {\n            try {\n                if (response.statusCode != null && response.statusCode >= 400) {\n                    const contentType = safeGetHeader(response, \"content-type\");\n                    const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find(it => it.includes(\"json\")) != null : contentType.includes(\"json\"));\n                    reject(createHttpError(response, `method: ${options.method || \"GET\"} url: ${options.protocol || \"https:\"}//${options.hostname}${options.port ? `:${options.port}` : \"\"}${options.path}\n\n          Data:\n          ${isJson ? JSON.stringify(JSON.parse(data)) : data}\n          `));\n                }\n                else {\n                    resolve(data.length === 0 ? null : data);\n                }\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    }\n    async downloadToBuffer(url, options) {\n        return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {\n            let result = null;\n            const requestOptions = {\n                headers: options.headers || undefined,\n                // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually\n                redirect: \"manual\",\n            };\n            configureRequestUrl(url, requestOptions);\n            configureRequestOptions(requestOptions);\n            this.doDownload(requestOptions, {\n                destination: null,\n                options,\n                onCancel,\n                callback: error => {\n                    if (error == null) {\n                        resolve(result);\n                    }\n                    else {\n                        reject(error);\n                    }\n                },\n                responseHandler: (response, callback) => {\n                    const contentLength = safeGetHeader(response, \"content-length\");\n                    let position = -1;\n                    if (contentLength != null) {\n                        const size = parseInt(contentLength, 10);\n                        if (size > 0) {\n                            if (size > 524288000) {\n                                callback(new Error(\"Maximum allowed size is 500 MB\"));\n                                return;\n                            }\n                            result = Buffer.alloc(size);\n                            position = 0;\n                        }\n                    }\n                    response.on(\"data\", (chunk) => {\n                        if (position !== -1) {\n                            chunk.copy(result, position);\n                            position += chunk.length;\n                        }\n                        else if (result == null) {\n                            result = chunk;\n                        }\n                        else {\n                            if (result.length > 524288000) {\n                                callback(new Error(\"Maximum allowed size is 500 MB\"));\n                                return;\n                            }\n                            result = Buffer.concat([result, chunk]);\n                        }\n                    });\n                    response.on(\"end\", () => {\n                        if (result != null && position !== -1 && position !== result.length) {\n                            callback(new Error(`Received data length ${position} is not equal to expected ${result.length}`));\n                        }\n                        else {\n                            callback(null);\n                        }\n                    });\n                },\n            }, 0);\n        });\n    }\n    doDownload(requestOptions, options, redirectCount) {\n        const request = this.createRequest(requestOptions, (response) => {\n            if (response.statusCode >= 400) {\n                options.callback(new Error(`Cannot download \"${requestOptions.protocol || \"https:\"}//${requestOptions.hostname}${requestOptions.path}\", status ${response.statusCode}: ${response.statusMessage}`));\n                return;\n            }\n            // It is possible for the response stream to fail, e.g. when a network is lost while\n            // response stream is in progress. Stop waiting and reject so consumer can catch the error.\n            response.on(\"error\", options.callback);\n            // this code not relevant for Electron (redirect event instead handled)\n            const redirectUrl = safeGetHeader(response, \"location\");\n            if (redirectUrl != null) {\n                if (redirectCount < this.maxRedirects) {\n                    this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);\n                }\n                else {\n                    options.callback(this.createMaxRedirectError());\n                }\n                return;\n            }\n            if (options.responseHandler == null) {\n                configurePipes(options, response);\n            }\n            else {\n                options.responseHandler(response, options.callback);\n            }\n        });\n        this.addErrorAndTimeoutHandlers(request, options.callback);\n        this.addRedirectHandlers(request, requestOptions, options.callback, redirectCount, requestOptions => {\n            this.doDownload(requestOptions, options, redirectCount++);\n        });\n        request.end();\n    }\n    createMaxRedirectError() {\n        return new Error(`Too many redirects (> ${this.maxRedirects})`);\n    }\n    addTimeOutHandler(request, callback) {\n        request.on(\"socket\", (socket) => {\n            socket.setTimeout(60 * 1000, () => {\n                request.abort();\n                callback(new Error(\"Request timed out\"));\n            });\n        });\n    }\n    static prepareRedirectUrlOptions(redirectUrl, options) {\n        const newOptions = configureRequestOptionsFromUrl(redirectUrl, { ...options });\n        const headers = newOptions.headers;\n        if (headers === null || headers === void 0 ? void 0 : headers.authorization) {\n            const parsedNewUrl = new url_1.URL(redirectUrl);\n            if (parsedNewUrl.hostname.endsWith(\".amazonaws.com\") || parsedNewUrl.searchParams.has(\"X-Amz-Credential\")) {\n                delete headers.authorization;\n            }\n        }\n        return newOptions;\n    }\n    static retryOnServerError(task, maxRetries = 3) {\n        for (let attemptNumber = 0;; attemptNumber++) {\n            try {\n                return task();\n            }\n            catch (e) {\n                if (attemptNumber < maxRetries && ((e instanceof HttpError && e.isServerError()) || e.code === \"EPIPE\")) {\n                    continue;\n                }\n                throw e;\n            }\n        }\n    }\n}\nexports.HttpExecutor = HttpExecutor;\nfunction configureRequestOptionsFromUrl(url, options) {\n    const result = configureRequestOptions(options);\n    configureRequestUrl(new url_1.URL(url), result);\n    return result;\n}\nexports.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;\nfunction configureRequestUrl(url, options) {\n    options.protocol = url.protocol;\n    options.hostname = url.hostname;\n    if (url.port) {\n        options.port = url.port;\n    }\n    else if (options.port) {\n        delete options.port;\n    }\n    options.path = url.pathname + url.search;\n}\nexports.configureRequestUrl = configureRequestUrl;\nclass DigestTransform extends stream_1.Transform {\n    constructor(expected, algorithm = \"sha512\", encoding = \"base64\") {\n        super();\n        this.expected = expected;\n        this.algorithm = algorithm;\n        this.encoding = encoding;\n        this._actual = null;\n        this.isValidateOnEnd = true;\n        this.digester = crypto_1.createHash(algorithm);\n    }\n    // noinspection JSUnusedGlobalSymbols\n    get actual() {\n        return this._actual;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    _transform(chunk, encoding, callback) {\n        this.digester.update(chunk);\n        callback(null, chunk);\n    }\n    // noinspection JSUnusedGlobalSymbols\n    _flush(callback) {\n        this._actual = this.digester.digest(this.encoding);\n        if (this.isValidateOnEnd) {\n            try {\n                this.validate();\n            }\n            catch (e) {\n                callback(e);\n                return;\n            }\n        }\n        callback(null);\n    }\n    validate() {\n        if (this._actual == null) {\n            throw index_1.newError(\"Not finished yet\", \"ERR_STREAM_NOT_FINISHED\");\n        }\n        if (this._actual !== this.expected) {\n            throw index_1.newError(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, \"ERR_CHECKSUM_MISMATCH\");\n        }\n        return null;\n    }\n}\nexports.DigestTransform = DigestTransform;\nfunction checkSha2(sha2Header, sha2, callback) {\n    if (sha2Header != null && sha2 != null && sha2Header !== sha2) {\n        callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));\n        return false;\n    }\n    return true;\n}\nfunction safeGetHeader(response, headerKey) {\n    const value = response.headers[headerKey];\n    if (value == null) {\n        return null;\n    }\n    else if (Array.isArray(value)) {\n        // electron API\n        return value.length === 0 ? null : value[value.length - 1];\n    }\n    else {\n        return value;\n    }\n}\nexports.safeGetHeader = safeGetHeader;\nfunction configurePipes(options, response) {\n    if (!checkSha2(safeGetHeader(response, \"X-Checksum-Sha2\"), options.options.sha2, options.callback)) {\n        return;\n    }\n    const streams = [];\n    if (options.options.onProgress != null) {\n        const contentLength = safeGetHeader(response, \"content-length\");\n        if (contentLength != null) {\n            streams.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));\n        }\n    }\n    const sha512 = options.options.sha512;\n    if (sha512 != null) {\n        streams.push(new DigestTransform(sha512, \"sha512\", sha512.length === 128 && !sha512.includes(\"+\") && !sha512.includes(\"Z\") && !sha512.includes(\"=\") ? \"hex\" : \"base64\"));\n    }\n    else if (options.options.sha2 != null) {\n        streams.push(new DigestTransform(options.options.sha2, \"sha256\", \"hex\"));\n    }\n    const fileOut = fs_1.createWriteStream(options.destination);\n    streams.push(fileOut);\n    let lastStream = response;\n    for (const stream of streams) {\n        stream.on(\"error\", (error) => {\n            if (!options.options.cancellationToken.cancelled) {\n                options.callback(error);\n            }\n        });\n        lastStream = lastStream.pipe(stream);\n    }\n    fileOut.on(\"finish\", () => {\n        ;\n        fileOut.close(options.callback);\n    });\n}\nfunction configureRequestOptions(options, token, method) {\n    if (method != null) {\n        options.method = method;\n    }\n    options.headers = { ...options.headers };\n    const headers = options.headers;\n    if (token != null) {\n        ;\n        headers.authorization = token.startsWith(\"Basic\") || token.startsWith(\"Bearer\") ? token : `token ${token}`;\n    }\n    if (headers[\"User-Agent\"] == null) {\n        headers[\"User-Agent\"] = \"electron-builder\";\n    }\n    if (method == null || method === \"GET\" || headers[\"Cache-Control\"] == null) {\n        headers[\"Cache-Control\"] = \"no-cache\";\n    }\n    // do not specify for node (in any case we use https module)\n    if (options.protocol == null && process.versions.electron != null) {\n        options.protocol = \"https:\";\n    }\n    return options;\n}\nexports.configureRequestOptions = configureRequestOptions;\nfunction safeStringifyJson(data, skippedNames) {\n    return JSON.stringify(data, (name, value) => {\n        if (name.endsWith(\"Authorization\") ||\n            name.endsWith(\"authorization\") ||\n            name.endsWith(\"Password\") ||\n            name.endsWith(\"PASSWORD\") ||\n            name.endsWith(\"Token\") ||\n            name.includes(\"password\") ||\n            name.includes(\"token\") ||\n            (skippedNames != null && skippedNames.has(name))) {\n            return \"<stripped sensitive data>\";\n        }\n        return value;\n    }, 2);\n}\nexports.safeStringifyJson = safeStringifyJson;\n//# sourceMappingURL=httpExecutor.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.newError = exports.asArray = exports.CURRENT_APP_PACKAGE_FILE_NAME = exports.CURRENT_APP_INSTALLER_FILE_NAME = exports.XElement = exports.parseXml = exports.ProgressCallbackTransform = exports.UUID = exports.parseDn = exports.githubUrl = exports.getS3LikeProviderBaseUrl = exports.configureRequestUrl = exports.parseJson = exports.safeStringifyJson = exports.configureRequestOptionsFromUrl = exports.configureRequestOptions = exports.safeGetHeader = exports.DigestTransform = exports.HttpExecutor = exports.createHttpError = exports.HttpError = exports.CancellationError = exports.CancellationToken = void 0;\nvar CancellationToken_1 = require(\"./CancellationToken\");\nObject.defineProperty(exports, \"CancellationToken\", { enumerable: true, get: function () { return CancellationToken_1.CancellationToken; } });\nObject.defineProperty(exports, \"CancellationError\", { enumerable: true, get: function () { return CancellationToken_1.CancellationError; } });\nvar httpExecutor_1 = require(\"./httpExecutor\");\nObject.defineProperty(exports, \"HttpError\", { enumerable: true, get: function () { return httpExecutor_1.HttpError; } });\nObject.defineProperty(exports, \"createHttpError\", { enumerable: true, get: function () { return httpExecutor_1.createHttpError; } });\nObject.defineProperty(exports, \"HttpExecutor\", { enumerable: true, get: function () { return httpExecutor_1.HttpExecutor; } });\nObject.defineProperty(exports, \"DigestTransform\", { enumerable: true, get: function () { return httpExecutor_1.DigestTransform; } });\nObject.defineProperty(exports, \"safeGetHeader\", { enumerable: true, get: function () { return httpExecutor_1.safeGetHeader; } });\nObject.defineProperty(exports, \"configureRequestOptions\", { enumerable: true, get: function () { return httpExecutor_1.configureRequestOptions; } });\nObject.defineProperty(exports, \"configureRequestOptionsFromUrl\", { enumerable: true, get: function () { return httpExecutor_1.configureRequestOptionsFromUrl; } });\nObject.defineProperty(exports, \"safeStringifyJson\", { enumerable: true, get: function () { return httpExecutor_1.safeStringifyJson; } });\nObject.defineProperty(exports, \"parseJson\", { enumerable: true, get: function () { return httpExecutor_1.parseJson; } });\nObject.defineProperty(exports, \"configureRequestUrl\", { enumerable: true, get: function () { return httpExecutor_1.configureRequestUrl; } });\nvar publishOptions_1 = require(\"./publishOptions\");\nObject.defineProperty(exports, \"getS3LikeProviderBaseUrl\", { enumerable: true, get: function () { return publishOptions_1.getS3LikeProviderBaseUrl; } });\nObject.defineProperty(exports, \"githubUrl\", { enumerable: true, get: function () { return publishOptions_1.githubUrl; } });\nvar rfc2253Parser_1 = require(\"./rfc2253Parser\");\nObject.defineProperty(exports, \"parseDn\", { enumerable: true, get: function () { return rfc2253Parser_1.parseDn; } });\nvar uuid_1 = require(\"./uuid\");\nObject.defineProperty(exports, \"UUID\", { enumerable: true, get: function () { return uuid_1.UUID; } });\nvar ProgressCallbackTransform_1 = require(\"./ProgressCallbackTransform\");\nObject.defineProperty(exports, \"ProgressCallbackTransform\", { enumerable: true, get: function () { return ProgressCallbackTransform_1.ProgressCallbackTransform; } });\nvar xml_1 = require(\"./xml\");\nObject.defineProperty(exports, \"parseXml\", { enumerable: true, get: function () { return xml_1.parseXml; } });\nObject.defineProperty(exports, \"XElement\", { enumerable: true, get: function () { return xml_1.XElement; } });\n// nsis\nexports.CURRENT_APP_INSTALLER_FILE_NAME = \"installer.exe\";\n// nsis-web\nexports.CURRENT_APP_PACKAGE_FILE_NAME = \"package.7z\";\nfunction asArray(v) {\n    if (v == null) {\n        return [];\n    }\n    else if (Array.isArray(v)) {\n        return v;\n    }\n    else {\n        return [v];\n    }\n}\nexports.asArray = asArray;\nfunction newError(message, code) {\n    const error = new Error(message);\n    error.code = code;\n    return error;\n}\nexports.newError = newError;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getS3LikeProviderBaseUrl = exports.githubUrl = void 0;\n/** @private */\nfunction githubUrl(options, defaultHost = \"github.com\") {\n    return `${options.protocol || \"https\"}://${options.host || defaultHost}`;\n}\nexports.githubUrl = githubUrl;\nfunction getS3LikeProviderBaseUrl(configuration) {\n    const provider = configuration.provider;\n    if (provider === \"s3\") {\n        return s3Url(configuration);\n    }\n    if (provider === \"spaces\") {\n        return spacesUrl(configuration);\n    }\n    throw new Error(`Not supported provider: ${provider}`);\n}\nexports.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;\nfunction s3Url(options) {\n    let url;\n    if (options.endpoint != null) {\n        url = `${options.endpoint}/${options.bucket}`;\n    }\n    else if (options.bucket.includes(\".\")) {\n        if (options.region == null) {\n            throw new Error(`Bucket name \"${options.bucket}\" includes a dot, but S3 region is missing`);\n        }\n        // special case, see http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro\n        if (options.region === \"us-east-1\") {\n            url = `https://s3.amazonaws.com/${options.bucket}`;\n        }\n        else {\n            url = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;\n        }\n    }\n    else if (options.region === \"cn-north-1\") {\n        url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;\n    }\n    else {\n        url = `https://${options.bucket}.s3.amazonaws.com`;\n    }\n    return appendPath(url, options.path);\n}\nfunction appendPath(url, p) {\n    if (p != null && p.length > 0) {\n        if (!p.startsWith(\"/\")) {\n            url += \"/\";\n        }\n        url += p;\n    }\n    return url;\n}\nfunction spacesUrl(options) {\n    if (options.name == null) {\n        throw new Error(`name is missing`);\n    }\n    if (options.region == null) {\n        throw new Error(`region is missing`);\n    }\n    return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);\n}\n//# sourceMappingURL=publishOptions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseDn = void 0;\nfunction parseDn(seq) {\n    let quoted = false;\n    let key = null;\n    let token = \"\";\n    let nextNonSpace = 0;\n    seq = seq.trim();\n    const result = new Map();\n    for (let i = 0; i <= seq.length; i++) {\n        if (i === seq.length) {\n            if (key !== null) {\n                result.set(key, token);\n            }\n            break;\n        }\n        const ch = seq[i];\n        if (quoted) {\n            if (ch === '\"') {\n                quoted = false;\n                continue;\n            }\n        }\n        else {\n            if (ch === '\"') {\n                quoted = true;\n                continue;\n            }\n            if (ch === \"\\\\\") {\n                i++;\n                const ord = parseInt(seq.slice(i, i + 2), 16);\n                if (Number.isNaN(ord)) {\n                    token += seq[i];\n                }\n                else {\n                    i++;\n                    token += String.fromCharCode(ord);\n                }\n                continue;\n            }\n            if (key === null && ch === \"=\") {\n                key = token;\n                token = \"\";\n                continue;\n            }\n            if (ch === \",\" || ch === \";\" || ch === \"+\") {\n                if (key !== null) {\n                    result.set(key, token);\n                }\n                key = null;\n                token = \"\";\n                continue;\n            }\n        }\n        if (ch === \" \" && !quoted) {\n            if (token.length === 0) {\n                continue;\n            }\n            if (i > nextNonSpace) {\n                let j = i;\n                while (seq[j] === \" \") {\n                    j++;\n                }\n                nextNonSpace = j;\n            }\n            if (nextNonSpace >= seq.length ||\n                seq[nextNonSpace] === \",\" ||\n                seq[nextNonSpace] === \";\" ||\n                (key === null && seq[nextNonSpace] === \"=\") ||\n                (key !== null && seq[nextNonSpace] === \"+\")) {\n                i = nextNonSpace - 1;\n                continue;\n            }\n        }\n        token += ch;\n    }\n    return result;\n}\nexports.parseDn = parseDn;\n//# sourceMappingURL=rfc2253Parser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nil = exports.UUID = void 0;\nconst crypto_1 = require(\"crypto\");\nconst index_1 = require(\"./index\");\nconst invalidName = \"options.name must be either a string or a Buffer\";\n// Node ID according to rfc4122#section-4.5\nconst randomHost = crypto_1.randomBytes(16);\nrandomHost[0] = randomHost[0] | 0x01;\n// lookup table hex to byte\nconst hex2byte = {};\n// lookup table byte to hex\nconst byte2hex = [];\n// populate lookup tables\nfor (let i = 0; i < 256; i++) {\n    const hex = (i + 0x100).toString(16).substr(1);\n    hex2byte[hex] = i;\n    byte2hex[i] = hex;\n}\n// UUID class\nclass UUID {\n    constructor(uuid) {\n        this.ascii = null;\n        this.binary = null;\n        const check = UUID.check(uuid);\n        if (!check) {\n            throw new Error(\"not a UUID\");\n        }\n        this.version = check.version;\n        if (check.format === \"ascii\") {\n            this.ascii = uuid;\n        }\n        else {\n            this.binary = uuid;\n        }\n    }\n    static v5(name, namespace) {\n        return uuidNamed(name, \"sha1\", 0x50, namespace);\n    }\n    toString() {\n        if (this.ascii == null) {\n            this.ascii = stringify(this.binary);\n        }\n        return this.ascii;\n    }\n    inspect() {\n        return `UUID v${this.version} ${this.toString()}`;\n    }\n    static check(uuid, offset = 0) {\n        if (typeof uuid === \"string\") {\n            uuid = uuid.toLowerCase();\n            if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid)) {\n                return false;\n            }\n            if (uuid === \"00000000-0000-0000-0000-000000000000\") {\n                return { version: undefined, variant: \"nil\", format: \"ascii\" };\n            }\n            return {\n                version: (hex2byte[uuid[14] + uuid[15]] & 0xf0) >> 4,\n                variant: getVariant((hex2byte[uuid[19] + uuid[20]] & 0xe0) >> 5),\n                format: \"ascii\",\n            };\n        }\n        if (Buffer.isBuffer(uuid)) {\n            if (uuid.length < offset + 16) {\n                return false;\n            }\n            let i = 0;\n            for (; i < 16; i++) {\n                if (uuid[offset + i] !== 0) {\n                    break;\n                }\n            }\n            if (i === 16) {\n                return { version: undefined, variant: \"nil\", format: \"binary\" };\n            }\n            return {\n                version: (uuid[offset + 6] & 0xf0) >> 4,\n                variant: getVariant((uuid[offset + 8] & 0xe0) >> 5),\n                format: \"binary\",\n            };\n        }\n        throw index_1.newError(\"Unknown type of uuid\", \"ERR_UNKNOWN_UUID_TYPE\");\n    }\n    // read stringified uuid into a Buffer\n    static parse(input) {\n        const buffer = Buffer.allocUnsafe(16);\n        let j = 0;\n        for (let i = 0; i < 16; i++) {\n            buffer[i] = hex2byte[input[j++] + input[j++]];\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                j += 1;\n            }\n        }\n        return buffer;\n    }\n}\nexports.UUID = UUID;\n// from rfc4122#appendix-C\nUUID.OID = UUID.parse(\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\");\n// according to rfc4122#section-4.1.1\nfunction getVariant(bits) {\n    switch (bits) {\n        case 0:\n        case 1:\n        case 3:\n            return \"ncs\";\n        case 4:\n        case 5:\n            return \"rfc4122\";\n        case 6:\n            return \"microsoft\";\n        default:\n            return \"future\";\n    }\n}\nvar UuidEncoding;\n(function (UuidEncoding) {\n    UuidEncoding[UuidEncoding[\"ASCII\"] = 0] = \"ASCII\";\n    UuidEncoding[UuidEncoding[\"BINARY\"] = 1] = \"BINARY\";\n    UuidEncoding[UuidEncoding[\"OBJECT\"] = 2] = \"OBJECT\";\n})(UuidEncoding || (UuidEncoding = {}));\n// v3 + v5\nfunction uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {\n    const hash = crypto_1.createHash(hashMethod);\n    const nameIsNotAString = typeof name !== \"string\";\n    if (nameIsNotAString && !Buffer.isBuffer(name)) {\n        throw index_1.newError(invalidName, \"ERR_INVALID_UUID_NAME\");\n    }\n    hash.update(namespace);\n    hash.update(name);\n    const buffer = hash.digest();\n    let result;\n    switch (encoding) {\n        case UuidEncoding.BINARY:\n            buffer[6] = (buffer[6] & 0x0f) | version;\n            buffer[8] = (buffer[8] & 0x3f) | 0x80;\n            result = buffer;\n            break;\n        case UuidEncoding.OBJECT:\n            buffer[6] = (buffer[6] & 0x0f) | version;\n            buffer[8] = (buffer[8] & 0x3f) | 0x80;\n            result = new UUID(buffer);\n            break;\n        default:\n            result =\n                byte2hex[buffer[0]] +\n                    byte2hex[buffer[1]] +\n                    byte2hex[buffer[2]] +\n                    byte2hex[buffer[3]] +\n                    \"-\" +\n                    byte2hex[buffer[4]] +\n                    byte2hex[buffer[5]] +\n                    \"-\" +\n                    byte2hex[(buffer[6] & 0x0f) | version] +\n                    byte2hex[buffer[7]] +\n                    \"-\" +\n                    byte2hex[(buffer[8] & 0x3f) | 0x80] +\n                    byte2hex[buffer[9]] +\n                    \"-\" +\n                    byte2hex[buffer[10]] +\n                    byte2hex[buffer[11]] +\n                    byte2hex[buffer[12]] +\n                    byte2hex[buffer[13]] +\n                    byte2hex[buffer[14]] +\n                    byte2hex[buffer[15]];\n            break;\n    }\n    return result;\n}\nfunction stringify(buffer) {\n    return (byte2hex[buffer[0]] +\n        byte2hex[buffer[1]] +\n        byte2hex[buffer[2]] +\n        byte2hex[buffer[3]] +\n        \"-\" +\n        byte2hex[buffer[4]] +\n        byte2hex[buffer[5]] +\n        \"-\" +\n        byte2hex[buffer[6]] +\n        byte2hex[buffer[7]] +\n        \"-\" +\n        byte2hex[buffer[8]] +\n        byte2hex[buffer[9]] +\n        \"-\" +\n        byte2hex[buffer[10]] +\n        byte2hex[buffer[11]] +\n        byte2hex[buffer[12]] +\n        byte2hex[buffer[13]] +\n        byte2hex[buffer[14]] +\n        byte2hex[buffer[15]]);\n}\n// according to rfc4122#section-4.1.7\nexports.nil = new UUID(\"00000000-0000-0000-0000-000000000000\");\n// UUID.v4 = uuidRandom\n// UUID.v4fast = uuidRandomFast\n// UUID.v3 = function(options, callback) {\n//     return uuidNamed(\"md5\", 0x30, options, callback)\n// }\n//# sourceMappingURL=uuid.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseXml = exports.XElement = void 0;\nconst sax = require(\"sax\");\nconst index_1 = require(\"./index\");\nclass XElement {\n    constructor(name) {\n        this.name = name;\n        this.value = \"\";\n        this.attributes = null;\n        this.isCData = false;\n        this.elements = null;\n        if (!name) {\n            throw index_1.newError(\"Element name cannot be empty\", \"ERR_XML_ELEMENT_NAME_EMPTY\");\n        }\n        if (!isValidName(name)) {\n            throw index_1.newError(`Invalid element name: ${name}`, \"ERR_XML_ELEMENT_INVALID_NAME\");\n        }\n    }\n    attribute(name) {\n        const result = this.attributes === null ? null : this.attributes[name];\n        if (result == null) {\n            throw index_1.newError(`No attribute \"${name}\"`, \"ERR_XML_MISSED_ATTRIBUTE\");\n        }\n        return result;\n    }\n    removeAttribute(name) {\n        if (this.attributes !== null) {\n            delete this.attributes[name];\n        }\n    }\n    element(name, ignoreCase = false, errorIfMissed = null) {\n        const result = this.elementOrNull(name, ignoreCase);\n        if (result === null) {\n            throw index_1.newError(errorIfMissed || `No element \"${name}\"`, \"ERR_XML_MISSED_ELEMENT\");\n        }\n        return result;\n    }\n    elementOrNull(name, ignoreCase = false) {\n        if (this.elements === null) {\n            return null;\n        }\n        for (const element of this.elements) {\n            if (isNameEquals(element, name, ignoreCase)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    getElements(name, ignoreCase = false) {\n        if (this.elements === null) {\n            return [];\n        }\n        return this.elements.filter(it => isNameEquals(it, name, ignoreCase));\n    }\n    elementValueOrEmpty(name, ignoreCase = false) {\n        const element = this.elementOrNull(name, ignoreCase);\n        return element === null ? \"\" : element.value;\n    }\n}\nexports.XElement = XElement;\nconst NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);\nfunction isValidName(name) {\n    return NAME_REG_EXP.test(name);\n}\nfunction isNameEquals(element, name, ignoreCase) {\n    const elementName = element.name;\n    return elementName === name || (ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase());\n}\nfunction parseXml(data) {\n    let rootElement = null;\n    const parser = sax.parser(true, {});\n    const elements = [];\n    parser.onopentag = saxElement => {\n        const element = new XElement(saxElement.name);\n        element.attributes = saxElement.attributes;\n        if (rootElement === null) {\n            rootElement = element;\n        }\n        else {\n            const parent = elements[elements.length - 1];\n            if (parent.elements == null) {\n                parent.elements = [];\n            }\n            parent.elements.push(element);\n        }\n        elements.push(element);\n    };\n    parser.onclosetag = () => {\n        elements.pop();\n    };\n    parser.ontext = text => {\n        if (elements.length > 0) {\n            elements[elements.length - 1].value = text;\n        }\n    };\n    parser.oncdata = cdata => {\n        const element = elements[elements.length - 1];\n        element.value = cdata;\n        element.isCData = true;\n    };\n    parser.onerror = err => {\n        throw err;\n    };\n    parser.write(data);\n    return rootElement;\n}\nexports.parseXml = parseXml;\n//# sourceMappingURL=xml.js.map","'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n","'use strict';\n\nconst {sep} = require('path');\nconst {platform} = process;\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.SLASH_SLASH = '//';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\nexports.isLinux = platform === 'linux';\n","'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\n\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed) return;\n  if (this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n","'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path)\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n    const linkPath = await fsrealpath(path);\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (path !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(targetPath, true);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","\"use strict\";\n\nconst modifiers = /^(Command|Cmd|Control|Ctrl|CommandOrControl|CmdOrCtrl|Alt|Option|AltGr|Shift|Super)$/;\nconst keyCodes = /^([0-9A-Z)!@#$%^&*(:+<_>?~{|}\";=,\\-./`[\\\\\\]']|F1*[1-9]|F10|F2[0-4]|Plus|Space|Tab|Backspace|Delete|Insert|Return|Enter|Up|Down|Left|Right|Home|End|PageUp|PageDown|Escape|Esc|VolumeUp|VolumeDown|VolumeMute|MediaNextTrack|MediaPreviousTrack|MediaStop|MediaPlayPause|PrintScreen)$/;\n\nmodule.exports = function (str) {\n\tlet parts = str.split(\"+\");\n\tlet keyFound = false;\n    return parts.every((val, index) => {\n\t\tconst isKey = keyCodes.test(val);\n\t\tconst isModifier = modifiers.test(val);\n\t\tif (isKey) {\n\t\t\t// Key must be unique\n\t\t\tif (keyFound) return false;\n\t\t\tkeyFound = true;\n\t\t}\n\t\t// Key is required\n\t\tif (index === parts.length - 1 && !keyFound) return false;\n        return isKey || isModifier;\n    });\n};\n","'use strict';\nconst {app, BrowserWindow} = require('electron');\nconst isAccelerator = require('electron-is-accelerator');\nconst equals = require('keyboardevents-areequal');\nconst {toKeyEvent} = require('keyboardevent-from-electron-accelerator');\nconst _debug = require('debug');\n\nconst debug = _debug('electron-localshortcut');\n\n// A placeholder to register shortcuts\n// on any window of the app.\nconst ANY_WINDOW = {};\n\nconst windowsWithShortcuts = new WeakMap();\n\nconst title = win => {\n\tif (win) {\n\t\ttry {\n\t\t\treturn win.getTitle();\n\t\t// eslint-disable-next-line no-unused-vars\n\t\t} catch (error) {\n\t\t\treturn 'A destroyed window';\n\t\t}\n\t}\n\n\treturn 'An falsy value';\n};\n\nfunction _checkAccelerator(accelerator) {\n\tif (!isAccelerator(accelerator)) {\n\t\tconst w = {};\n\t\tError.captureStackTrace(w);\n\t\tconst stack = w.stack ? w.stack.split('\\n').slice(4).join('\\n') : w.message;\n\t\tconst msg = `\nWARNING: ${accelerator} is not a valid accelerator.\n\n${stack}\n`;\n\t\tconsole.error(msg);\n\t}\n}\n\n/**\n * Disable all of the shortcuts registered on the BrowserWindow instance.\n * Registered shortcuts no more works on the `window` instance, but the module\n * keep a reference on them. You can reactivate them later by calling `enableAll`\n * method on the same window instance.\n * @param  {BrowserWindow} win BrowserWindow instance\n */\nfunction disableAll(win) {\n\tdebug(`Disabling all shortcuts on window ${title(win)}`);\n\tconst wc = win.webContents;\n\tconst shortcutsOfWindow = windowsWithShortcuts.get(wc);\n\n\tfor (const shortcut of shortcutsOfWindow) {\n\t\tshortcut.enabled = false;\n\t}\n}\n\n/**\n * Enable all of the shortcuts registered on the BrowserWindow instance that\n * you had previously disabled calling `disableAll` method.\n * @param  {BrowserWindow} win BrowserWindow instance\n */\nfunction enableAll(win) {\n\tdebug(`Enabling all shortcuts on window ${title(win)}`);\n\tconst wc = win.webContents;\n\tconst shortcutsOfWindow = windowsWithShortcuts.get(wc);\n\n\tfor (const shortcut of shortcutsOfWindow) {\n\t\tshortcut.enabled = true;\n\t}\n}\n\n/**\n * Unregisters all of the shortcuts registered on any focused BrowserWindow\n * instance. This method does not unregister any shortcut you registered on\n * a particular window instance.\n * @param  {BrowserWindow} win BrowserWindow instance\n */\nfunction unregisterAll(win) {\n\tdebug(`Unregistering all shortcuts on window ${title(win)}`);\n\tconst wc = win.webContents;\n\tconst shortcutsOfWindow = windowsWithShortcuts.get(wc);\n\tif (shortcutsOfWindow && shortcutsOfWindow.removeListener) {\n\t\t// Remove listener from window\n\t\tshortcutsOfWindow.removeListener();\n\t\twindowsWithShortcuts.delete(wc);\n\t}\n}\n\nfunction _normalizeEvent(input) {\n\tconst normalizedEvent = {\n\t\tcode: input.code,\n\t\tkey: input.key\n\t};\n\n\t['alt', 'shift', 'meta'].forEach(prop => {\n\t\tif (typeof input[prop] !== 'undefined') {\n\t\t\tnormalizedEvent[`${prop}Key`] = input[prop];\n\t\t}\n\t});\n\n\tif (typeof input.control !== 'undefined') {\n\t\tnormalizedEvent.ctrlKey = input.control;\n\t}\n\n\treturn normalizedEvent;\n}\n\nfunction _findShortcut(event, shortcutsOfWindow) {\n\tlet i = 0;\n\tfor (const shortcut of shortcutsOfWindow) {\n\t\tif (equals(shortcut.eventStamp, event)) {\n\t\t\treturn i;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn -1;\n}\n\nconst _onBeforeInput = shortcutsOfWindow => (e, input) => {\n\tif (input.type === 'keyUp') {\n\t\treturn;\n\t}\n\n\tconst event = _normalizeEvent(input);\n\n\tdebug(`before-input-event: ${input} is translated to: ${event}`);\n\tfor (const {eventStamp, callback} of shortcutsOfWindow) {\n\t\tif (equals(eventStamp, event)) {\n\t\t\tdebug(`eventStamp: ${eventStamp} match`);\n\t\t\tcallback();\n\n\t\t\treturn;\n\t\t}\n\n\t\tdebug(`eventStamp: ${eventStamp} no match`);\n\t}\n};\n\n/**\n * Registers the shortcut `accelerator`on the BrowserWindow instance.\n * @param  {BrowserWindow} win - BrowserWindow instance to register.\n * This argument could be omitted, in this case the function register\n * the shortcut on all app windows.\n * @param  {String|Array<String>} accelerator - the shortcut to register\n * @param  {Function} callback    This function is called when the shortcut is pressed\n * and the window is focused and not minimized.\n */\nfunction register(win, accelerator, callback) {\n\tlet wc;\n\tif (typeof callback === 'undefined') {\n\t\twc = ANY_WINDOW;\n\t\tcallback = accelerator;\n\t\taccelerator = win;\n\t} else {\n\t\twc = win.webContents;\n\t}\n\n\tif (Array.isArray(accelerator) === true) {\n\t\taccelerator.forEach(accelerator => {\n\t\t\tif (typeof accelerator === 'string') {\n\t\t\t\tregister(win, accelerator, callback);\n\t\t\t}\n\t\t});\n\t\treturn;\n\t}\n\n\tdebug(`Registering callback for ${accelerator} on window ${title(win)}`);\n\t_checkAccelerator(accelerator);\n\n\tdebug(`${accelerator} seems a valid shortcut sequence.`);\n\n\tlet shortcutsOfWindow;\n\tif (windowsWithShortcuts.has(wc)) {\n\t\tdebug('Window has others shortcuts registered.');\n\t\tshortcutsOfWindow = windowsWithShortcuts.get(wc);\n\t} else {\n\t\tdebug('This is the first shortcut of the window.');\n\t\tshortcutsOfWindow = [];\n\t\twindowsWithShortcuts.set(wc, shortcutsOfWindow);\n\n\t\tif (wc === ANY_WINDOW) {\n\t\t\tconst keyHandler = _onBeforeInput(shortcutsOfWindow);\n\t\t\tconst enableAppShortcuts = (e, win) => {\n\t\t\t\tconst wc = win.webContents;\n\t\t\t\twc.on('before-input-event', keyHandler);\n\t\t\t\twc.once('closed', () =>\n\t\t\t\t\twc.removeListener('before-input-event', keyHandler)\n\t\t\t\t);\n\t\t\t};\n\n\t\t\t// Enable shortcut on current windows\n\t\t\tconst windows = BrowserWindow.getAllWindows();\n\n\t\t\twindows.forEach(win => enableAppShortcuts(null, win));\n\n\t\t\t// Enable shortcut on future windows\n\t\t\tapp.on('browser-window-created', enableAppShortcuts);\n\n\t\t\tshortcutsOfWindow.removeListener = () => {\n\t\t\t\tconst windows = BrowserWindow.getAllWindows();\n\t\t\t\twindows.forEach(win =>\n\t\t\t\t\twin.webContents.removeListener('before-input-event', keyHandler)\n\t\t\t\t);\n\t\t\t\tapp.removeListener('browser-window-created', enableAppShortcuts);\n\t\t\t};\n\t\t} else {\n\t\t\tconst keyHandler = _onBeforeInput(shortcutsOfWindow);\n\t\t\twc.on('before-input-event', keyHandler);\n\n\t\t\t// Save a reference to allow remove of listener from elsewhere\n\t\t\tshortcutsOfWindow.removeListener = () =>\n\t\t\t\twc.removeListener('before-input-event', keyHandler);\n\t\t\twc.once('closed', shortcutsOfWindow.removeListener);\n\t\t}\n\t}\n\n\tdebug('Adding shortcut to window set.');\n\n\tconst eventStamp = toKeyEvent(accelerator);\n\n\tshortcutsOfWindow.push({\n\t\teventStamp,\n\t\tcallback,\n\t\tenabled: true\n\t});\n\n\tdebug('Shortcut registered.');\n}\n\n/**\n * Unregisters the shortcut of `accelerator` registered on the BrowserWindow instance.\n * @param  {BrowserWindow} win - BrowserWindow instance to unregister.\n * This argument could be omitted, in this case the function unregister the shortcut\n * on all app windows. If you registered the shortcut on a particular window instance, it will do nothing.\n * @param  {String|Array<String>} accelerator - the shortcut to unregister\n */\nfunction unregister(win, accelerator) {\n\tlet wc;\n\tif (typeof accelerator === 'undefined') {\n\t\twc = ANY_WINDOW;\n\t\taccelerator = win;\n\t} else {\n\t\tif (win.isDestroyed()) {\n\t\t\tdebug('Early return because window is destroyed.');\n\t\t\treturn;\n\t\t}\n\n\t\twc = win.webContents;\n\t}\n\n\tif (Array.isArray(accelerator) === true) {\n\t\taccelerator.forEach(accelerator => {\n\t\t\tif (typeof accelerator === 'string') {\n\t\t\t\tunregister(win, accelerator);\n\t\t\t}\n\t\t});\n\t\treturn;\n\t}\n\n\tdebug(`Unregistering callback for ${accelerator} on window ${title(win)}`);\n\n\t_checkAccelerator(accelerator);\n\n\tdebug(`${accelerator} seems a valid shortcut sequence.`);\n\n\tif (!windowsWithShortcuts.has(wc)) {\n\t\tdebug('Early return because window has never had shortcuts registered.');\n\t\treturn;\n\t}\n\n\tconst shortcutsOfWindow = windowsWithShortcuts.get(wc);\n\n\tconst eventStamp = toKeyEvent(accelerator);\n\tconst shortcutIdx = _findShortcut(eventStamp, shortcutsOfWindow);\n\tif (shortcutIdx === -1) {\n\t\treturn;\n\t}\n\n\tshortcutsOfWindow.splice(shortcutIdx, 1);\n\n\t// If the window has no more shortcuts,\n\t// we remove it early from the WeakMap\n\t// and unregistering the event listener\n\tif (shortcutsOfWindow.length === 0) {\n\t\t// Remove listener from window\n\t\tshortcutsOfWindow.removeListener();\n\n\t\t// Remove window from shortcuts catalog\n\t\twindowsWithShortcuts.delete(wc);\n\t}\n}\n\n/**\n * Returns `true` or `false` depending on whether the shortcut `accelerator`\n * is registered on `window`.\n * @param  {BrowserWindow} win - BrowserWindow instance to check. This argument\n * could be omitted, in this case the function returns whether the shortcut\n * `accelerator` is registered on all app windows. If you registered the\n * shortcut on a particular window instance, it return false.\n * @param  {String} accelerator - the shortcut to check\n * @return {Boolean} - if the shortcut `accelerator` is registered on `window`.\n */\nfunction isRegistered(win, accelerator) {\n\t_checkAccelerator(accelerator);\n\tconst wc = win.webContents;\n\tconst shortcutsOfWindow = windowsWithShortcuts.get(wc);\n\tconst eventStamp = toKeyEvent(accelerator);\n\n\treturn _findShortcut(eventStamp, shortcutsOfWindow) !== -1;\n}\n\nmodule.exports = {\n\tregister,\n\tunregister,\n\tisRegistered,\n\tunregisterAll,\n\tenableAll,\n\tdisableAll\n};\n","'use strict';\n\n/**\n * Some ideas from sindresorhus/electron-unhandled\n */\n\nvar electronApi = require('./electronApi');\nvar queryString = require('querystring');\n\nvar isAttached = false;\n\nmodule.exports = function catchErrors(options) {\n  if (isAttached) return { stop: stop };\n  isAttached = true;\n\n  if (process.type === 'renderer') {\n    window.addEventListener('error', onRendererError);\n    window.addEventListener('unhandledrejection', onRendererRejection);\n  } else {\n    process.on('uncaughtException', onError);\n    process.on('unhandledRejection', onRejection);\n  }\n\n  return { stop: stop };\n\n  function onError(e) {\n    try {\n      if (typeof options.onError === 'function') {\n        var versions = electronApi.getVersions();\n        if (options.onError(e, versions, createIssue) === false) {\n          return;\n        }\n      }\n\n      options.log('Unhandled Exception', e);\n\n      if (options.showDialog && e.name.indexOf('UnhandledRejection') < 0) {\n        var type = process.type || 'main';\n        electronApi.showErrorBox(\n          'A JavaScript error occurred in the ' + type + ' process',\n          e.stack\n        );\n      }\n    } catch (logError) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n    }\n  }\n\n  function onRejection(reason) {\n    if (reason instanceof Error) {\n      try {\n        Object.defineProperty(reason, 'name', {\n          value: 'UnhandledRejection ' + reason.name,\n        });\n      } catch (e) {\n        // Can't redefine error name, but who cares?\n      }\n\n      onError(reason);\n      return;\n    }\n\n    var error = new Error(JSON.stringify(reason));\n    error.name = 'UnhandledRejection';\n    onError(error);\n  }\n\n  function onRendererError(event) {\n    event.preventDefault();\n    onError(event.error);\n  }\n\n  function onRendererRejection(event) {\n    event.preventDefault();\n    onRejection(event.reason);\n  }\n\n  function stop() {\n    isAttached = false;\n\n    if (process.type === 'renderer') {\n      window.removeEventListener('error', onRendererError);\n      window.removeEventListener('unhandledrejection', onRendererRejection);\n    } else {\n      process.removeListener('uncaughtException', onError);\n      process.removeListener('unhandledRejection', onRejection);\n    }\n  }\n\n  function createIssue(pageUrl, queryParams) {\n    var issueUrl = pageUrl + '?' + queryString.stringify(queryParams);\n    electronApi.openUrl(issueUrl, options.log);\n  }\n};\n","'use strict';\n\n/**\n * Split Electron API from the main code\n */\n\nvar path = require('path');\nvar electron;\ntry {\n  // eslint-disable-next-line global-require\n  electron = require('electron');\n} catch (e) {\n  electron = null;\n}\n\nvar os = require('os');\n\nmodule.exports = {\n  getName: getName,\n  getPath: getPath,\n  getVersion: getVersion,\n  getVersions: getVersions,\n  isDev: isDev,\n  isElectron: isElectron,\n  isIpcChannelListened: isIpcChannelListened,\n  loadRemoteModule: loadRemoteModule,\n  onIpc: onIpc,\n  openUrl: openUrl,\n  sendIpc: sendIpc,\n  showErrorBox: showErrorBox,\n};\n\nfunction getApp() {\n  return getElectronModule('app');\n}\n\nfunction getName() {\n  var app = getApp();\n  if (!app) return null;\n\n  return 'name' in app ? app.name : app.getName();\n}\n\nfunction getElectronModule(name) {\n  if (!electron) {\n    return null;\n  }\n\n  if (electron[name]) {\n    return electron[name];\n  }\n\n  if (electron.remote) {\n    return electron.remote[name];\n  }\n\n  return null;\n}\n\nfunction getIpc() {\n  if (process.type === 'browser' && electron && electron.ipcMain) {\n    return electron.ipcMain;\n  }\n\n  if (process.type === 'renderer' && electron && electron.ipcRenderer) {\n    return electron.ipcRenderer;\n  }\n\n  return null;\n}\n\nfunction getPath(name) {\n  var app = getApp();\n  if (!app) return null;\n\n  try {\n    return app.getPath(name);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction getVersion() {\n  var app = getApp();\n  if (!app) return null;\n\n  return 'version' in app ? app.version : app.getVersion();\n}\n\nfunction getVersions() {\n  return {\n    app: getName() + ' ' + getVersion(),\n    electron: 'Electron ' + process.versions.electron,\n    os: getOsVersion(),\n  };\n}\n\nfunction getOsVersion() {\n  var osName = os.type().replace('_', ' ');\n  var osVersion = os.release();\n\n  if (osName === 'Darwin') {\n    osName = 'macOS';\n    osVersion = getMacOsVersion();\n  }\n\n  return osName + ' ' + osVersion;\n}\n\nfunction getMacOsVersion() {\n  var release = Number(os.release().split('.')[0]);\n  return '10.' + (release - 4);\n}\n\nfunction isDev() {\n  var app = getApp();\n\n  if (app && app.isPackaged !== undefined) {\n    return !app.isPackaged;\n  }\n\n  if (typeof process.execPath === 'string') {\n    var execFileName = path.basename(process.execPath).toLowerCase();\n    return execFileName.startsWith('electron');\n  }\n\n  return process.env.NODE_ENV === 'development'\n    || process.env.ELECTRON_IS_DEV === '1';\n}\n\nfunction isElectron() {\n  return process.type === 'browser' || process.type === 'renderer';\n}\n\n/**\n * Return true if the process listens for the IPC channel\n * @param {string} channel\n */\nfunction isIpcChannelListened(channel) {\n  var ipc = getIpc();\n  return ipc ? ipc.listenerCount(channel) > 0 : false;\n}\n\n/**\n * Try to load the module in the opposite process\n * @param {string} moduleName\n */\nfunction loadRemoteModule(moduleName) {\n  if (process.type === 'browser') {\n    getApp().on('web-contents-created', function (e, contents) {\n      var promise = contents.executeJavaScript(\n        'try {require(\"' + moduleName + '\")} catch(e){}; void 0;'\n      );\n\n      // Do nothing on error, just prevent Unhandled rejection\n      if (promise && typeof promise.catch === 'function') {\n        promise.catch(function () {});\n      }\n    });\n  } else if (process.type === 'renderer') {\n    // Previously, it was electron.remote.require(moduleName)\n    // but now the remote module is deprecated\n  }\n}\n\n/**\n * Listen to async messages sent from opposite process\n * @param {string} channel\n * @param {function} listener\n */\nfunction onIpc(channel, listener) {\n  var ipc = getIpc();\n  if (ipc) {\n    ipc.on(channel, listener);\n  }\n}\n\n/**\n * Sent a message to opposite process\n * @param {string} channel\n * @param {any} message\n */\nfunction sendIpc(channel, message) {\n  if (process.type === 'browser') {\n    sendIpcToRenderer(channel, message);\n  } else if (process.type === 'renderer') {\n    sendIpcToMain(channel, message);\n  }\n}\n\nfunction sendIpcToMain(channel, message) {\n  var ipc = getIpc();\n  if (ipc) {\n    ipc.send(channel, message);\n  }\n}\n\nfunction sendIpcToRenderer(channel, message) {\n  if (!electron || !electron.BrowserWindow) {\n    return;\n  }\n\n  electron.BrowserWindow.getAllWindows().forEach(function (wnd) {\n    if (wnd.webContents && !wnd.webContents.isDestroyed()) {\n      wnd.webContents.send(channel, message);\n    }\n  });\n}\n\nfunction showErrorBox(title, message) {\n  var dialog = getElectronModule('dialog');\n  if (!dialog) return;\n\n  dialog.showErrorBox(title, message);\n}\n\n/**\n * @param {string} url\n * @param {Function} [logFunction]\n */\nfunction openUrl(url, logFunction) {\n  // eslint-disable-next-line no-console\n  logFunction = logFunction || console.error;\n\n  var shell = getElectronModule('shell');\n  if (!shell) return;\n\n  shell.openExternal(url).catch(logFunction);\n}\n","'use strict';\n\nvar catchErrors = require('./catchErrors');\nvar electronApi = require('./electronApi');\nvar log = require('./log');\nvar scopeFactory = require('./scope');\nvar transportConsole = require('./transports/console');\nvar transportFile = require('./transports/file');\nvar transportIpc = require('./transports/ipc');\nvar transportRemote = require('./transports/remote');\n\nmodule.exports = create('default');\nmodule.exports.default = module.exports;\n\n/**\n * @param {string} logId\n * @return {ElectronLog.ElectronLog}\n */\nfunction create(logId) {\n  /**\n   * @type {ElectronLog.ElectronLog}\n   */\n  var instance = {\n    catchErrors: function callCatchErrors(options) {\n      var opts = Object.assign({}, {\n        log: instance.error,\n        showDialog: process.type === 'browser',\n      }, options || {});\n\n      catchErrors(opts);\n    },\n    create: create,\n    functions: {},\n    hooks: [],\n    isDev: electronApi.isDev(),\n    levels: [],\n    logId: logId,\n    variables: {\n      processType: process.type,\n    },\n  };\n\n  instance.scope = scopeFactory(instance);\n\n  instance.transports = {\n    console: transportConsole(instance),\n    file: transportFile(instance),\n    remote: transportRemote(instance),\n    ipc: transportIpc(instance),\n  };\n\n  Object.defineProperty(instance.levels, 'add', {\n    enumerable: false,\n    value: function add(name, index) {\n      index = index === undefined ? instance.levels.length : index;\n      instance.levels.splice(index, 0, name);\n      instance[name] = log.log.bind(null, instance, { level: name });\n      instance.functions[name] = instance[name];\n    },\n  });\n\n  ['error', 'warn', 'info', 'verbose', 'debug', 'silly'].forEach(\n    function (level) { instance.levels.add(level) }\n  );\n\n  instance.log = log.log.bind(null, instance, { level: 'info' });\n  instance.functions.log = instance.log;\n\n  instance.logMessageWithTransports = function logMessageWithTransports(\n    message,\n    transports\n  ) {\n    if (message.date === undefined) {\n      message.date = new Date();\n    }\n\n    if (message.variables === undefined) {\n      message.variables = instance.variables;\n    }\n\n    return log.runTransports(transports, message, instance);\n  };\n\n  return instance;\n}\n","'use strict';\n\nmodule.exports = {\n  compareLevels: compareLevels,\n  log: log,\n  runTransport: runTransport,\n  runTransports: runTransports,\n};\n\nfunction log(electronLog, options) {\n  var transports = electronLog.transports;\n\n  var message = {\n    data: Array.prototype.slice.call(arguments, 2),\n    date: new Date(),\n    level: options.level,\n    scope: options.scope ? options.scope.toJSON() : null,\n    variables: electronLog.variables,\n  };\n\n  runTransports(transports, message, electronLog);\n}\n\nfunction runTransports(transports, message, electronLog) {\n  for (var i in transports) {\n    if (Object.prototype.hasOwnProperty.call(transports, i)) {\n      runTransport(transports[i], message, electronLog);\n    }\n  }\n}\n\nfunction runTransport(transport, message, electronLog) {\n  if (typeof transport !== 'function' || transport.level === false) {\n    return;\n  }\n\n  if (!compareLevels(electronLog.levels, transport.level, message.level)) {\n    return;\n  }\n\n  message = runHooks(electronLog.hooks, transport, message);\n\n  if (message) {\n    transport(message);\n  }\n}\n\nfunction compareLevels(levels, passLevel, checkLevel) {\n  var pass = levels.indexOf(passLevel);\n  var check = levels.indexOf(checkLevel);\n  if (check === -1 || pass === -1) {\n    return true;\n  }\n\n  return check <= pass;\n}\n\nfunction runHooks(hooks, transport, message) {\n  if (!hooks || !hooks.length) {\n    return message;\n  }\n\n  // eslint-disable-next-line no-plusplus\n  for (var i = 0; i < hooks.length; i++) {\n    message = hooks[i](message, transport);\n    if (!message) break;\n  }\n\n  return message;\n}\n","'use strict';\n\nvar log = require('./log').log;\n\nmodule.exports = scopeFactory;\n\n/**\n * @param {ElectronLog.ElectronLog} electronLog\n * @return {ElectronLog.Scope}\n */\nfunction scopeFactory(electronLog) {\n  scope.labelPadding = true;\n  scope.defaultLabel = '';\n\n  /** @private */\n  scope.maxLabelLength = 0;\n\n  /**\n   * @type {typeof getOptions}\n   * @package\n   */\n  scope.getOptions = getOptions;\n\n  return scope;\n\n  function scope(label) {\n    var instance = {\n      label: label,\n      toJSON: function () {\n        return {\n          label: this.label,\n        };\n      },\n    };\n\n    electronLog.levels.forEach(function (level) {\n      instance[level] = log.bind(null, electronLog, {\n        level: level,\n        scope: instance,\n      });\n    });\n\n    instance.log = instance.info;\n\n    scope.maxLabelLength = Math.max(scope.maxLabelLength, label.length);\n\n    return instance;\n  }\n\n  function getOptions() {\n    return {\n      defaultLabel: scope.defaultLabel,\n      labelLength: getLabelLength(),\n    };\n  }\n\n  function getLabelLength() {\n    if (scope.labelPadding === true) {\n      return scope.maxLabelLength;\n    }\n\n    if (scope.labelPadding === false) {\n      return 0;\n    }\n\n    if (typeof scope.labelPadding === 'number') {\n      return scope.labelPadding;\n    }\n\n    return 0;\n  }\n}\n","'use strict';\n\nvar object = require('./object');\nvar style = require('./style');\nvar template = require('./template');\n\nmodule.exports = {\n  applyAnsiStyles: style.applyAnsiStyles,\n  concatFirstStringElements: template.concatFirstStringElements,\n  customFormatterFactory: customFormatterFactory,\n  maxDepthFactory: object.maxDepthFactory,\n  removeStyles: style.removeStyles,\n  toJSON: object.toJSON,\n  toStringFactory: object.toStringFactory,\n  transform: transform,\n};\n\nfunction customFormatterFactory(customFormat, concatFirst, scopeOptions) {\n  if (typeof customFormat === 'string') {\n    return function customStringFormatter(data, message) {\n      return transform(message, [\n        template.templateVariables,\n        template.templateScopeFactory(scopeOptions),\n        template.templateDate,\n        template.templateText,\n        concatFirst && template.concatFirstStringElements,\n      ], [customFormat].concat(data));\n    };\n  }\n\n  if (typeof customFormat === 'function') {\n    return function customFunctionFormatter(data, message) {\n      var modifiedMessage = Object.assign({}, message, { data: data });\n      var texts = customFormat(modifiedMessage, data);\n      return [].concat(texts);\n    };\n  }\n\n  return function (data) {\n    return [].concat(data);\n  };\n}\n\nfunction transform(message, transformers, initialData) {\n  return transformers.reduce(function (data, transformer) {\n    if (typeof transformer === 'function') {\n      return transformer(data, message);\n    }\n\n    return data;\n  }, initialData || message.data);\n}\n","'use strict';\n\nvar util = require('util');\n\nmodule.exports = {\n  maxDepthFactory: maxDepthFactory,\n  serialize: serialize,\n  toJSON: toJSON,\n  toStringFactory: toStringFactory,\n};\n\n/**\n * @param {object} options?\n * @param {boolean} options.serializeMapAndSet?\n * @return {function}\n */\nfunction createSerializer(options) {\n  var seen = createWeakSet();\n\n  return function (key, value) {\n    if (typeof value === 'object' && value !== null) {\n      if (seen.has(value)) {\n        return undefined;\n      }\n\n      seen.add(value);\n    }\n\n    return serialize(key, value, options);\n  };\n}\n\n/**\n * @return {WeakSet<object>}\n */\nfunction createWeakSet() {\n  if (typeof WeakSet !== 'undefined') {\n    return new WeakSet();\n  }\n\n  var cache = [];\n  return {\n    add: function (value) { cache.push(value) },\n    has: function (value) { return cache.indexOf(value) !== -1 },\n  };\n}\n\nfunction maxDepth(data, depth) {\n  if (!data) {\n    return data;\n  }\n\n  if (depth < 1) {\n    if (isArray(data)) return '[array]';\n    if (typeof data === 'object' && data) return '[object]';\n\n    return data;\n  }\n\n  if (isArray(data)) {\n    return data.map(function (child) {\n      return maxDepth(child, depth - 1);\n    });\n  }\n\n  if (typeof data !== 'object') {\n    return data;\n  }\n\n  if (data && typeof data.toISOString === 'function') {\n    return data;\n  }\n\n  // noinspection PointlessBooleanExpressionJS\n  if (data === null) {\n    return null;\n  }\n\n  if (data instanceof Error) {\n    return data;\n  }\n\n  var newJson = {};\n  for (var i in data) {\n    if (!Object.prototype.hasOwnProperty.call(data, i)) continue;\n    newJson[i] = maxDepth(data[i], depth - 1);\n  }\n\n  return newJson;\n}\n\nfunction maxDepthFactory(depth) {\n  depth = depth || 6;\n\n  return function maxDepthFunction(data) {\n    return maxDepth(data, depth);\n  };\n}\n\n/**\n * @param {string} key\n * @param {any} value\n * @param {object} options?\n * @return {any}\n */\nfunction serialize(key, value, options) {\n  var serializeMapAndSet = !options || options.serializeMapAndSet !== false;\n\n  if (value instanceof Error) {\n    return value.stack;\n  }\n\n  if (!value) {\n    return value;\n  }\n\n  if (typeof value.toJSON === 'function') {\n    return value.toJSON();\n  }\n\n  if (typeof value === 'function') {\n    return '[function] ' + value.toString();\n  }\n\n  if (serializeMapAndSet && value instanceof Map && Object.fromEntries) {\n    return Object.fromEntries(value);\n  }\n\n  if (serializeMapAndSet && value instanceof Set && Array.from) {\n    return Array.from(value);\n  }\n\n  return value;\n}\n\nfunction toJSON(data) {\n  return JSON.parse(JSON.stringify(data, createSerializer()));\n}\n\nfunction toStringFactory(inspectOptions) {\n  return function toStringFunction(data) {\n    var simplifiedData = data.map(function (item) {\n      if (item === undefined) {\n        return undefined;\n      }\n\n      try {\n        var str = JSON.stringify(item, createSerializer(), '  ');\n        return str === undefined ? undefined : JSON.parse(str);\n      } catch (e) {\n        // There are some rare cases when an item can't be simplified.\n        // In that case, it's fine to pass it to util.format directly.\n        return item;\n      }\n    });\n\n    if (util.formatWithOptions) {\n      simplifiedData.unshift(inspectOptions || {});\n      return util.formatWithOptions.apply(util, simplifiedData);\n    }\n\n    return util.format.apply(util, simplifiedData);\n  };\n}\n\nfunction isArray(value) {\n  return Object.prototype.toString.call(value) === '[object Array]';\n}\n","'use strict';\n\nmodule.exports = {\n  applyAnsiStyles: applyAnsiStyles,\n  removeStyles: removeStyles,\n  transformStyles: transformStyles,\n};\n\nvar ANSI_COLORS = {\n  unset: '\\x1b[0m',\n  black: '\\x1b[30m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n  white: '\\x1b[37m',\n};\n\nfunction applyAnsiStyles(data) {\n  return transformStyles(data, styleToAnsi, resetAnsiStyle);\n}\n\nfunction styleToAnsi(style) {\n  var color = style.replace(/color:\\s*(\\w+).*/, '$1').toLowerCase();\n  return ANSI_COLORS[color] || '';\n}\n\nfunction resetAnsiStyle(string) {\n  return string + ANSI_COLORS.unset;\n}\n\nfunction removeStyles(data) {\n  return transformStyles(data, function () { return '' });\n}\n\nfunction transformStyles(data, onStyleFound, onStyleApplied) {\n  var foundStyles = {};\n\n  return data.reduce(function (result, item, index, array) {\n    if (foundStyles[index]) {\n      return result;\n    }\n\n    if (typeof item === 'string') {\n      var valueIndex = index;\n      var styleApplied = false;\n\n      item = item.replace(/%[1cdfiOos]/g, function (match) {\n        valueIndex += 1;\n\n        if (match !== '%c') {\n          return match;\n        }\n\n        var style = array[valueIndex];\n        if (typeof style === 'string') {\n          foundStyles[valueIndex] = true;\n          styleApplied = true;\n          return onStyleFound(style, item);\n        }\n\n        return match;\n      });\n\n      if (styleApplied && onStyleApplied) {\n        item = onStyleApplied(item);\n      }\n    }\n\n    result.push(item);\n    return result;\n  }, []);\n}\n","'use strict';\n\nmodule.exports = {\n  concatFirstStringElements: concatFirstStringElements,\n  formatDate: formatDate,\n  formatTimeZone: formatTimeZone,\n  pad: pad,\n  padString: padString,\n  templateDate: templateDate,\n  templateVariables: templateVariables,\n  templateScopeFactory: templateScopeFactory,\n  templateText: templateText,\n};\n\n/**\n * The first argument of console.log may contain templates. In the library\n * the first element is a string related to transports.console.format. So\n * this function concatenates first two elements to make templates like %d\n * work\n * @param {*[]} data\n * @return {*[]}\n */\nfunction concatFirstStringElements(data) {\n  if (typeof data[0] !== 'string' || typeof data[1] !== 'string') {\n    return data;\n  }\n\n  if (data[0].match(/%[1cdfiOos]/)) {\n    return data;\n  }\n\n  data[1] = data[0] + ' ' + data[1];\n  data.shift();\n\n  return data;\n}\n\nfunction formatDate(template, date) {\n  return template\n    .replace('{y}', String(date.getFullYear()))\n    .replace('{m}', pad(date.getMonth() + 1))\n    .replace('{d}', pad(date.getDate()))\n    .replace('{h}', pad(date.getHours()))\n    .replace('{i}', pad(date.getMinutes()))\n    .replace('{s}', pad(date.getSeconds()))\n    .replace('{ms}', pad(date.getMilliseconds(), 3))\n    .replace('{z}', formatTimeZone(date.getTimezoneOffset()))\n    .replace('{iso}', date.toISOString());\n}\n\nfunction formatTimeZone(minutesOffset) {\n  var m = Math.abs(minutesOffset);\n  return (minutesOffset >= 0 ? '-' : '+')\n    + pad(Math.floor(m / 60)) + ':'\n    + pad(m % 60);\n}\n\nfunction pad(number, zeros) {\n  zeros = zeros || 2;\n  return (new Array(zeros + 1).join('0') + number).substr(-zeros, zeros);\n}\n\nfunction padString(value, length) {\n  length = Math.max(length, value.length);\n  var padValue = Array(length + 1).join(' ');\n  return (value + padValue).substring(0, length);\n}\n\nfunction templateDate(data, message) {\n  var template = data[0];\n  if (typeof template !== 'string') {\n    return data;\n  }\n\n  data[0] = formatDate(template, message.date);\n  return data;\n}\n\n/**\n * @param {{ labelLength: number, defaultLabel: string }} options\n */\nfunction templateScopeFactory(options) {\n  options = options || {};\n  var labelLength = options.labelLength || 0;\n\n  return function templateScope(data, message) {\n    var template = data[0];\n    var label = message.scope && message.scope.label;\n\n    if (!label) {\n      label = options.defaultLabel;\n    }\n\n    var scopeText;\n    if (label === '') {\n      scopeText = labelLength > 0 ? padString('', labelLength + 3) : '';\n    } else if (typeof label === 'string') {\n      scopeText = padString(' (' + label + ')', labelLength + 3);\n    } else {\n      scopeText = '';\n    }\n\n    data[0] = template.replace('{scope}', scopeText);\n    return data;\n  };\n}\n\nfunction templateVariables(data, message) {\n  var template = data[0];\n  var variables = message.variables;\n\n  if (typeof template !== 'string' || !message.variables) {\n    return data;\n  }\n\n  for (var i in variables) {\n    if (!Object.prototype.hasOwnProperty.call(variables, i)) continue;\n    template = template.replace('{' + i + '}', variables[i]);\n  }\n\n  // Add additional space to the end of {level}] template to align messages\n  template = template.replace('{level}]', padString(message.level + ']', 6));\n  template = template.replace('{level}', message.level);\n\n  data[0] = template;\n  return data;\n}\n\nfunction templateText(data) {\n  var template = data[0];\n  if (typeof template !== 'string') {\n    return data;\n  }\n\n  var textTplPosition = template.lastIndexOf('{text}');\n  if (textTplPosition === template.length - 6) {\n    data[0] = template.replace(/\\s?{text}/, '');\n    if (data[0] === '') {\n      data.shift();\n    }\n\n    return data;\n  }\n\n  var templatePieces = template.split('{text}');\n  var result = [];\n\n  if (templatePieces[0] !== '') {\n    result.push(templatePieces[0]);\n  }\n\n  result = result.concat(data.slice(1));\n\n  if (templatePieces[1] !== '') {\n    result.push(templatePieces[1]);\n  }\n\n  return result;\n}\n","'use strict';\n\n/* eslint-disable no-multi-spaces, no-console */\n\nvar transform = require('../transform');\n\nvar consoleMethods = {\n  context: console,\n  error:   console.error,\n  warn:    console.warn,\n  info:    console.info,\n  verbose: console.verbose,\n  debug:   console.debug,\n  silly:   console.silly,\n  log:     console.log,\n};\n\nmodule.exports = consoleTransportFactory;\nmodule.exports.transformRenderer = transformRenderer;\nmodule.exports.transformMain = transformMain;\n\nvar separator = process.platform === 'win32' ? '>' : '›';\nvar DEFAULT_FORMAT = {\n  browser: '%c{h}:{i}:{s}.{ms}{scope}%c ' + separator + ' {text}',\n  renderer: '{h}:{i}:{s}.{ms}{scope} › {text}',\n  worker: '{h}:{i}:{s}.{ms}{scope} › {text}',\n};\n\nfunction consoleTransportFactory(electronLog) {\n  transport.level  = 'silly';\n  transport.useStyles = process.env.FORCE_STYLES;\n  transport.format = DEFAULT_FORMAT[process.type] || DEFAULT_FORMAT.browser;\n\n  return transport;\n\n  function transport(message) {\n    var scopeOptions = electronLog.scope.getOptions();\n\n    var data;\n    if (process.type === 'renderer' || process.type === 'worker') {\n      data = transformRenderer(message, transport, scopeOptions);\n    } else {\n      data = transformMain(message, transport, scopeOptions);\n    }\n\n    consoleLog(message.level, data);\n  }\n}\n\nfunction transformRenderer(message, transport, scopeOptions) {\n  return transform.transform(message, [\n    transform.customFormatterFactory(transport.format, true, scopeOptions),\n  ]);\n}\n\nfunction transformMain(message, transport, scopeOptions) {\n  var useStyles = canUseStyles(transport.useStyles, message.level);\n\n  return transform.transform(message, [\n    addTemplateColorFactory(transport.format),\n    transform.customFormatterFactory(transport.format, false, scopeOptions),\n    useStyles ? transform.applyAnsiStyles : transform.removeStyles,\n    transform.concatFirstStringElements,\n    transform.maxDepthFactory(4),\n    transform.toJSON,\n  ]);\n}\n\nfunction addTemplateColorFactory(format) {\n  return function addTemplateColors(data, message) {\n    if (format !== DEFAULT_FORMAT.browser) {\n      return data;\n    }\n\n    return ['color:' + levelToStyle(message.level), 'color:unset'].concat(data);\n  };\n}\n\nfunction canUseStyles(useStyleValue, level) {\n  if (useStyleValue === true || useStyleValue === false) {\n    return useStyleValue;\n  }\n\n  var useStderr = level === 'error' || level === 'warn';\n  var stream = useStderr ? process.stderr : process.stdout;\n  return stream && stream.isTTY;\n}\n\nfunction consoleLog(level, args) {\n  var consoleMethod = consoleMethods[level] || consoleMethods.info;\n\n  if (process.type === 'renderer') {\n    setTimeout(consoleMethod.bind.apply(\n      consoleMethod,\n      [consoleMethod.context].concat(args)\n    ));\n    return;\n  }\n\n  consoleMethod.apply(consoleMethods.context, args);\n}\n\nfunction levelToStyle(level) {\n  switch (level) {\n    case 'error': return 'red';\n    case 'warn':  return 'yellow';\n    case 'info':  return 'cyan';\n    default:      return 'unset';\n  }\n}\n","'use strict';\n\nvar EventEmitter = require('events');\nvar fs = require('fs');\nvar os = require('os');\nvar path = require('path');\nvar util = require('util');\n\nmodule.exports = {\n  File: File,\n  FileRegistry: FileRegistry,\n  NullFile: NullFile,\n};\n\n/**\n * File manipulations on filesystem\n * @class\n * @extends EventEmitter\n * @property {number} size\n *\n * @constructor\n * @param {string} filePath\n * @param {WriteOptions} [writeOptions]\n * @param {boolean} [writeAsync]\n */\nfunction File(filePath, writeOptions, writeAsync) {\n  EventEmitter.call(this);\n\n  /**\n   * @type {string}\n   * @readonly\n   */\n  this.path = filePath;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.initialSize = undefined;\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.bytesWritten = 0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.writeAsync = Boolean(writeAsync);\n\n  /**\n   * @type {string[]}\n   * @private\n   */\n  this.asyncWriteQueue = [];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.hasActiveAsyncWritting = false;\n\n  /**\n   * @type {WriteOptions}\n   * @private\n   */\n  this.writeOptions = writeOptions || {\n    flag: 'a',\n    mode: 438, // 0666\n    encoding: 'utf8',\n  };\n\n  Object.defineProperty(this, 'size', {\n    get: this.getSize.bind(this),\n  });\n}\n\nutil.inherits(File, EventEmitter);\n\nFile.prototype.clear = function () {\n  try {\n    fs.writeFileSync(this.path, '', {\n      mode: this.writeOptions.mode,\n      flag: 'w',\n    });\n    this.reset();\n    return true;\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return true;\n    }\n\n    this.emit('error', e, this);\n    return false;\n  }\n};\n\nFile.prototype.crop = function (bytesAfter) {\n  try {\n    var content = readFileSyncFromEnd(this.path, bytesAfter || 4096);\n    this.clear();\n    this.writeLine('[log cropped]' + os.EOL + content);\n  } catch (e) {\n    this.emit(\n      'error',\n      new Error('Couldn\\'t crop file ' + this.path + '. ' + e.message),\n      this\n    );\n  }\n};\n\nFile.prototype.toString = function () {\n  return this.path;\n};\n\n/**\n * @package\n */\nFile.prototype.reset = function () {\n  this.initialSize = undefined;\n  this.bytesWritten = 0;\n};\n\n/**\n * @package\n */\nFile.prototype.writeLine = function (text) {\n  text += os.EOL;\n\n  if (this.writeAsync) {\n    this.asyncWriteQueue.push(text);\n    this.nextAsyncWrite();\n    return;\n  }\n\n  try {\n    fs.writeFileSync(this.path, text, this.writeOptions);\n    this.increaseBytesWrittenCounter(text);\n  } catch (e) {\n    this.emit(\n      'error',\n      new Error('Couldn\\'t write to ' + this.path + '. ' + e.message),\n      this\n    );\n  }\n};\n\n/**\n * @return {number}\n * @protected\n */\nFile.prototype.getSize = function () {\n  if (this.initialSize === undefined) {\n    try {\n      var stats = fs.statSync(this.path);\n      this.initialSize = stats.size;\n    } catch (e) {\n      this.initialSize = 0;\n    }\n  }\n\n  return this.initialSize + this.bytesWritten;\n};\n\n/**\n * @return {boolean}\n * @package\n */\nFile.prototype.isNull = function () {\n  return false;\n};\n\n/**\n * @private\n */\nFile.prototype.increaseBytesWrittenCounter = function (text) {\n  this.bytesWritten += Buffer.byteLength(text, this.writeOptions.encoding);\n};\n\n/**\n * @private\n */\nFile.prototype.nextAsyncWrite = function () {\n  var file = this;\n\n  if (this.hasActiveAsyncWritting || this.asyncWriteQueue.length < 1) {\n    return;\n  }\n\n  var text = this.asyncWriteQueue.shift();\n  this.hasActiveAsyncWritting = true;\n\n  fs.writeFile(this.path, text, this.writeOptions, function (e) {\n    file.hasActiveAsyncWritting = false;\n\n    if (e) {\n      file.emit(\n        'error',\n        new Error('Couldn\\'t write to ' + file.path + '. ' + e.message),\n        this\n      );\n    } else {\n      file.increaseBytesWrittenCounter(text);\n    }\n\n    file.nextAsyncWrite();\n  });\n};\n\n/**\n * File manipulations on filesystem\n * @class\n * @property {number} size\n *\n * @constructor\n * @param {string} filePath\n */\nfunction NullFile(filePath) {\n  File.call(this, filePath);\n}\n\nutil.inherits(NullFile, File);\n\nNullFile.prototype.clear = function () {};\nNullFile.prototype.crop = function () {};\nNullFile.prototype.writeLine = function () {};\nNullFile.prototype.getSize = function () { return 0 };\nNullFile.prototype.isNull = function () { return true };\n\n/**\n * Collection, key is a file path, value is a File instance\n * @class\n *\n * @constructor\n */\nfunction FileRegistry() {\n  EventEmitter.call(this);\n  this.store = {};\n\n  this.emitError = this.emitError.bind(this);\n}\n\nutil.inherits(FileRegistry, EventEmitter);\n\n/**\n * Provide a File object corresponding to the filePath\n * @param {string} filePath\n * @param {WriteOptions} [writeOptions]\n * @param {boolean} [async]\n * @return {File}\n */\nFileRegistry.prototype.provide = function (filePath, writeOptions, async) {\n  var file;\n  try {\n    filePath = path.resolve(filePath);\n\n    if (this.store[filePath]) {\n      return this.store[filePath];\n    }\n\n    file = this.createFile(filePath, writeOptions, Boolean(async));\n  } catch (e) {\n    file = new NullFile(filePath);\n    this.emitError(e, file);\n  }\n\n  file.on('error', this.emitError);\n  this.store[filePath] = file;\n  return file;\n};\n\n/**\n * @param {string} filePath\n * @param {WriteOptions} writeOptions\n * @param {boolean} async\n * @return {File}\n * @private\n */\nFileRegistry.prototype.createFile = function (filePath, writeOptions, async) {\n  this.testFileWriting(filePath);\n  return new File(filePath, writeOptions, async);\n};\n\n/**\n * @param {Error} error\n * @param {File} file\n * @private\n */\nFileRegistry.prototype.emitError = function (error, file) {\n  this.emit('error', error, file);\n};\n\n/**\n * @param {string} filePath\n * @private\n */\nFileRegistry.prototype.testFileWriting = function (filePath) {\n  mkDir(path.dirname(filePath));\n  fs.writeFileSync(filePath, '', { flag: 'a' });\n};\n\nfunction mkDir(dirPath) {\n  if (checkNodeJsVersion(10.12)) {\n    fs.mkdirSync(dirPath, { recursive: true });\n    return true;\n  }\n\n  try {\n    fs.mkdirSync(dirPath);\n    return true;\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      return mkDir(path.dirname(dirPath)) && mkDir(dirPath);\n    }\n\n    // eslint-disable-next-line no-useless-catch\n    try {\n      if (fs.statSync(dirPath).isDirectory()) {\n        return true;\n      }\n\n      // noinspection ExceptionCaughtLocallyJS\n      throw error;\n    } catch (e) {\n      throw e;\n    }\n  }\n}\n\nfunction checkNodeJsVersion(version) {\n  if (!process.versions) {\n    return false;\n  }\n\n  var nodeVersion = Number(\n    process.version.match(/^v(\\d+\\.\\d+)/)[1].replace(/\\.(\\d)$/, '.0$1')\n  );\n\n  return nodeVersion >= version;\n}\n\nfunction readFileSyncFromEnd(filePath, bytesCount) {\n  var buffer = Buffer.alloc(bytesCount);\n  var stats = fs.statSync(filePath);\n\n  var readLength = Math.min(stats.size, bytesCount);\n  var offset = Math.max(0, stats.size - bytesCount);\n\n  var fd = fs.openSync(filePath, 'r');\n  var totalBytes = fs.readSync(fd, buffer, 0, readLength, offset);\n  fs.closeSync(fd);\n\n  return buffer.toString('utf8', 0, totalBytes);\n}\n","'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar os = require('os');\nvar util = require('util');\nvar transform = require('../../transform');\nvar FileRegistry = require('./file').FileRegistry;\nvar variables = require('./variables');\n\nmodule.exports = fileTransportFactory;\n\n// Shared between multiple file transport instances\nvar globalRegistry = new FileRegistry();\n\nfunction fileTransportFactory(electronLog, customRegistry) {\n  var pathVariables = variables.getPathVariables(process.platform);\n\n  var registry = customRegistry || globalRegistry;\n  if (registry.listenerCount('error') < 1) {\n    registry.on('error', function (e, file) {\n      logConsole('Can\\'t write to ' + file, e);\n    });\n  }\n\n  /* eslint-disable no-multi-spaces */\n  transport.archiveLog   = archiveLog;\n  transport.depth        = 5;\n  transport.fileName     = getDefaultFileName();\n  transport\n    .format = '[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}]{scope} {text}';\n  transport.getFile      = getFile;\n  transport.level        = 'silly';\n  transport.maxSize      = 1024 * 1024;\n  transport.readAllLogs  = readAllLogs;\n  transport.resolvePath  = resolvePath;\n  transport.sync         = true;\n  transport.writeOptions = {\n    flag: 'a',\n    mode: 438, // 0666\n    encoding: 'utf8',\n  };\n  transport.inspectOptions = {};\n\n  initDeprecated();\n\n  return transport;\n\n  function transport(message) {\n    var file = getFile(message);\n\n    var needLogRotation = transport.maxSize > 0\n      && file.size > transport.maxSize;\n\n    if (needLogRotation) {\n      transport.archiveLog(file);\n      file.reset();\n    }\n\n    var scopeOptions = electronLog.scope.getOptions();\n    var inspectOptions = Object.assign(\n      { depth: transport.depth },\n      transport.inspectOptions\n    );\n    var content = transform.transform(message, [\n      transform.removeStyles,\n      transform.customFormatterFactory(transport.format, false, scopeOptions),\n      transform.concatFirstStringElements,\n      transform.toStringFactory(inspectOptions),\n    ]);\n\n    file.writeLine(content);\n  }\n\n  function archiveLog(file) {\n    var oldPath = file.toString();\n    var inf = path.parse(oldPath);\n    try {\n      fs.renameSync(oldPath, path.join(inf.dir, inf.name + '.old' + inf.ext));\n    } catch (e) {\n      logConsole('Could not rotate log', e);\n      var quarterOfMaxSize = Math.round(transport.maxSize / 4);\n      file.crop(Math.min(quarterOfMaxSize, 256 * 1024));\n    }\n  }\n\n  function logConsole(message, error) {\n    var data = ['electron-log.transports.file: ' + message];\n\n    if (error) {\n      data.push(error);\n    }\n\n    electronLog.transports.console({\n      data: data,\n      date: new Date(),\n      level: 'warn',\n    });\n  }\n\n  function getFile(msg) {\n    var vars = Object.assign({}, pathVariables, {\n      fileName: transport.fileName,\n    });\n\n    var filePath = transport.resolvePath(vars, msg);\n    return registry.provide(filePath, transport.writeOptions, !transport.sync);\n  }\n\n  /**\n   * @param {PathVariables} vars\n   */\n  function resolvePath(vars) {\n    return path.join(vars.libraryDefaultDir, vars.fileName);\n  }\n\n  function readAllLogs() {\n    var vars = Object.assign({}, pathVariables, {\n      fileName: transport.fileName,\n    });\n    var logsPath = path.dirname(transport.resolvePath(vars));\n\n    return fs.readdirSync(logsPath)\n      .map(function (fileName) {\n        var logPath = path.join(logsPath, fileName);\n        try {\n          return {\n            path: logPath,\n            lines: fs.readFileSync(logPath, 'utf8').split(os.EOL),\n          };\n        } catch (e) {\n          return null;\n        }\n      })\n      .filter(Boolean);\n  }\n\n  function initDeprecated() {\n    var isDeprecatedText = ' is deprecated and will be removed in v5.';\n    var isDeprecatedProp = ' property' + isDeprecatedText;\n\n    Object.defineProperties(transport, {\n      bytesWritten: {\n        get: util.deprecate(getBytesWritten, 'bytesWritten' + isDeprecatedProp),\n      },\n\n      file: {\n        get: util.deprecate(getLogFile, 'file' + isDeprecatedProp),\n        set: util.deprecate(setLogFile, 'file' + isDeprecatedProp),\n      },\n\n      fileSize: {\n        get: util.deprecate(getFileSize, 'file' + isDeprecatedProp),\n      },\n    });\n\n    transport.clear = util.deprecate(clear, 'clear()' + isDeprecatedText);\n    transport.findLogPath = util.deprecate(\n      getLogFile,\n      'findLogPath()' + isDeprecatedText\n    );\n    transport.init = util.deprecate(init, 'init()' + isDeprecatedText);\n\n    function getBytesWritten() {\n      return getFile().bytesWritten;\n    }\n\n    function getLogFile() {\n      return getFile().path;\n    }\n\n    function setLogFile(filePath) {\n      transport.resolvePath = function () {\n        return filePath;\n      };\n    }\n\n    function getFileSize() {\n      return getFile().size;\n    }\n\n    function clear() {\n      getFile().clear();\n    }\n\n    function init() {}\n  }\n}\n\nfunction getDefaultFileName() {\n  switch (process.type) {\n    case 'renderer': return 'renderer.log';\n    case 'worker': return 'worker.log';\n    default: return 'main.log';\n  }\n}\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nvar fs = require('fs');\nvar path = require('path');\n\nmodule.exports = {\n  readPackageJson: readPackageJson,\n  tryReadJsonAt: tryReadJsonAt,\n};\n\n/**\n * @return {{ name?: string, version?: string}}\n */\nfunction readPackageJson() {\n  return tryReadJsonAt(require.main && require.main.filename)\n    || tryReadJsonAt(extractPathFromArgs())\n    || tryReadJsonAt(process.resourcesPath, 'app.asar')\n    || tryReadJsonAt(process.resourcesPath, 'app')\n    || tryReadJsonAt(process.cwd())\n    || { name: null, version: null };\n}\n\n/**\n * @param {...string} searchPath\n * @return {{ name?: string, version?: string } | null}\n */\nfunction tryReadJsonAt(searchPath) {\n  if (!searchPath) {\n    return null;\n  }\n\n  try {\n    searchPath = path.join.apply(path, arguments);\n    var fileName = findUp('package.json', searchPath);\n    if (!fileName) {\n      return null;\n    }\n\n    var json = JSON.parse(fs.readFileSync(fileName, 'utf8'));\n    var name = json.productName || json.name;\n    if (!name || name.toLowerCase() === 'electron') {\n      return null;\n    }\n\n    if (json.productName || json.name) {\n      return {\n        name: name,\n        version: json.version,\n      };\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * @param {string} fileName\n * @param {string} [cwd]\n * @return {string | null}\n */\nfunction findUp(fileName, cwd) {\n  var currentPath = cwd;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    var parsedPath = path.parse(currentPath);\n    var root = parsedPath.root;\n    var dir = parsedPath.dir;\n\n    if (fs.existsSync(path.join(currentPath, fileName))) {\n      return path.resolve(path.join(currentPath, fileName));\n    }\n\n    if (currentPath === root) {\n      return null;\n    }\n\n    currentPath = dir;\n  }\n}\n\n/**\n * Get app path from --user-data-dir cmd arg, passed to a renderer process\n * @return {string|null}\n */\nfunction extractPathFromArgs() {\n  var matchedArgs = process.argv.filter(function (arg) {\n    return arg.indexOf('--user-data-dir=') === 0;\n  });\n\n  if (matchedArgs.length === 0 || typeof matchedArgs[0] !== 'string') {\n    return null;\n  }\n\n  var userDataDir = matchedArgs[0];\n  return userDataDir.replace('--user-data-dir=', '');\n}\n","'use strict';\n\nvar os = require('os');\nvar path = require('path');\nvar electronApi = require('../../electronApi');\nvar packageJson = require('./packageJson');\n\nmodule.exports = {\n  getAppData: getAppData,\n  getLibraryDefaultDir: getLibraryDefaultDir,\n  getLibraryTemplate: getLibraryTemplate,\n  getNameAndVersion: getNameAndVersion,\n  getPathVariables: getPathVariables,\n  getUserData: getUserData,\n};\n\nfunction getAppData(platform) {\n  var appData = electronApi.getPath('appData');\n  if (appData) {\n    return appData;\n  }\n\n  var home = getHome();\n\n  switch (platform) {\n    case 'darwin': {\n      return path.join(home, 'Library/Application Support');\n    }\n\n    case 'win32': {\n      return process.env.APPDATA || path.join(home, 'AppData/Roaming');\n    }\n\n    default: {\n      return process.env.XDG_CONFIG_HOME || path.join(home, '.config');\n    }\n  }\n}\n\nfunction getHome() {\n  return os.homedir ? os.homedir() : process.env.HOME;\n}\n\nfunction getLibraryDefaultDir(platform, appName) {\n  if (platform === 'darwin') {\n    return path.join(getHome(), 'Library/Logs', appName);\n  }\n\n  return path.join(getUserData(platform, appName), 'logs');\n}\n\nfunction getLibraryTemplate(platform) {\n  if (platform === 'darwin') {\n    return path.join(getHome(), 'Library/Logs', '{appName}');\n  }\n\n  return path.join(getAppData(platform), '{appName}', 'logs');\n}\n\nfunction getNameAndVersion() {\n  var name = electronApi.getName() || '';\n  var version = electronApi.getVersion();\n\n  if (name.toLowerCase() === 'electron') {\n    name = '';\n    version = '';\n  }\n\n  if (name && version) {\n    return { name: name, version: version };\n  }\n\n  var packageValues = packageJson.readPackageJson();\n  if (!name) {\n    name = packageValues.name;\n  }\n\n  if (!version) {\n    version = packageValues.version;\n  }\n\n  if (!name) {\n    // Fallback, otherwise file transport can't be initialized\n    name = 'Electron';\n  }\n\n  return { name: name, version: version };\n}\n\n/**\n * @param {string} platform\n * @return {PathVariables}\n */\nfunction getPathVariables(platform) {\n  var nameAndVersion = getNameAndVersion();\n  var appName = nameAndVersion.name;\n  var appVersion = nameAndVersion.version;\n\n  return {\n    appData: getAppData(platform),\n    appName: appName,\n    appVersion: appVersion,\n    electronDefaultDir: electronApi.getPath('logs'),\n    home: getHome(),\n    libraryDefaultDir: getLibraryDefaultDir(platform, appName),\n    libraryTemplate: getLibraryTemplate(platform),\n    temp: electronApi.getPath('temp') || os.tmpdir(),\n    userData: getUserData(platform, appName),\n  };\n}\n\nfunction getUserData(platform, appName) {\n  if (electronApi.getName() !== appName) {\n    return path.join(getAppData(platform), appName);\n  }\n\n  return electronApi.getPath('userData')\n    || path.join(getAppData(platform), appName);\n}\n","'use strict';\n\nvar transform = require('../transform');\nvar electronApi = require('../electronApi');\nvar log = require('../log.js');\n\nmodule.exports = ipcTransportFactory;\n\nfunction ipcTransportFactory(electronLog) {\n  transport.eventId = '__ELECTRON_LOG_IPC_' + electronLog.logId + '__';\n  transport.level = electronLog.isDev ? 'silly' : false;\n\n  // Prevent problems when there are multiple instances after webpack\n  if (electronApi.isIpcChannelListened(transport.eventId)) {\n    return function () {};\n  }\n\n  electronApi.onIpc(transport.eventId, function (_, message) {\n    message.date = new Date(message.date);\n\n    log.runTransport(\n      electronLog.transports.console,\n      message,\n      electronLog\n    );\n  });\n\n  electronApi.loadRemoteModule('electron-log');\n\n  return electronApi.isElectron() ? transport : null;\n\n  function transport(message) {\n    var ipcMessage = Object.assign({}, message, {\n      data: transform.transform(message, [\n        transform.toJSON,\n        transform.maxDepthFactory(3),\n      ]),\n    });\n\n    electronApi.sendIpc(transport.eventId, ipcMessage);\n  }\n}\n","'use strict';\n\nvar http = require('http');\nvar https = require('https');\nvar url = require('url');\nvar transform = require('../transform');\n\nmodule.exports = remoteTransportFactory;\n\nfunction remoteTransportFactory(electronLog) {\n  transport.client = { name: 'electron-application' };\n  transport.depth = 6;\n  transport.level = false;\n  transport.requestOptions = {};\n  transport.url = null;\n  transport.onError = null;\n  transport.transformBody = function (body) { return JSON.stringify(body) };\n\n  return transport;\n\n  function transport(message) {\n    if (!transport.url) return;\n\n    var body = transport.transformBody({\n      client: transport.client,\n      data: transform.transform(message, [\n        transform.removeStyles,\n        transform.toJSON,\n        transform.maxDepthFactory(transport.depth + 1),\n      ]),\n      date: message.date.getTime(),\n      level: message.level,\n      variables: message.variables,\n    });\n\n    var request = post(\n      transport.url,\n      transport.requestOptions,\n      Buffer.from(body, 'utf8')\n    );\n\n    request.on('error', transport.onError || onError);\n\n    function onError(error) {\n      electronLog.logMessageWithTransports(\n        {\n          data: [\n            'electron-log.transports.remote:'\n            + ' cannot send HTTP request to ' + transport.url,\n            error,\n          ],\n          level: 'warn',\n        },\n        [\n          electronLog.transports.console,\n          electronLog.transports.ipc,\n          electronLog.transports.file,\n        ]\n      );\n    }\n  }\n}\n\nfunction post(serverUrl, requestOptions, body) {\n  var urlObject = url.parse(serverUrl);\n  var httpTransport = urlObject.protocol === 'https:' ? https : http;\n\n  var options = {\n    hostname: urlObject.hostname,\n    port:     urlObject.port,\n    path:     urlObject.path,\n    method:   'POST',\n    headers:  {},\n  };\n\n  Object.assign(options, requestOptions);\n\n  options.headers['Content-Length'] = body.length;\n  if (!options.headers['Content-Type']) {\n    options.headers['Content-Type'] = 'application/json';\n  }\n\n  var request = httpTransport.request(options);\n  request.write(body);\n  request.end();\n\n  return request;\n}\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar electron_1 = __importDefault(require(\"electron\"));\nvar fs_1 = __importDefault(require(\"fs\"));\nvar mkdirp_1 = __importDefault(require(\"mkdirp\"));\nvar path_1 = __importDefault(require(\"path\"));\nvar write_file_atomic_1 = __importDefault(require(\"write-file-atomic\"));\nvar lodash_get_1 = __importDefault(require(\"lodash.get\"));\nvar lodash_has_1 = __importDefault(require(\"lodash.has\"));\nvar lodash_set_1 = __importDefault(require(\"lodash.set\"));\nvar lodash_unset_1 = __importDefault(require(\"lodash.unset\"));\n/** @internal */\nvar defaultConfig = {\n    atomicSave: true,\n    fileName: 'settings.json',\n    numSpaces: 2,\n    prettify: false,\n};\n/** @internal */\nvar config = __assign({}, defaultConfig);\n/**\n * Returns the Electron instance. The developer may define\n * a custom Electron instance by using `configure()`.\n *\n * @returns The Electron instance.\n * @internal\n */\nfunction getElectron() {\n    var _a;\n    return (_a = config.electron) !== null && _a !== void 0 ? _a : electron_1.default;\n}\n/**\n * Returns the Electron app. The app may need be accessed\n * via `Remote` depending on whether this code is running\n * in the main or renderer process.\n *\n * @returns The Electron app.\n * @internal\n */\nfunction getElectronApp() {\n    var _a;\n    var e = getElectron();\n    var app = (_a = e.app) !== null && _a !== void 0 ? _a : e.remote.app;\n    return app;\n}\n/**\n * Returns the path to the settings directory. The path\n * may be customized by the developer by using\n * `configure()`.\n *\n * @returns The path to the settings directory.\n * @internal\n */\nfunction getSettingsDirPath() {\n    var _a;\n    return (_a = config.dir) !== null && _a !== void 0 ? _a : getElectronApp().getPath('userData');\n}\n/**\n * Returns the path to the settings file. The file name\n * may be customized by the developer using `configure()`.\n *\n * @returns The path to the settings file.\n * @internal\n */\nfunction getSettingsFilePath() {\n    var dir = getSettingsDirPath();\n    return path_1.default.join(dir, config.fileName);\n}\n/**\n * Ensures that the settings file exists. If it does not\n * exist, then it is created.\n *\n * @returns A promise which resolves when the settings file exists.\n * @internal\n */\nfunction ensureSettingsFile() {\n    var filePath = getSettingsFilePath();\n    return new Promise(function (resolve, reject) {\n        fs_1.default.stat(filePath, function (err) {\n            if (err) {\n                if (err.code === 'ENOENT') {\n                    saveSettings({}).then(resolve, reject);\n                }\n                else {\n                    reject(err);\n                }\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n}\n/**\n * Ensures that the settings file exists. If it does not\n * exist, then it is created.\n *\n * @internal\n */\nfunction ensureSettingsFileSync() {\n    var filePath = getSettingsFilePath();\n    try {\n        fs_1.default.statSync(filePath);\n    }\n    catch (err) {\n        if (err) {\n            if (err.code === 'ENOENT') {\n                saveSettingsSync({});\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n}\n/**\n * Ensures that the settings directory exists. If it does\n * not exist, then it is created.\n *\n * @returns A promise which resolves when the settings dir exists.\n * @internal\n */\nfunction ensureSettingsDir() {\n    var dirPath = getSettingsDirPath();\n    return new Promise(function (resolve, reject) {\n        fs_1.default.stat(dirPath, function (err) {\n            if (err) {\n                if (err.code === 'ENOENT') {\n                    mkdirp_1.default(dirPath).then(function () { return resolve(); }, reject);\n                }\n                else {\n                    reject(err);\n                }\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n}\n/**\n * Ensures that the settings directory exists. If it does\n * not exist, then it is created.\n *\n * @internal\n */\nfunction ensureSettingsDirSync() {\n    var dirPath = getSettingsDirPath();\n    try {\n        fs_1.default.statSync(dirPath);\n    }\n    catch (err) {\n        if (err.code === 'ENOENT') {\n            mkdirp_1.default.sync(dirPath);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * First ensures that the settings file exists then loads\n * the settings from the disk.\n *\n * @returns A promise which resolves with the settings object.\n * @internal\n */\nfunction loadSettings() {\n    return ensureSettingsFile().then(function () {\n        var filePath = getSettingsFilePath();\n        return new Promise(function (resolve, reject) {\n            fs_1.default.readFile(filePath, 'utf-8', function (err, data) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    try {\n                        resolve(JSON.parse(data));\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                }\n            });\n        });\n    });\n}\n/**\n * First ensures that the settings file exists then loads\n * the settings from the disk.\n *\n * @returns The settings object.\n * @internal\n */\nfunction loadSettingsSync() {\n    var filePath = getSettingsFilePath();\n    ensureSettingsFileSync();\n    var data = fs_1.default.readFileSync(filePath, 'utf-8');\n    return JSON.parse(data);\n}\n/**\n * Saves the settings to the disk.\n *\n * @param obj The settings object to save.\n * @returns A promise which resolves when the settings have been saved.\n * @internal\n */\nfunction saveSettings(obj) {\n    return ensureSettingsDir().then(function () {\n        var filePath = getSettingsFilePath();\n        var numSpaces = config.prettify ? config.numSpaces : 0;\n        var data = JSON.stringify(obj, null, numSpaces);\n        return new Promise(function (resolve, reject) {\n            if (config.atomicSave) {\n                write_file_atomic_1.default(filePath, data, function (err) {\n                    return err\n                        ? reject(err)\n                        : resolve();\n                });\n            }\n            else {\n                fs_1.default.writeFile(filePath, data, function (err) {\n                    return err\n                        ? reject(err)\n                        : resolve();\n                });\n            }\n        });\n    });\n}\n/**\n * Saves the settings to the disk.\n *\n * @param obj The settings object to save.\n * @internal\n */\nfunction saveSettingsSync(obj) {\n    var filePath = getSettingsFilePath();\n    var numSpaces = config.prettify ? config.numSpaces : 0;\n    var data = JSON.stringify(obj, null, numSpaces);\n    ensureSettingsDirSync();\n    if (config.atomicSave) {\n        write_file_atomic_1.default.sync(filePath, data);\n    }\n    else {\n        fs_1.default.writeFileSync(filePath, data);\n    }\n}\n/**\n * Returns the path to the settings file.\n *\n * In general, the settings file is stored in your app's\n * user data directory in a file called `settings.json`.\n * The default user data directory varies by system.\n *\n * - **macOS** - `~/Library/Application\\ Support/<Your App>`\n * - **Windows** - `%APPDATA%/<Your App>`\n * - **Linux** - Either `$XDG_CONFIG_HOME/<Your App>` or\n * `~/.config/<Your App>`\n *\n * Although it is not recommended, you may change the name\n * or location of the settings file using\n * [[configure|configure()]].\n *\n * @returns The path to the settings file.\n * @example\n *\n * Get the path to the settings file.\n *\n *     settings.file();\n *     // => /home/nathan/.config/MyApp/settings.json\n */\nfunction file() {\n    return getSettingsFilePath();\n}\n/**\n * Sets the configuration for Electron Settings. To reset\n * to defaults, use [[reset|reset()]].\n *\n * Defaults:\n *\n *     {\n *       atomicSave: true,\n *       fileName: 'settings.json',\n *       numSpaces: 2,\n *       prettify: false\n *     }\n *\n * @param customConfig The custom configuration to use.\n * @example\n *\n * Update the filename to `cool-settings.json` and prettify\n * the output.\n *\n *     settings.configure({\n *       fileName: 'cool-settings.json',\n *       prettify: true\n *     });\n */\nfunction configure(customConfig) {\n    config = __assign(__assign({}, config), customConfig);\n}\n/**\n * Resets the Electron Settings configuration to defaults.\n *\n * @example\n *\n * Reset configuration to defaults.\n *\n *     settings.reset();\n */\nfunction reset() {\n    config = __assign({}, defaultConfig);\n}\n/**\n * Checks if the given key path exists. For sync,\n * use [[hasSync|hasSync()]].\n *\n * @category Core\n * @param keyPath The key path to check.\n * @returns A promise which resolves to `true` if the\n * `keyPath` exists, else `false`.\n * @example\n *\n * Check if the value at `color.name` exists.\n *\n *     // Given:\n *     //\n *     // {\n *     //   \"color\": {\n *     //     \"name\": \"cerulean\",\n *     //     \"code\": {\n *     //       \"rgb\": [0, 179, 230],\n *     //       \"hex\": \"#003BE6\"\n *     //     }\n *     //   }\n *     // }\n *\n *     const exists = await settings.has('color.name');\n *     // => true\n *\n * @example\n *\n * Check if the value at `color.hue` exists.\n *\n *     const h = 'hue';\n *     const exists = await settings.has(['color', h]);\n *     // => false\n *\n *  @example\n *\n * Check if the value at `color.code.rgb[1]` exists.\n *\n *     const exists = await settings.has(color.code.rgb[1]);\n *     // => true\n */\nfunction has(keyPath) {\n    return __awaiter(this, void 0, void 0, function () {\n        var obj;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, loadSettings()];\n                case 1:\n                    obj = _a.sent();\n                    return [2 /*return*/, lodash_has_1.default(obj, keyPath)];\n            }\n        });\n    });\n}\n/**\n * Checks if the given key path exists. For async,\n * use [[hasSync|hasSync()]].\n *\n * @category Core\n * @param keyPath The key path to check.\n * @returns `true` if the `keyPath` exists, else `false`.\n * @example\n *\n * Check if the value at `color.name` exists.\n *\n *     // Given:\n *     //\n *     // {\n *     //   \"color\": {\n *     //     \"name\": \"cerulean\",\n *     //     \"code\": {\n *     //       \"rgb\": [0, 179, 230],\n *     //       \"hex\": \"#003BE6\"\n *     //     }\n *     //   }\n *     // }\n *\n *     const exists = settings.hasSync('color.name');\n *     // => true\n *\n * @example\n *\n * Check if the value at `color.hue` exists.\n *\n *     const h = 'hue';\n *     const exists = settings.hasSync(['color', h]);\n *     // => false\n *\n * @example\n *\n * Check if the value at `color.code.rgb[1]` exists.\n *\n *     const exists = settings.hasSync(color.code.rgb[1]);\n *     // => true\n */\nfunction hasSync(keyPath) {\n    var obj = loadSettingsSync();\n    return lodash_has_1.default(obj, keyPath);\n}\nfunction get(keyPath) {\n    return __awaiter(this, void 0, void 0, function () {\n        var obj;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, loadSettings()];\n                case 1:\n                    obj = _a.sent();\n                    if (keyPath) {\n                        return [2 /*return*/, lodash_get_1.default(obj, keyPath)];\n                    }\n                    else {\n                        return [2 /*return*/, obj];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction getSync(keyPath) {\n    var obj = loadSettingsSync();\n    if (keyPath) {\n        return lodash_get_1.default(obj, keyPath);\n    }\n    else {\n        return obj;\n    }\n}\nfunction set() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return __awaiter(this, void 0, void 0, function () {\n        var value, keyPath, value, obj;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(args.length === 1)) return [3 /*break*/, 1];\n                    value = args[0];\n                    return [2 /*return*/, saveSettings(value)];\n                case 1:\n                    keyPath = args[0], value = args[1];\n                    return [4 /*yield*/, loadSettings()];\n                case 2:\n                    obj = _a.sent();\n                    lodash_set_1.default(obj, keyPath, value);\n                    return [2 /*return*/, saveSettings(obj)];\n            }\n        });\n    });\n}\nfunction setSync() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var value = args[0];\n        saveSettingsSync(value);\n    }\n    else {\n        var keyPath = args[0], value = args[1];\n        var obj = loadSettingsSync();\n        lodash_set_1.default(obj, keyPath, value);\n        saveSettingsSync(obj);\n    }\n}\nfunction unset(keyPath) {\n    return __awaiter(this, void 0, void 0, function () {\n        var obj;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!keyPath) return [3 /*break*/, 2];\n                    return [4 /*yield*/, loadSettings()];\n                case 1:\n                    obj = _a.sent();\n                    lodash_unset_1.default(obj, keyPath);\n                    return [2 /*return*/, saveSettings(obj)];\n                case 2: \n                // Unset all settings by saving empty object.\n                return [2 /*return*/, saveSettings({})];\n            }\n        });\n    });\n}\nfunction unsetSync(keyPath) {\n    if (keyPath) {\n        var obj = loadSettingsSync();\n        lodash_unset_1.default(obj, keyPath);\n        saveSettingsSync(obj);\n    }\n    else {\n        // Unset all settings by saving empty object.\n        saveSettingsSync({});\n    }\n}\nmodule.exports = {\n    file: file,\n    configure: configure,\n    reset: reset,\n    has: has,\n    hasSync: hasSync,\n    get: get,\n    getSync: getSync,\n    set: set,\n    setSync: setSync,\n    unset: unset,\n    unsetSync: unsetSync,\n};\n//# sourceMappingURL=settings.js.map","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0002'\n    )\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirs = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimesMillis = require('../util/utimes').utimesMillis\nconst stat = require('../util/stat')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  stat.checkPaths(src, dest, 'copy', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return getStats(destStat, src, dest, opts, cb)\n    mkdirs(destParent, err => {\n      if (err) return cb(err)\n      return getStats(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`))\n    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`))\n    return cb(new Error(`Unknown file: ${src}`))\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  fs.copyFile(src, dest, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)\n    return setDestMode(dest, srcStat.mode, cb)\n  })\n}\n\nfunction handleTimestampsAndMode (srcMode, src, dest, cb) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    return makeFileWritable(dest, srcMode, err => {\n      if (err) return cb(err)\n      return setDestTimestampsAndMode(srcMode, src, dest, cb)\n    })\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest, cb)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode, cb) {\n  return setDestMode(dest, srcMode | 0o200, cb)\n}\n\nfunction setDestTimestampsAndMode (srcMode, src, dest, cb) {\n  setDestTimestamps(src, dest, err => {\n    if (err) return cb(err)\n    return setDestMode(dest, srcMode, cb)\n  })\n}\n\nfunction setDestMode (dest, srcMode, cb) {\n  return fs.chmod(dest, srcMode, cb)\n}\n\nfunction setDestTimestamps (src, dest, cb) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  fs.stat(src, (err, updatedSrcStat) => {\n    if (err) return cb(err)\n    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return setDestMode(dest, srcMode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy')),\n  copySync: require('./copy-sync')\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(async function emptyDir (dir) {\n  let items\n  try {\n    items = await fs.readdir(dir)\n  } catch {\n    return mkdir.mkdirs(dir)\n  }\n\n  return Promise.all(items.map(item => remove.remove(path.join(dir, item))))\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    fs.stat(dir, (err, stats) => {\n      if (err) {\n        // if the directory doesn't exist, make it\n        if (err.code === 'ENOENT') {\n          return mkdir.mkdirs(dir, err => {\n            if (err) return callback(err)\n            makeFile()\n          })\n        }\n        return callback(err)\n      }\n\n      if (stats.isDirectory()) makeFile()\n      else {\n        // parent is not a directory\n        // This is just to cause an internal ENOTDIR error to be thrown\n        fs.readdir(dir, err => {\n          if (err) return callback(err)\n        })\n      }\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      // parent is not a directory\n      // This is just to cause an internal ENOTDIR error to be thrown\n      fs.readdirSync(dir)\n    }\n  } catch (err) {\n    // If the stat call above failed because the directory doesn't exist, create it\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)\n    else throw err\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst { createFile, createFileSync } = require('./file')\nconst { createLink, createLinkSync } = require('./link')\nconst { createSymlink, createSymlinkSync } = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile,\n  createFileSync,\n  ensureFile: createFile,\n  ensureFileSync: createFileSync,\n  // link\n  createLink,\n  createLinkSync,\n  ensureLink: createLink,\n  ensureLinkSync: createLinkSync,\n  // symlink\n  createSymlink,\n  createSymlinkSync,\n  ensureSymlink: createSymlink,\n  ensureSymlinkSync: createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\nconst { areIdentical } = require('../util/stat')\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  fs.lstat(dstpath, (_, dstStat) => {\n    fs.lstat(srcpath, (err, srcStat) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n      if (dstStat && areIdentical(srcStat, dstStat)) return callback(null)\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  let dstStat\n  try {\n    dstStat = fs.lstatSync(dstpath)\n  } catch {}\n\n  try {\n    const srcStat = fs.lstatSync(srcpath)\n    if (dstStat && areIdentical(srcStat, dstStat)) return\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        toCwd: srcpath,\n        toDst: srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          toCwd: relativeToDst,\n          toDst: srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        toCwd: relativeToDst,\n        toDst: srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        toCwd: srcpath,\n        toDst: path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('../fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nconst { areIdentical } = require('../util/stat')\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  fs.lstat(dstpath, (err, stats) => {\n    if (!err && stats.isSymbolicLink()) {\n      Promise.all([\n        fs.stat(srcpath),\n        fs.stat(dstpath)\n      ]).then(([srcStat, dstStat]) => {\n        if (areIdentical(srcStat, dstStat)) return callback(null)\n        _createSymlink(srcpath, dstpath, type, callback)\n      })\n    } else _createSymlink(srcpath, dstpath, type, callback)\n  })\n}\n\nfunction _createSymlink (srcpath, dstpath, type, callback) {\n  symlinkPaths(srcpath, dstpath, (err, relative) => {\n    if (err) return callback(err)\n    srcpath = relative.toDst\n    symlinkType(relative.toCwd, type, (err, type) => {\n      if (err) return callback(err)\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n        mkdirs(dir, err => {\n          if (err) return callback(err)\n          fs.symlink(srcpath, dstpath, type, callback)\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  let stats\n  try {\n    stats = fs.lstatSync(dstpath)\n  } catch {}\n  if (stats && stats.isSymbolicLink()) {\n    const srcStat = fs.statSync(srcpath)\n    const dstStat = fs.statSync(dstpath)\n    if (areIdentical(srcStat, dstStat)) return\n  }\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchmod',\n  'lchown',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rm',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.opendir was added in Node.js v12.12.0\n  // fs.rm was added in Node.js v14.14.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export cloned fs:\nObject.assign(exports, fs)\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.writev only available in Node v12.9.0+\nif (typeof fs.writev === 'function') {\n  // Function signature is\n  // s.writev(fd, buffers[, position], callback)\n  // We need to handle the optional arg, so we use ...args\n  exports.writev = function (fd, buffers, ...args) {\n    if (typeof args[args.length - 1] === 'function') {\n      return fs.writev(fd, buffers, ...args)\n    }\n\n    return new Promise((resolve, reject) => {\n      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n        if (err) return reject(err)\n        resolve({ bytesWritten, buffers })\n      })\n    })\n  }\n}\n\n// fs.realpath.native sometimes not available if fs is monkey-patched\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n} else {\n  process.emitWarning(\n    'fs.realpath.native is not a function. Is fs being monkey-patched?',\n    'Warning', 'fs-extra-WARN0003'\n  )\n}\n","'use strict'\n\nmodule.exports = {\n  // Export promiseified graceful-fs:\n  ...require('./fs'),\n  // Export extra methods:\n  ...require('./copy'),\n  ...require('./empty'),\n  ...require('./ensure'),\n  ...require('./json'),\n  ...require('./mkdirs'),\n  ...require('./move'),\n  ...require('./output-file'),\n  ...require('./path-exists'),\n  ...require('./remove')\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync\n}\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFileSync } = require('../output-file')\n\nfunction outputJsonSync (file, data, options) {\n  const str = stringify(data, options)\n\n  outputFileSync(file, str, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFile } = require('../output-file')\n\nasync function outputJson (file, data, options = {}) {\n  const str = stringify(data, options)\n\n  await outputFile(file, str, options)\n}\n\nmodule.exports = outputJson\n","'use strict'\nconst u = require('universalify').fromPromise\nconst { makeDir: _makeDir, makeDirSync } = require('./make-dir')\nconst makeDir = u(_makeDir)\n\nmodule.exports = {\n  mkdirs: makeDir,\n  mkdirsSync: makeDirSync,\n  // alias\n  mkdirp: makeDir,\n  mkdirpSync: makeDirSync,\n  ensureDir: makeDir,\n  ensureDirSync: makeDirSync\n}\n","'use strict'\nconst fs = require('../fs')\nconst { checkPath } = require('./utils')\n\nconst getMode = options => {\n  const defaults = { mode: 0o777 }\n  if (typeof options === 'number') return options\n  return ({ ...defaults, ...options }).mode\n}\n\nmodule.exports.makeDir = async (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdir(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n\nmodule.exports.makeDirSync = (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdirSync(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n","// Adapted from https://github.com/sindresorhus/make-dir\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict'\nconst path = require('path')\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nmodule.exports.checkPath = function checkPath (pth) {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''))\n\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`)\n      error.code = 'EINVAL'\n      throw error\n    }\n  }\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  move: u(require('./move')),\n  moveSync: require('./move-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, 'move', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite, isChangingCase)\n}\n\nfunction isParentRoot (dest) {\n  const parent = path.dirname(dest)\n  const parsedPath = path.parse(parent)\n  return parsedPath.root === parent\n}\n\nfunction doRename (src, dest, overwrite, isChangingCase) {\n  if (isChangingCase) return rename(src, dest, overwrite)\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\nconst stat = require('../util/stat')\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  opts = opts || {}\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, isChangingCase = false } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, isChangingCase, cb)\n      })\n    })\n  })\n}\n\nfunction isParentRoot (dest) {\n  const parent = path.dirname(dest)\n  const parsedPath = path.parse(parent)\n  return parsedPath.root === parent\n}\n\nfunction doRename (src, dest, overwrite, isChangingCase, cb) {\n  if (isChangingCase) return rename(src, dest, overwrite, cb)\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nfunction remove (path, callback) {\n  // Node 14.14.0+\n  if (fs.rm) return fs.rm(path, { recursive: true, force: true }, callback)\n  rimraf(path, callback)\n}\n\nfunction removeSync (path) {\n  // Node 14.14.0+\n  if (fs.rmSync) return fs.rmSync(path, { recursive: true, force: true })\n  rimraf.sync(path)\n}\n\nmodule.exports = {\n  remove: u(remove),\n  removeSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch {}\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src)\n        const destBaseName = path.basename(dest)\n        if (funcName === 'move' &&\n          srcBaseName !== destBaseName &&\n          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, { srcStat, destStat, isChangingCase: true })\n        }\n        return cb(new Error('Source and destination must not be the same.'))\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  fs.stat(destParent, { bigint: true }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  })\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  utimesMillis,\n  utimesMillisSync\n}\n","let _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\nconst universalify = require('universalify')\nconst { stringify, stripBom } = require('./utils')\n\nasync function _readFile (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  let data = await universalify.fromCallback(fs.readFile)(file, options)\n\n  data = stripBom(data)\n\n  let obj\n  try {\n    obj = JSON.parse(data, options ? options.reviver : null)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n\n  return obj\n}\n\nconst readFile = universalify.fromPromise(_readFile)\n\nfunction readFileSync (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  try {\n    let content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nasync function _writeFile (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n\n  await universalify.fromCallback(fs.writeFile)(file, str, options)\n}\n\nconst writeFile = universalify.fromPromise(_writeFile)\n\nfunction writeFileSync (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nconst jsonfile = {\n  readFile,\n  readFileSync,\n  writeFile,\n  writeFileSync\n}\n\nmodule.exports = jsonfile\n","function stringify (obj, { EOL = '\\n', finalEOL = true, replacer = null, spaces } = {}) {\n  const EOF = finalEOL ? EOL : ''\n  const str = JSON.stringify(obj, replacer, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOF\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  return content.replace(/^\\uFEFF/, '')\n}\n\nmodule.exports = { stringify, stripBom }\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false,\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = require('../internal/parse-options')\nconst { re, t } = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    range = range.trim()\n\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts = Object.keys(this.options).join(',')\n    const memoKey = `parseRange:${memoOpts}:${range}`\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst LRU = require('lru-cache')\nconst cache = new LRU({ max: 1000 })\n\nconst parseOptions = require('../internal/parse-options')\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = require('../internal/re')\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((c) => {\n    return replaceTilde(c, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((c) => {\n    return replaceCaret(c, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((c) => {\n    return replaceXRange(c, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { re, t } = require('../internal/re')\n\nconst parseOptions = require('../internal/parse-options')\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","const parse = require('./parse')\nconst eq = require('./eq')\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const { MAX_LENGTH } = require('../internal/constants')\nconst { re, t } = require('../internal/re')\nconst SemVer = require('../classes/semver')\n\nconst parseOptions = require('../internal/parse-options')\nconst parse = (version, options) => {\n  options = parseOptions(options)\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: require('./internal/constants').SEMVER_SPEC_VERSION,\n  SemVer: require('./classes/semver'),\n  compareIdentifiers: require('./internal/identifiers').compareIdentifiers,\n  rcompareIdentifiers: require('./internal/identifiers').rcompareIdentifiers,\n  parse: require('./functions/parse'),\n  valid: require('./functions/valid'),\n  clean: require('./functions/clean'),\n  inc: require('./functions/inc'),\n  diff: require('./functions/diff'),\n  major: require('./functions/major'),\n  minor: require('./functions/minor'),\n  patch: require('./functions/patch'),\n  prerelease: require('./functions/prerelease'),\n  compare: require('./functions/compare'),\n  rcompare: require('./functions/rcompare'),\n  compareLoose: require('./functions/compare-loose'),\n  compareBuild: require('./functions/compare-build'),\n  sort: require('./functions/sort'),\n  rsort: require('./functions/rsort'),\n  gt: require('./functions/gt'),\n  lt: require('./functions/lt'),\n  eq: require('./functions/eq'),\n  neq: require('./functions/neq'),\n  gte: require('./functions/gte'),\n  lte: require('./functions/lte'),\n  cmp: require('./functions/cmp'),\n  coerce: require('./functions/coerce'),\n  Comparator: require('./classes/comparator'),\n  Range: require('./classes/range'),\n  satisfies: require('./functions/satisfies'),\n  toComparators: require('./ranges/to-comparators'),\n  maxSatisfying: require('./ranges/max-satisfying'),\n  minSatisfying: require('./ranges/min-satisfying'),\n  minVersion: require('./ranges/min-version'),\n  validRange: require('./ranges/valid'),\n  outside: require('./ranges/outside'),\n  gtr: require('./ranges/gtr'),\n  ltr: require('./ranges/ltr'),\n  intersects: require('./ranges/intersects'),\n  simplifyRange: require('./ranges/simplify'),\n  subset: require('./ranges/subset'),\n}\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH,\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n","// parse out just the options we care about so we always get a consistent\n// obj with keys in a consistent order.\nconst opts = ['includePrerelease', 'loose', 'rtl']\nconst parseOptions = options =>\n  !options ? {}\n  : typeof options !== 'object' ? { loose: true }\n  : opts.filter(k => options[k]).reduce((o, k) => {\n    o[k] = true\n    return o\n  }, {})\nmodule.exports = parseOptions\n","const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst { ANY } = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst Comparator = require('../classes/comparator.js')\nconst { ANY } = Comparator\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = [new Comparator('>=0.0.0-0')]\n    } else {\n      sub = [new Comparator('>=0.0.0')]\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = [new Comparator('>=0.0.0')]\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.call(\n          this,\n          ...args,\n          (err, res) => (err != null) ? reject(err) : resolve(res)\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAppCacheDir = void 0;\nconst path = require(\"path\");\nconst os_1 = require(\"os\");\nfunction getAppCacheDir() {\n    const homedir = os_1.homedir();\n    // https://github.com/electron/electron/issues/1404#issuecomment-194391247\n    let result;\n    if (process.platform === \"win32\") {\n        result = process.env[\"LOCALAPPDATA\"] || path.join(homedir, \"AppData\", \"Local\");\n    }\n    else if (process.platform === \"darwin\") {\n        result = path.join(homedir, \"Library\", \"Application Support\", \"Caches\");\n    }\n    else {\n        result = process.env[\"XDG_CACHE_HOME\"] || path.join(homedir, \".cache\");\n    }\n    return result;\n}\nexports.getAppCacheDir = getAppCacheDir;\n//# sourceMappingURL=AppAdapter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppImageUpdater = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst child_process_1 = require(\"child_process\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst fs_1 = require(\"fs\");\nconst path = require(\"path\");\nconst BaseUpdater_1 = require(\"./BaseUpdater\");\nconst FileWithEmbeddedBlockMapDifferentialDownloader_1 = require(\"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\");\nconst main_1 = require(\"./main\");\nconst Provider_1 = require(\"./providers/Provider\");\nclass AppImageUpdater extends BaseUpdater_1.BaseUpdater {\n    constructor(options, app) {\n        super(options, app);\n    }\n    isUpdaterActive() {\n        if (process.env[\"APPIMAGE\"] == null) {\n            if (process.env[\"SNAP\"] == null) {\n                this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\");\n            }\n            else {\n                this._logger.info(\"SNAP env is defined, updater is disabled\");\n            }\n            return false;\n        }\n        return super.isUpdaterActive();\n    }\n    /*** @private */\n    doDownloadUpdate(downloadUpdateOptions) {\n        const provider = downloadUpdateOptions.updateInfoAndProvider.provider;\n        const fileInfo = Provider_1.findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"AppImage\");\n        return this.executeDownload({\n            fileExtension: \"AppImage\",\n            fileInfo,\n            downloadUpdateOptions,\n            task: async (updateFile, downloadOptions) => {\n                const oldFile = process.env[\"APPIMAGE\"];\n                if (oldFile == null) {\n                    throw builder_util_runtime_1.newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\");\n                }\n                let isDownloadFull = false;\n                try {\n                    const downloadOptions = {\n                        newUrl: fileInfo.url,\n                        oldFile,\n                        logger: this._logger,\n                        newFile: updateFile,\n                        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n                        requestHeaders: downloadUpdateOptions.requestHeaders,\n                        cancellationToken: downloadUpdateOptions.cancellationToken,\n                    };\n                    if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {\n                        downloadOptions.onProgress = it => this.emit(main_1.DOWNLOAD_PROGRESS, it);\n                    }\n                    await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download();\n                }\n                catch (e) {\n                    this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);\n                    // during test (developer machine mac) we must throw error\n                    isDownloadFull = process.platform === \"linux\";\n                }\n                if (isDownloadFull) {\n                    await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);\n                }\n                await fs_extra_1.chmod(updateFile, 0o755);\n            },\n        });\n    }\n    doInstall(options) {\n        const appImageFile = process.env[\"APPIMAGE\"];\n        if (appImageFile == null) {\n            throw builder_util_runtime_1.newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\");\n        }\n        // https://stackoverflow.com/a/1712051/1910191\n        fs_1.unlinkSync(appImageFile);\n        let destination;\n        const existingBaseName = path.basename(appImageFile);\n        // https://github.com/electron-userland/electron-builder/issues/2964\n        // if no version in existing file name, it means that user wants to preserve current custom name\n        if (path.basename(options.installerPath) === existingBaseName || !/\\d+\\.\\d+\\.\\d+/.test(existingBaseName)) {\n            // no version in the file name, overwrite existing\n            destination = appImageFile;\n        }\n        else {\n            destination = path.join(path.dirname(appImageFile), path.basename(options.installerPath));\n        }\n        child_process_1.execFileSync(\"mv\", [\"-f\", options.installerPath, destination]);\n        if (destination !== appImageFile) {\n            this.emit(\"appimage-filename-updated\", destination);\n        }\n        const env = {\n            ...process.env,\n            APPIMAGE_SILENT_INSTALL: \"true\",\n        };\n        if (options.isForceRunAfter) {\n            child_process_1.spawn(destination, [], {\n                detached: true,\n                stdio: \"ignore\",\n                env,\n            }).unref();\n        }\n        else {\n            env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\";\n            child_process_1.execFileSync(destination, [], { env });\n        }\n        return true;\n    }\n}\nexports.AppImageUpdater = AppImageUpdater;\n//# sourceMappingURL=AppImageUpdater.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoOpLogger = exports.AppUpdater = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst crypto_1 = require(\"crypto\");\nconst events_1 = require(\"events\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst promises_1 = require(\"fs/promises\");\nconst js_yaml_1 = require(\"js-yaml\");\nconst lazy_val_1 = require(\"lazy-val\");\nconst path = require(\"path\");\nconst semver_1 = require(\"semver\");\nconst DownloadedUpdateHelper_1 = require(\"./DownloadedUpdateHelper\");\nconst ElectronAppAdapter_1 = require(\"./ElectronAppAdapter\");\nconst electronHttpExecutor_1 = require(\"./electronHttpExecutor\");\nconst GenericProvider_1 = require(\"./providers/GenericProvider\");\nconst main_1 = require(\"./main\");\nconst providerFactory_1 = require(\"./providerFactory\");\nclass AppUpdater extends events_1.EventEmitter {\n    constructor(options, app) {\n        super();\n        /**\n         * Whether to automatically download an update when it is found.\n         */\n        this.autoDownload = true;\n        /**\n         * Whether to automatically install a downloaded update on app quit (if `quitAndInstall` was not called before).\n         */\n        this.autoInstallOnAppQuit = true;\n        /**\n         * *GitHub provider only.* Whether to allow update to pre-release versions. Defaults to `true` if application version contains prerelease components (e.g. `0.12.1-alpha.1`, here `alpha` is a prerelease component), otherwise `false`.\n         *\n         * If `true`, downgrade will be allowed (`allowDowngrade` will be set to `true`).\n         */\n        this.allowPrerelease = false;\n        /**\n         * *GitHub provider only.* Get all release notes (from current version to latest), not just the latest.\n         * @default false\n         */\n        this.fullChangelog = false;\n        /**\n         * Whether to allow version downgrade (when a user from the beta channel wants to go back to the stable channel).\n         *\n         * Taken in account only if channel differs (pre-release version component in terms of semantic versioning).\n         *\n         * @default false\n         */\n        this.allowDowngrade = false;\n        this._channel = null;\n        this.downloadedUpdateHelper = null;\n        /**\n         *  The request headers.\n         */\n        this.requestHeaders = null;\n        this._logger = console;\n        // noinspection JSUnusedGlobalSymbols\n        /**\n         * For type safety you can use signals, e.g. `autoUpdater.signals.updateDownloaded(() => {})` instead of `autoUpdater.on('update-available', () => {})`\n         */\n        this.signals = new main_1.UpdaterSignal(this);\n        this._appUpdateConfigPath = null;\n        this.clientPromise = null;\n        this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());\n        // public, allow to read old config for anyone\n        /** @internal */\n        this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());\n        this.checkForUpdatesPromise = null;\n        this.updateInfoAndProvider = null;\n        /**\n         * @private\n         * @internal\n         */\n        this._testOnlyOptions = null;\n        this.on(\"error\", (error) => {\n            this._logger.error(`Error: ${error.stack || error.message}`);\n        });\n        if (app == null) {\n            this.app = new ElectronAppAdapter_1.ElectronAppAdapter();\n            this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit(\"login\", authInfo, callback));\n        }\n        else {\n            this.app = app;\n            this.httpExecutor = null;\n        }\n        const currentVersionString = this.app.version;\n        const currentVersion = semver_1.parse(currentVersionString);\n        if (currentVersion == null) {\n            throw builder_util_runtime_1.newError(`App version is not a valid semver version: \"${currentVersionString}\"`, \"ERR_UPDATER_INVALID_VERSION\");\n        }\n        this.currentVersion = currentVersion;\n        this.allowPrerelease = hasPrereleaseComponents(currentVersion);\n        if (options != null) {\n            this.setFeedURL(options);\n            if (typeof options !== \"string\" && options.requestHeaders) {\n                this.requestHeaders = options.requestHeaders;\n            }\n        }\n    }\n    /**\n     * Get the update channel. Not applicable for GitHub. Doesn't return `channel` from the update configuration, only if was previously set.\n     */\n    get channel() {\n        return this._channel;\n    }\n    /**\n     * Set the update channel. Not applicable for GitHub. Overrides `channel` in the update configuration.\n     *\n     * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.\n     */\n    set channel(value) {\n        if (this._channel != null) {\n            // noinspection SuspiciousTypeOfGuard\n            if (typeof value !== \"string\") {\n                throw builder_util_runtime_1.newError(`Channel must be a string, but got: ${value}`, \"ERR_UPDATER_INVALID_CHANNEL\");\n            }\n            else if (value.length === 0) {\n                throw builder_util_runtime_1.newError(`Channel must be not an empty string`, \"ERR_UPDATER_INVALID_CHANNEL\");\n            }\n        }\n        this._channel = value;\n        this.allowDowngrade = true;\n    }\n    /**\n     *  Shortcut for explicitly adding auth tokens to request headers\n     */\n    addAuthHeader(token) {\n        this.requestHeaders = Object.assign({}, this.requestHeaders, {\n            authorization: token,\n        });\n    }\n    // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols\n    get netSession() {\n        return electronHttpExecutor_1.getNetSession();\n    }\n    /**\n     * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.\n     * Set it to `null` if you would like to disable a logging feature.\n     */\n    get logger() {\n        return this._logger;\n    }\n    set logger(value) {\n        this._logger = value == null ? new NoOpLogger() : value;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * test only\n     * @private\n     */\n    set updateConfigPath(value) {\n        this.clientPromise = null;\n        this._appUpdateConfigPath = value;\n        this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());\n    }\n    //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols\n    getFeedURL() {\n        return \"Deprecated. Do not use it.\";\n    }\n    /**\n     * Configure update provider. If value is `string`, [GenericServerOptions](/configuration/publish#genericserveroptions) will be set with value as `url`.\n     * @param options If you want to override configuration in the `app-update.yml`.\n     */\n    setFeedURL(options) {\n        const runtimeOptions = this.createProviderRuntimeOptions();\n        // https://github.com/electron-userland/electron-builder/issues/1105\n        let provider;\n        if (typeof options === \"string\") {\n            provider = new GenericProvider_1.GenericProvider({ provider: \"generic\", url: options }, this, {\n                ...runtimeOptions,\n                isUseMultipleRangeRequest: providerFactory_1.isUrlProbablySupportMultiRangeRequests(options),\n            });\n        }\n        else {\n            provider = providerFactory_1.createClient(options, this, runtimeOptions);\n        }\n        this.clientPromise = Promise.resolve(provider);\n    }\n    /**\n     * Asks the server whether there is an update.\n     */\n    checkForUpdates() {\n        let checkForUpdatesPromise = this.checkForUpdatesPromise;\n        if (checkForUpdatesPromise != null) {\n            this._logger.info(\"Checking for update (already in progress)\");\n            return checkForUpdatesPromise;\n        }\n        const nullizePromise = () => (this.checkForUpdatesPromise = null);\n        this._logger.info(\"Checking for update\");\n        checkForUpdatesPromise = this.doCheckForUpdates()\n            .then(it => {\n            nullizePromise();\n            return it;\n        })\n            .catch(e => {\n            nullizePromise();\n            this.emit(\"error\", e, `Cannot check for updates: ${(e.stack || e).toString()}`);\n            throw e;\n        });\n        this.checkForUpdatesPromise = checkForUpdatesPromise;\n        return checkForUpdatesPromise;\n    }\n    isUpdaterActive() {\n        if (!this.app.isPackaged) {\n            this._logger.info(\"Skip checkForUpdatesAndNotify because application is not packed\");\n            return false;\n        }\n        return true;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    checkForUpdatesAndNotify(downloadNotification) {\n        if (!this.isUpdaterActive()) {\n            return Promise.resolve(null);\n        }\n        return this.checkForUpdates().then(it => {\n            const downloadPromise = it.downloadPromise;\n            if (downloadPromise == null) {\n                if (this._logger.debug != null) {\n                    this._logger.debug(\"checkForUpdatesAndNotify called, downloadPromise is null\");\n                }\n                return it;\n            }\n            void downloadPromise.then(() => {\n                const notificationContent = AppUpdater.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);\n                new (require(\"electron\").Notification)(notificationContent).show();\n            });\n            return it;\n        });\n    }\n    static formatDownloadNotification(version, appName, downloadNotification) {\n        if (downloadNotification == null) {\n            downloadNotification = {\n                title: \"A new update is ready to install\",\n                body: `{appName} version {version} has been downloaded and will be automatically installed on exit`,\n            };\n        }\n        downloadNotification = {\n            title: downloadNotification.title.replace(\"{appName}\", appName).replace(\"{version}\", version),\n            body: downloadNotification.body.replace(\"{appName}\", appName).replace(\"{version}\", version),\n        };\n        return downloadNotification;\n    }\n    async isStagingMatch(updateInfo) {\n        const rawStagingPercentage = updateInfo.stagingPercentage;\n        let stagingPercentage = rawStagingPercentage;\n        if (stagingPercentage == null) {\n            return true;\n        }\n        stagingPercentage = parseInt(stagingPercentage, 10);\n        if (isNaN(stagingPercentage)) {\n            this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);\n            return true;\n        }\n        // convert from user 0-100 to internal 0-1\n        stagingPercentage = stagingPercentage / 100;\n        const stagingUserId = await this.stagingUserIdPromise.value;\n        const val = builder_util_runtime_1.UUID.parse(stagingUserId).readUInt32BE(12);\n        const percentage = val / 0xffffffff;\n        this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);\n        return percentage < stagingPercentage;\n    }\n    computeFinalHeaders(headers) {\n        if (this.requestHeaders != null) {\n            Object.assign(headers, this.requestHeaders);\n        }\n        return headers;\n    }\n    async isUpdateAvailable(updateInfo) {\n        const latestVersion = semver_1.parse(updateInfo.version);\n        if (latestVersion == null) {\n            throw builder_util_runtime_1.newError(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: \"${updateInfo.version}\"`, \"ERR_UPDATER_INVALID_VERSION\");\n        }\n        const currentVersion = this.currentVersion;\n        if (semver_1.eq(latestVersion, currentVersion)) {\n            return false;\n        }\n        const isStagingMatch = await this.isStagingMatch(updateInfo);\n        if (!isStagingMatch) {\n            return false;\n        }\n        // https://github.com/electron-userland/electron-builder/pull/3111#issuecomment-405033227\n        // https://github.com/electron-userland/electron-builder/pull/3111#issuecomment-405030797\n        const isLatestVersionNewer = semver_1.gt(latestVersion, currentVersion);\n        const isLatestVersionOlder = semver_1.lt(latestVersion, currentVersion);\n        if (isLatestVersionNewer) {\n            return true;\n        }\n        return this.allowDowngrade && isLatestVersionOlder;\n    }\n    async getUpdateInfoAndProvider() {\n        await this.app.whenReady();\n        if (this.clientPromise == null) {\n            this.clientPromise = this.configOnDisk.value.then(it => providerFactory_1.createClient(it, this, this.createProviderRuntimeOptions()));\n        }\n        const client = await this.clientPromise;\n        const stagingUserId = await this.stagingUserIdPromise.value;\n        client.setRequestHeaders(this.computeFinalHeaders({ \"x-user-staging-id\": stagingUserId }));\n        return {\n            info: await client.getLatestVersion(),\n            provider: client,\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n    createProviderRuntimeOptions() {\n        return {\n            isUseMultipleRangeRequest: true,\n            platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,\n            executor: this.httpExecutor,\n        };\n    }\n    async doCheckForUpdates() {\n        this.emit(\"checking-for-update\");\n        const result = await this.getUpdateInfoAndProvider();\n        const updateInfo = result.info;\n        if (!(await this.isUpdateAvailable(updateInfo))) {\n            this._logger.info(`Update for version ${this.currentVersion} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? \"allowed\" : \"disallowed\"}).`);\n            this.emit(\"update-not-available\", updateInfo);\n            return {\n                versionInfo: updateInfo,\n                updateInfo,\n            };\n        }\n        this.updateInfoAndProvider = result;\n        this.onUpdateAvailable(updateInfo);\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        //noinspection ES6MissingAwait\n        return {\n            versionInfo: updateInfo,\n            updateInfo,\n            cancellationToken,\n            downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null,\n        };\n    }\n    onUpdateAvailable(updateInfo) {\n        this._logger.info(`Found version ${updateInfo.version} (url: ${builder_util_runtime_1.asArray(updateInfo.files)\n            .map(it => it.url)\n            .join(\", \")})`);\n        this.emit(\"update-available\", updateInfo);\n    }\n    /**\n     * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.\n     * @returns {Promise<string>} Path to downloaded file.\n     */\n    downloadUpdate(cancellationToken = new builder_util_runtime_1.CancellationToken()) {\n        const updateInfoAndProvider = this.updateInfoAndProvider;\n        if (updateInfoAndProvider == null) {\n            const error = new Error(\"Please check update first\");\n            this.dispatchError(error);\n            return Promise.reject(error);\n        }\n        this._logger.info(`Downloading update from ${builder_util_runtime_1.asArray(updateInfoAndProvider.info.files)\n            .map(it => it.url)\n            .join(\", \")}`);\n        const errorHandler = (e) => {\n            // https://github.com/electron-userland/electron-builder/issues/1150#issuecomment-436891159\n            if (!(e instanceof builder_util_runtime_1.CancellationError)) {\n                try {\n                    this.dispatchError(e);\n                }\n                catch (nestedError) {\n                    this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);\n                }\n            }\n            return e;\n        };\n        try {\n            return this.doDownloadUpdate({\n                updateInfoAndProvider,\n                requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),\n                cancellationToken,\n            }).catch(e => {\n                throw errorHandler(e);\n            });\n        }\n        catch (e) {\n            return Promise.reject(errorHandler(e));\n        }\n    }\n    dispatchError(e) {\n        this.emit(\"error\", e, (e.stack || e).toString());\n    }\n    dispatchUpdateDownloaded(event) {\n        this.emit(main_1.UPDATE_DOWNLOADED, event);\n    }\n    async loadUpdateConfig() {\n        if (this._appUpdateConfigPath == null) {\n            this._appUpdateConfigPath = this.app.appUpdateConfigPath;\n        }\n        return js_yaml_1.load(await promises_1.readFile(this._appUpdateConfigPath, \"utf-8\"));\n    }\n    computeRequestHeaders(provider) {\n        const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;\n        if (fileExtraDownloadHeaders != null) {\n            const requestHeaders = this.requestHeaders;\n            return requestHeaders == null\n                ? fileExtraDownloadHeaders\n                : {\n                    ...fileExtraDownloadHeaders,\n                    ...requestHeaders,\n                };\n        }\n        return this.computeFinalHeaders({ accept: \"*/*\" });\n    }\n    async getOrCreateStagingUserId() {\n        const file = path.join(this.app.userDataPath, \".updaterId\");\n        try {\n            const id = await promises_1.readFile(file, \"utf-8\");\n            if (builder_util_runtime_1.UUID.check(id)) {\n                return id;\n            }\n            else {\n                this._logger.warn(`Staging user id file exists, but content was invalid: ${id}`);\n            }\n        }\n        catch (e) {\n            if (e.code !== \"ENOENT\") {\n                this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);\n            }\n        }\n        const id = builder_util_runtime_1.UUID.v5(crypto_1.randomBytes(4096), builder_util_runtime_1.UUID.OID);\n        this._logger.info(`Generated new staging user ID: ${id}`);\n        try {\n            await fs_extra_1.outputFile(file, id);\n        }\n        catch (e) {\n            this._logger.warn(`Couldn't write out staging user ID: ${e}`);\n        }\n        return id;\n    }\n    /** @internal */\n    get isAddNoCacheQuery() {\n        const headers = this.requestHeaders;\n        // https://github.com/electron-userland/electron-builder/issues/3021\n        if (headers == null) {\n            return true;\n        }\n        for (const headerName of Object.keys(headers)) {\n            const s = headerName.toLowerCase();\n            if (s === \"authorization\" || s === \"private-token\") {\n                return false;\n            }\n        }\n        return true;\n    }\n    async getOrCreateDownloadHelper() {\n        let result = this.downloadedUpdateHelper;\n        if (result == null) {\n            const dirName = (await this.configOnDisk.value).updaterCacheDirName;\n            const logger = this._logger;\n            if (dirName == null) {\n                logger.error(\"updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?\");\n            }\n            const cacheDir = path.join(this.app.baseCachePath, dirName || this.app.name);\n            if (logger.debug != null) {\n                logger.debug(`updater cache dir: ${cacheDir}`);\n            }\n            result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);\n            this.downloadedUpdateHelper = result;\n        }\n        return result;\n    }\n    async executeDownload(taskOptions) {\n        const fileInfo = taskOptions.fileInfo;\n        const downloadOptions = {\n            headers: taskOptions.downloadUpdateOptions.requestHeaders,\n            cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,\n            sha2: fileInfo.info.sha2,\n            sha512: fileInfo.info.sha512,\n        };\n        if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {\n            downloadOptions.onProgress = it => this.emit(main_1.DOWNLOAD_PROGRESS, it);\n        }\n        const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;\n        const version = updateInfo.version;\n        const packageInfo = fileInfo.packageInfo;\n        function getCacheUpdateFileName() {\n            // NodeJS URL doesn't decode automatically\n            const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);\n            if (urlPath.endsWith(`.${taskOptions.fileExtension}`)) {\n                return path.posix.basename(urlPath);\n            }\n            else {\n                // url like /latest, generate name\n                return `update.${taskOptions.fileExtension}`;\n            }\n        }\n        const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();\n        const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;\n        await promises_1.mkdir(cacheDir, { recursive: true });\n        const updateFileName = getCacheUpdateFileName();\n        let updateFile = path.join(cacheDir, updateFileName);\n        const packageFile = packageInfo == null ? null : path.join(cacheDir, `package-${version}${path.extname(packageInfo.path) || \".7z\"}`);\n        const done = async (isSaveCache) => {\n            await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);\n            await taskOptions.done({\n                ...updateInfo,\n                downloadedFile: updateFile,\n            });\n            return packageFile == null ? [updateFile] : [updateFile, packageFile];\n        };\n        const log = this._logger;\n        const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log);\n        if (cachedUpdateFile != null) {\n            updateFile = cachedUpdateFile;\n            return await done(false);\n        }\n        const removeFileIfAny = async () => {\n            await downloadedUpdateHelper.clear().catch(() => {\n                // ignore\n            });\n            return await promises_1.unlink(updateFile).catch(() => {\n                // ignore\n            });\n        };\n        const tempUpdateFile = await DownloadedUpdateHelper_1.createTempUpdateFile(`temp-${updateFileName}`, cacheDir, log);\n        try {\n            await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);\n            await promises_1.rename(tempUpdateFile, updateFile);\n        }\n        catch (e) {\n            await removeFileIfAny();\n            if (e instanceof builder_util_runtime_1.CancellationError) {\n                log.info(\"cancelled\");\n                this.emit(\"update-cancelled\", updateInfo);\n            }\n            throw e;\n        }\n        log.info(`New version ${version} has been downloaded to ${updateFile}`);\n        return await done(true);\n    }\n}\nexports.AppUpdater = AppUpdater;\nfunction hasPrereleaseComponents(version) {\n    const versionPrereleaseComponent = semver_1.prerelease(version);\n    return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;\n}\n/** @private */\nclass NoOpLogger {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    info(message) {\n        // ignore\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    warn(message) {\n        // ignore\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    error(message) {\n        // ignore\n    }\n}\nexports.NoOpLogger = NoOpLogger;\n//# sourceMappingURL=AppUpdater.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseUpdater = void 0;\nconst AppUpdater_1 = require(\"./AppUpdater\");\nclass BaseUpdater extends AppUpdater_1.AppUpdater {\n    constructor(options, app) {\n        super(options, app);\n        this.quitAndInstallCalled = false;\n        this.quitHandlerAdded = false;\n    }\n    quitAndInstall(isSilent = false, isForceRunAfter = false) {\n        this._logger.info(`Install on explicit quitAndInstall`);\n        const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : true);\n        if (isInstalled) {\n            setImmediate(() => {\n                // this event is normally emitted when calling quitAndInstall, this emulates that\n                require(\"electron\").autoUpdater.emit(\"before-quit-for-update\");\n                this.app.quit();\n            });\n        }\n        else {\n            this.quitAndInstallCalled = false;\n        }\n    }\n    executeDownload(taskOptions) {\n        return super.executeDownload({\n            ...taskOptions,\n            done: event => {\n                this.dispatchUpdateDownloaded(event);\n                this.addQuitHandler();\n                return Promise.resolve();\n            },\n        });\n    }\n    // must be sync (because quit even handler is not async)\n    install(isSilent, isForceRunAfter) {\n        if (this.quitAndInstallCalled) {\n            this._logger.warn(\"install call ignored: quitAndInstallCalled is set to true\");\n            return false;\n        }\n        const downloadedUpdateHelper = this.downloadedUpdateHelper;\n        const installerPath = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.file;\n        const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;\n        if (installerPath == null || downloadedFileInfo == null) {\n            this.dispatchError(new Error(\"No valid update available, can't quit and install\"));\n            return false;\n        }\n        // prevent calling several times\n        this.quitAndInstallCalled = true;\n        try {\n            this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}`);\n            return this.doInstall({\n                installerPath,\n                isSilent,\n                isForceRunAfter,\n                isAdminRightsRequired: downloadedFileInfo.isAdminRightsRequired,\n            });\n        }\n        catch (e) {\n            this.dispatchError(e);\n            return false;\n        }\n    }\n    addQuitHandler() {\n        if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {\n            return;\n        }\n        this.quitHandlerAdded = true;\n        this.app.onQuit(exitCode => {\n            if (this.quitAndInstallCalled) {\n                this._logger.info(\"Update installer has already been triggered. Quitting application.\");\n                return;\n            }\n            if (!this.autoInstallOnAppQuit) {\n                this._logger.info(\"Update will not be installed on quit because autoInstallOnAppQuit is set to false.\");\n                return;\n            }\n            if (exitCode !== 0) {\n                this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);\n                return;\n            }\n            this._logger.info(\"Auto install update on quit\");\n            this.install(true, false);\n        });\n    }\n}\nexports.BaseUpdater = BaseUpdater;\n//# sourceMappingURL=BaseUpdater.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createTempUpdateFile = exports.DownloadedUpdateHelper = void 0;\nconst crypto_1 = require(\"crypto\");\nconst fs_1 = require(\"fs\");\n// @ts-ignore\nconst isEqual = require(\"lodash.isequal\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst path = require(\"path\");\n/** @private **/\nclass DownloadedUpdateHelper {\n    constructor(cacheDir) {\n        this.cacheDir = cacheDir;\n        this._file = null;\n        this._packageFile = null;\n        this.versionInfo = null;\n        this.fileInfo = null;\n        this._downloadedFileInfo = null;\n    }\n    get downloadedFileInfo() {\n        return this._downloadedFileInfo;\n    }\n    get file() {\n        return this._file;\n    }\n    get packageFile() {\n        return this._packageFile;\n    }\n    get cacheDirForPendingUpdate() {\n        return path.join(this.cacheDir, \"pending\");\n    }\n    async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger) {\n        if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {\n            // update has already been downloaded from this running instance\n            // check here only existence, not checksum\n            if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && (await fs_extra_1.pathExists(updateFile))) {\n                return updateFile;\n            }\n            else {\n                return null;\n            }\n        }\n        // update has already been downloaded from some previous app launch\n        const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger);\n        if (cachedUpdateFile === null) {\n            return null;\n        }\n        logger.info(`Update has already been downloaded to ${updateFile}).`);\n        this._file = cachedUpdateFile;\n        return cachedUpdateFile;\n    }\n    async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {\n        this._file = downloadedFile;\n        this._packageFile = packageFile;\n        this.versionInfo = versionInfo;\n        this.fileInfo = fileInfo;\n        this._downloadedFileInfo = {\n            fileName: updateFileName,\n            sha512: fileInfo.info.sha512,\n            isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true,\n        };\n        if (isSaveCache) {\n            await fs_extra_1.outputJson(this.getUpdateInfoFile(), this._downloadedFileInfo);\n        }\n    }\n    async clear() {\n        this._file = null;\n        this._packageFile = null;\n        this.versionInfo = null;\n        this.fileInfo = null;\n        await this.cleanCacheDirForPendingUpdate();\n    }\n    async cleanCacheDirForPendingUpdate() {\n        try {\n            // remove stale data\n            await fs_extra_1.emptyDir(this.cacheDirForPendingUpdate);\n        }\n        catch (ignore) {\n            // ignore\n        }\n    }\n    /**\n     * Returns \"update-info.json\" which is created in the update cache directory's \"pending\" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.\n     * @param fileInfo\n     * @param logger\n     */\n    async getValidCachedUpdateFile(fileInfo, logger) {\n        var _a;\n        const updateInfoFilePath = this.getUpdateInfoFile();\n        const doesUpdateInfoFileExist = await fs_extra_1.pathExists(updateInfoFilePath);\n        if (!doesUpdateInfoFileExist) {\n            return null;\n        }\n        let cachedInfo;\n        try {\n            cachedInfo = await fs_extra_1.readJson(updateInfoFilePath);\n        }\n        catch (error) {\n            let message = `No cached update info available`;\n            if (error.code !== \"ENOENT\") {\n                await this.cleanCacheDirForPendingUpdate();\n                message += ` (error on read: ${error.message})`;\n            }\n            logger.info(message);\n            return null;\n        }\n        const isCachedInfoFileNameValid = (_a = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null) !== null && _a !== void 0 ? _a : false;\n        if (!isCachedInfoFileNameValid) {\n            logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);\n            await this.cleanCacheDirForPendingUpdate();\n            return null;\n        }\n        if (fileInfo.info.sha512 !== cachedInfo.sha512) {\n            logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);\n            await this.cleanCacheDirForPendingUpdate();\n            return null;\n        }\n        const updateFile = path.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);\n        if (!(await fs_extra_1.pathExists(updateFile))) {\n            logger.info(\"Cached update file doesn't exist\");\n            return null;\n        }\n        const sha512 = await hashFile(updateFile);\n        if (fileInfo.info.sha512 !== sha512) {\n            logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);\n            await this.cleanCacheDirForPendingUpdate();\n            return null;\n        }\n        this._downloadedFileInfo = cachedInfo;\n        return updateFile;\n    }\n    getUpdateInfoFile() {\n        return path.join(this.cacheDirForPendingUpdate, \"update-info.json\");\n    }\n}\nexports.DownloadedUpdateHelper = DownloadedUpdateHelper;\nfunction hashFile(file, algorithm = \"sha512\", encoding = \"base64\", options) {\n    return new Promise((resolve, reject) => {\n        const hash = crypto_1.createHash(algorithm);\n        hash.on(\"error\", reject).setEncoding(encoding);\n        fs_1.createReadStream(file, { ...options, highWaterMark: 1024 * 1024 /* better to use more memory but hash faster */ })\n            .on(\"error\", reject)\n            .on(\"end\", () => {\n            hash.end();\n            resolve(hash.read());\n        })\n            .pipe(hash, { end: false });\n    });\n}\nasync function createTempUpdateFile(name, cacheDir, log) {\n    // https://github.com/electron-userland/electron-builder/pull/2474#issuecomment-366481912\n    let nameCounter = 0;\n    let result = path.join(cacheDir, name);\n    for (let i = 0; i < 3; i++) {\n        try {\n            await fs_extra_1.unlink(result);\n            return result;\n        }\n        catch (e) {\n            if (e.code === \"ENOENT\") {\n                return result;\n            }\n            log.warn(`Error on remove temp update file: ${e}`);\n            result = path.join(cacheDir, `${nameCounter++}-${name}`);\n        }\n    }\n    return result;\n}\nexports.createTempUpdateFile = createTempUpdateFile;\n//# sourceMappingURL=DownloadedUpdateHelper.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ElectronAppAdapter = void 0;\nconst path = require(\"path\");\nconst AppAdapter_1 = require(\"./AppAdapter\");\nclass ElectronAppAdapter {\n    constructor(app = require(\"electron\").app) {\n        this.app = app;\n    }\n    whenReady() {\n        return this.app.whenReady();\n    }\n    get version() {\n        return this.app.getVersion();\n    }\n    get name() {\n        return this.app.getName();\n    }\n    get isPackaged() {\n        return this.app.isPackaged === true;\n    }\n    get appUpdateConfigPath() {\n        return this.isPackaged ? path.join(process.resourcesPath, \"app-update.yml\") : path.join(this.app.getAppPath(), \"dev-app-update.yml\");\n    }\n    get userDataPath() {\n        return this.app.getPath(\"userData\");\n    }\n    get baseCachePath() {\n        return AppAdapter_1.getAppCacheDir();\n    }\n    quit() {\n        this.app.quit();\n    }\n    onQuit(handler) {\n        this.app.once(\"quit\", (_, exitCode) => handler(exitCode));\n    }\n}\nexports.ElectronAppAdapter = ElectronAppAdapter;\n//# sourceMappingURL=ElectronAppAdapter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MacUpdater = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst fs_1 = require(\"fs\");\nconst http_1 = require(\"http\");\nconst AppUpdater_1 = require(\"./AppUpdater\");\nconst Provider_1 = require(\"./providers/Provider\");\nconst child_process_1 = require(\"child_process\");\nclass MacUpdater extends AppUpdater_1.AppUpdater {\n    constructor(options, app) {\n        super(options, app);\n        this.nativeUpdater = require(\"electron\").autoUpdater;\n        this.squirrelDownloadedUpdate = false;\n        this.nativeUpdater.on(\"error\", it => {\n            this._logger.warn(it);\n            this.emit(\"error\", it);\n        });\n        this.nativeUpdater.on(\"update-downloaded\", () => {\n            this.squirrelDownloadedUpdate = true;\n        });\n    }\n    debug(message) {\n        if (this._logger.debug != null) {\n            this._logger.debug(message);\n        }\n    }\n    async doDownloadUpdate(downloadUpdateOptions) {\n        let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);\n        const log = this._logger;\n        // detect if we are running inside Rosetta emulation\n        const sysctlRosettaInfoKey = \"sysctl.proc_translated\";\n        let isRosetta = false;\n        try {\n            this.debug(\"Checking for macOS Rosetta environment\");\n            const result = child_process_1.execFileSync(\"sysctl\", [sysctlRosettaInfoKey], { encoding: \"utf8\" });\n            isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);\n            log.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);\n        }\n        catch (e) {\n            log.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);\n        }\n        let isArm64Mac = false;\n        try {\n            this.debug(\"Checking for arm64 in uname\");\n            const result = child_process_1.execFileSync(\"uname\", ['-a'], { encoding: \"utf8\" });\n            const isArm = result.includes('ARM');\n            log.info(`Checked 'uname -a': arm64=${isArm}`);\n            isArm64Mac = isArm64Mac || isArm;\n        }\n        catch (e) {\n            log.warn(`uname shell command to check for arm64 failed: ${e}`);\n        }\n        isArm64Mac = isArm64Mac || process.arch === 'arm64' || isRosetta;\n        // allow arm64 macs to install universal or rosetta2(x64) - https://github.com/electron-userland/electron-builder/pull/5524\n        const isArm64 = (file) => { var _a; return file.url.pathname.includes(\"arm64\") || ((_a = file.info.url) === null || _a === void 0 ? void 0 : _a.includes(\"arm64\")); };\n        if (isArm64Mac && files.some(isArm64)) {\n            files = files.filter(file => isArm64Mac === isArm64(file));\n        }\n        else {\n            files = files.filter(file => !isArm64(file));\n        }\n        const zipFileInfo = Provider_1.findFile(files, \"zip\", [\"pkg\", \"dmg\"]);\n        if (zipFileInfo == null) {\n            throw builder_util_runtime_1.newError(`ZIP file not provided: ${builder_util_runtime_1.safeStringifyJson(files)}`, \"ERR_UPDATER_ZIP_FILE_NOT_FOUND\");\n        }\n        return this.executeDownload({\n            fileExtension: \"zip\",\n            fileInfo: zipFileInfo,\n            downloadUpdateOptions,\n            task: (destinationFile, downloadOptions) => {\n                return this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);\n            },\n            done: event => this.updateDownloaded(zipFileInfo, event),\n        });\n    }\n    async updateDownloaded(zipFileInfo, event) {\n        var _a;\n        const downloadedFile = event.downloadedFile;\n        const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await fs_extra_1.stat(downloadedFile)).size;\n        const log = this._logger;\n        const logContext = `fileToProxy=${zipFileInfo.url.href}`;\n        this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);\n        const server = http_1.createServer();\n        this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);\n        server.on(\"close\", () => {\n            log.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);\n        });\n        // must be called after server is listening, otherwise address is null\n        function getServerUrl() {\n            const address = server.address();\n            return `http://127.0.0.1:${address.port}`;\n        }\n        return await new Promise((resolve, reject) => {\n            // insecure random is ok\n            const fileUrl = `/${Date.now().toString(16)}-${Math.floor(Math.random() * 9999).toString(16)}.zip`;\n            server.on(\"request\", (request, response) => {\n                const requestUrl = request.url;\n                log.info(`${requestUrl} requested`);\n                if (requestUrl === \"/\") {\n                    const data = Buffer.from(`{ \"url\": \"${getServerUrl()}${fileUrl}\" }`);\n                    response.writeHead(200, { \"Content-Type\": \"application/json\", \"Content-Length\": data.length });\n                    response.end(data);\n                    return;\n                }\n                if (!requestUrl.startsWith(fileUrl)) {\n                    log.warn(`${requestUrl} requested, but not supported`);\n                    response.writeHead(404);\n                    response.end();\n                    return;\n                }\n                log.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);\n                let errorOccurred = false;\n                response.on(\"finish\", () => {\n                    try {\n                        setImmediate(() => server.close());\n                    }\n                    finally {\n                        if (!errorOccurred) {\n                            this.nativeUpdater.removeListener(\"error\", reject);\n                            resolve([]);\n                        }\n                    }\n                });\n                const readStream = fs_1.createReadStream(downloadedFile);\n                readStream.on(\"error\", error => {\n                    try {\n                        response.end();\n                    }\n                    catch (e) {\n                        log.warn(`cannot end response: ${e}`);\n                    }\n                    errorOccurred = true;\n                    this.nativeUpdater.removeListener(\"error\", reject);\n                    reject(new Error(`Cannot pipe \"${downloadedFile}\": ${error}`));\n                });\n                response.writeHead(200, {\n                    \"Content-Type\": \"application/zip\",\n                    \"Content-Length\": updateFileSize,\n                });\n                readStream.pipe(response);\n            });\n            this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);\n            server.listen(0, \"127.0.0.1\", () => {\n                this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl()}, ${logContext})`);\n                this.nativeUpdater.setFeedURL({\n                    url: getServerUrl(),\n                    headers: { \"Cache-Control\": \"no-cache\" },\n                });\n                // The update has been downloaded and is ready to be served to Squirrel\n                this.dispatchUpdateDownloaded(event);\n                if (this.autoInstallOnAppQuit) {\n                    this.nativeUpdater.once(\"error\", reject);\n                    // This will trigger fetching and installing the file on Squirrel side\n                    this.nativeUpdater.checkForUpdates();\n                }\n                else {\n                    resolve([]);\n                }\n            });\n        });\n    }\n    quitAndInstall() {\n        if (this.squirrelDownloadedUpdate) {\n            // update already fetched by Squirrel, it's ready to install\n            this.nativeUpdater.quitAndInstall();\n        }\n        else {\n            // Quit and install as soon as Squirrel get the update\n            this.nativeUpdater.on(\"update-downloaded\", () => {\n                this.nativeUpdater.quitAndInstall();\n            });\n            if (!this.autoInstallOnAppQuit) {\n                /**\n                 * If this was not `true` previously then MacUpdater.doDownloadUpdate()\n                 * would not actually initiate the downloading by electron's autoUpdater\n                 */\n                this.nativeUpdater.checkForUpdates();\n            }\n        }\n    }\n}\nexports.MacUpdater = MacUpdater;\n//# sourceMappingURL=MacUpdater.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NsisUpdater = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst child_process_1 = require(\"child_process\");\nconst path = require(\"path\");\nconst BaseUpdater_1 = require(\"./BaseUpdater\");\nconst FileWithEmbeddedBlockMapDifferentialDownloader_1 = require(\"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\");\nconst GenericDifferentialDownloader_1 = require(\"./differentialDownloader/GenericDifferentialDownloader\");\nconst main_1 = require(\"./main\");\nconst util_1 = require(\"./util\");\nconst Provider_1 = require(\"./providers/Provider\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst windowsExecutableCodeSignatureVerifier_1 = require(\"./windowsExecutableCodeSignatureVerifier\");\nconst url_1 = require(\"url\");\nconst zlib_1 = require(\"zlib\");\nclass NsisUpdater extends BaseUpdater_1.BaseUpdater {\n    constructor(options, app) {\n        super(options, app);\n    }\n    /*** @private */\n    doDownloadUpdate(downloadUpdateOptions) {\n        const provider = downloadUpdateOptions.updateInfoAndProvider.provider;\n        const fileInfo = Provider_1.findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"exe\");\n        return this.executeDownload({\n            fileExtension: \"exe\",\n            downloadUpdateOptions,\n            fileInfo,\n            task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {\n                const packageInfo = fileInfo.packageInfo;\n                const isWebInstaller = packageInfo != null && packageFile != null;\n                if (isWebInstaller || (await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider))) {\n                    await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);\n                }\n                const signatureVerificationStatus = await this.verifySignature(destinationFile);\n                if (signatureVerificationStatus != null) {\n                    await removeTempDirIfAny();\n                    // noinspection ThrowInsideFinallyBlockJS\n                    throw builder_util_runtime_1.newError(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, \"ERR_UPDATER_INVALID_SIGNATURE\");\n                }\n                if (isWebInstaller) {\n                    if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {\n                        try {\n                            await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {\n                                headers: downloadUpdateOptions.requestHeaders,\n                                cancellationToken: downloadUpdateOptions.cancellationToken,\n                                sha512: packageInfo.sha512,\n                            });\n                        }\n                        catch (e) {\n                            try {\n                                await fs_extra_1.unlink(packageFile);\n                            }\n                            catch (ignored) {\n                                // ignore\n                            }\n                            throw e;\n                        }\n                    }\n                }\n            },\n        });\n    }\n    // $certificateInfo = (Get-AuthenticodeSignature 'xxx\\yyy.exe'\n    // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains(\"CN=siemens.com\")})\n    // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }\n    async verifySignature(tempUpdateFile) {\n        let publisherName;\n        try {\n            publisherName = (await this.configOnDisk.value).publisherName;\n            if (publisherName == null) {\n                return null;\n            }\n        }\n        catch (e) {\n            if (e.code === \"ENOENT\") {\n                // no app-update.yml\n                return null;\n            }\n            throw e;\n        }\n        return await windowsExecutableCodeSignatureVerifier_1.verifySignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile, this._logger);\n    }\n    doInstall(options) {\n        const args = [\"--updated\"];\n        if (options.isSilent) {\n            args.push(\"/S\");\n        }\n        if (options.isForceRunAfter) {\n            args.push(\"--force-run\");\n        }\n        const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;\n        if (packagePath != null) {\n            // only = form is supported\n            args.push(`--package-file=${packagePath}`);\n        }\n        const callUsingElevation = () => {\n            _spawn(path.join(process.resourcesPath, \"elevate.exe\"), [options.installerPath].concat(args)).catch(e => this.dispatchError(e));\n        };\n        if (options.isAdminRightsRequired) {\n            this._logger.info(\"isAdminRightsRequired is set to true, run installer using elevate.exe\");\n            callUsingElevation();\n            return true;\n        }\n        _spawn(options.installerPath, args).catch((e) => {\n            // https://github.com/electron-userland/electron-builder/issues/1129\n            // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors\n            const errorCode = e.code;\n            this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: \"${e.message}\", will be executed again using elevate if EACCES\"`);\n            if (errorCode === \"UNKNOWN\" || errorCode === \"EACCES\") {\n                callUsingElevation();\n            }\n            else {\n                this.dispatchError(e);\n            }\n        });\n        return true;\n    }\n    async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider) {\n        try {\n            if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {\n                return true;\n            }\n            const blockmapFileUrls = util_1.blockmapFiles(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);\n            this._logger.info(`Download block maps (old: \"${blockmapFileUrls[0]}\", new: ${blockmapFileUrls[1]})`);\n            const downloadBlockMap = async (url) => {\n                const data = await this.httpExecutor.downloadToBuffer(url, {\n                    headers: downloadUpdateOptions.requestHeaders,\n                    cancellationToken: downloadUpdateOptions.cancellationToken,\n                });\n                if (data == null || data.length === 0) {\n                    throw new Error(`Blockmap \"${url.href}\" is empty`);\n                }\n                try {\n                    return JSON.parse(zlib_1.gunzipSync(data).toString());\n                }\n                catch (e) {\n                    throw new Error(`Cannot parse blockmap \"${url.href}\", error: ${e}`);\n                }\n            };\n            const downloadOptions = {\n                newUrl: fileInfo.url,\n                oldFile: path.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME),\n                logger: this._logger,\n                newFile: installerPath,\n                isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n                requestHeaders: downloadUpdateOptions.requestHeaders,\n                cancellationToken: downloadUpdateOptions.cancellationToken,\n            };\n            if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {\n                downloadOptions.onProgress = it => this.emit(main_1.DOWNLOAD_PROGRESS, it);\n            }\n            const blockMapDataList = await Promise.all(blockmapFileUrls.map(u => downloadBlockMap(u)));\n            await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);\n            return false;\n        }\n        catch (e) {\n            this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);\n            if (this._testOnlyOptions != null) {\n                // test mode\n                throw e;\n            }\n            return true;\n        }\n    }\n    async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {\n        if (packageInfo.blockMapSize == null) {\n            return true;\n        }\n        try {\n            const downloadOptions = {\n                newUrl: new url_1.URL(packageInfo.path),\n                oldFile: path.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),\n                logger: this._logger,\n                newFile: packagePath,\n                requestHeaders: this.requestHeaders,\n                isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n                cancellationToken: downloadUpdateOptions.cancellationToken,\n            };\n            if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {\n                downloadOptions.onProgress = it => this.emit(main_1.DOWNLOAD_PROGRESS, it);\n            }\n            await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();\n        }\n        catch (e) {\n            this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);\n            // during test (developer machine mac or linux) we must throw error\n            return process.platform === \"win32\";\n        }\n        return false;\n    }\n}\nexports.NsisUpdater = NsisUpdater;\n/**\n * This handles both node 8 and node 10 way of emitting error when spawning a process\n *   - node 8: Throws the error\n *   - node 10: Emit the error(Need to listen with on)\n */\nasync function _spawn(exe, args) {\n    return new Promise((resolve, reject) => {\n        try {\n            const process = child_process_1.spawn(exe, args, {\n                detached: true,\n                stdio: \"ignore\",\n            });\n            process.on(\"error\", error => {\n                reject(error);\n            });\n            process.unref();\n            if (process.pid !== undefined) {\n                resolve(true);\n            }\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n//# sourceMappingURL=NsisUpdater.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataSplitter = exports.copyData = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst fs_1 = require(\"fs\");\nconst stream_1 = require(\"stream\");\nconst downloadPlanBuilder_1 = require(\"./downloadPlanBuilder\");\nconst DOUBLE_CRLF = Buffer.from(\"\\r\\n\\r\\n\");\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"INIT\"] = 0] = \"INIT\";\n    ReadState[ReadState[\"HEADER\"] = 1] = \"HEADER\";\n    ReadState[ReadState[\"BODY\"] = 2] = \"BODY\";\n})(ReadState || (ReadState = {}));\nfunction copyData(task, out, oldFileFd, reject, resolve) {\n    const readStream = fs_1.createReadStream(\"\", {\n        fd: oldFileFd,\n        autoClose: false,\n        start: task.start,\n        // end is inclusive\n        end: task.end - 1,\n    });\n    readStream.on(\"error\", reject);\n    readStream.once(\"end\", resolve);\n    readStream.pipe(out, {\n        end: false,\n    });\n}\nexports.copyData = copyData;\nclass DataSplitter extends stream_1.Writable {\n    constructor(out, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {\n        super();\n        this.out = out;\n        this.options = options;\n        this.partIndexToTaskIndex = partIndexToTaskIndex;\n        this.partIndexToLength = partIndexToLength;\n        this.finishHandler = finishHandler;\n        this.partIndex = -1;\n        this.headerListBuffer = null;\n        this.readState = ReadState.INIT;\n        this.ignoreByteCount = 0;\n        this.remainingPartDataCount = 0;\n        this.actualPartLength = 0;\n        this.boundaryLength = boundary.length + 4; /* size of \\r\\n-- */\n        // first chunk doesn't start with \\r\\n\n        this.ignoreByteCount = this.boundaryLength - 2;\n    }\n    get isFinished() {\n        return this.partIndex === this.partIndexToLength.length;\n    }\n    // noinspection JSUnusedGlobalSymbols\n    _write(data, encoding, callback) {\n        if (this.isFinished) {\n            console.error(`Trailing ignored data: ${data.length} bytes`);\n            return;\n        }\n        this.handleData(data).then(callback).catch(callback);\n    }\n    async handleData(chunk) {\n        let start = 0;\n        if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {\n            throw builder_util_runtime_1.newError(\"Internal error\", \"ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH\");\n        }\n        if (this.ignoreByteCount > 0) {\n            const toIgnore = Math.min(this.ignoreByteCount, chunk.length);\n            this.ignoreByteCount -= toIgnore;\n            start = toIgnore;\n        }\n        else if (this.remainingPartDataCount > 0) {\n            const toRead = Math.min(this.remainingPartDataCount, chunk.length);\n            this.remainingPartDataCount -= toRead;\n            await this.processPartData(chunk, 0, toRead);\n            start = toRead;\n        }\n        if (start === chunk.length) {\n            return;\n        }\n        if (this.readState === ReadState.HEADER) {\n            const headerListEnd = this.searchHeaderListEnd(chunk, start);\n            if (headerListEnd === -1) {\n                return;\n            }\n            start = headerListEnd;\n            this.readState = ReadState.BODY;\n            // header list is ignored, we don't need it\n            this.headerListBuffer = null;\n        }\n        while (true) {\n            if (this.readState === ReadState.BODY) {\n                this.readState = ReadState.INIT;\n            }\n            else {\n                this.partIndex++;\n                let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);\n                if (taskIndex == null) {\n                    if (this.isFinished) {\n                        taskIndex = this.options.end;\n                    }\n                    else {\n                        throw builder_util_runtime_1.newError(\"taskIndex is null\", \"ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL\");\n                    }\n                }\n                const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1; /* prev part is download, next maybe copy */\n                if (prevTaskIndex < taskIndex) {\n                    await this.copyExistingData(prevTaskIndex, taskIndex);\n                }\n                else if (prevTaskIndex > taskIndex) {\n                    throw builder_util_runtime_1.newError(\"prevTaskIndex must be < taskIndex\", \"ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED\");\n                }\n                if (this.isFinished) {\n                    this.onPartEnd();\n                    this.finishHandler();\n                    return;\n                }\n                start = this.searchHeaderListEnd(chunk, start);\n                if (start === -1) {\n                    this.readState = ReadState.HEADER;\n                    return;\n                }\n            }\n            const partLength = this.partIndexToLength[this.partIndex];\n            const end = start + partLength;\n            const effectiveEnd = Math.min(end, chunk.length);\n            await this.processPartStarted(chunk, start, effectiveEnd);\n            this.remainingPartDataCount = partLength - (effectiveEnd - start);\n            if (this.remainingPartDataCount > 0) {\n                return;\n            }\n            start = end + this.boundaryLength;\n            if (start >= chunk.length) {\n                this.ignoreByteCount = this.boundaryLength - (chunk.length - end);\n                return;\n            }\n        }\n    }\n    copyExistingData(index, end) {\n        return new Promise((resolve, reject) => {\n            const w = () => {\n                if (index === end) {\n                    resolve();\n                    return;\n                }\n                const task = this.options.tasks[index];\n                if (task.kind !== downloadPlanBuilder_1.OperationKind.COPY) {\n                    reject(new Error(\"Task kind must be COPY\"));\n                    return;\n                }\n                copyData(task, this.out, this.options.oldFileFd, reject, () => {\n                    index++;\n                    w();\n                });\n            };\n            w();\n        });\n    }\n    searchHeaderListEnd(chunk, readOffset) {\n        const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);\n        if (headerListEnd !== -1) {\n            return headerListEnd + DOUBLE_CRLF.length;\n        }\n        // not all headers data were received, save to buffer\n        const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);\n        if (this.headerListBuffer == null) {\n            this.headerListBuffer = partialChunk;\n        }\n        else {\n            this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);\n        }\n        return -1;\n    }\n    onPartEnd() {\n        const expectedLength = this.partIndexToLength[this.partIndex - 1];\n        if (this.actualPartLength !== expectedLength) {\n            throw builder_util_runtime_1.newError(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, \"ERR_DATA_SPLITTER_LENGTH_MISMATCH\");\n        }\n        this.actualPartLength = 0;\n    }\n    processPartStarted(data, start, end) {\n        if (this.partIndex !== 0) {\n            this.onPartEnd();\n        }\n        return this.processPartData(data, start, end);\n    }\n    processPartData(data, start, end) {\n        this.actualPartLength += end - start;\n        const out = this.out;\n        if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                out.on(\"error\", reject);\n                out.once(\"drain\", () => {\n                    out.removeListener(\"error\", reject);\n                    resolve();\n                });\n            });\n        }\n    }\n}\nexports.DataSplitter = DataSplitter;\n//# sourceMappingURL=DataSplitter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DifferentialDownloader = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst fs_1 = require(\"fs\");\nconst DataSplitter_1 = require(\"./DataSplitter\");\nconst url_1 = require(\"url\");\nconst downloadPlanBuilder_1 = require(\"./downloadPlanBuilder\");\nconst multipleRangeDownloader_1 = require(\"./multipleRangeDownloader\");\nconst ProgressDifferentialDownloadCallbackTransform_1 = require(\"./ProgressDifferentialDownloadCallbackTransform\");\nclass DifferentialDownloader {\n    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n    constructor(blockAwareFileInfo, httpExecutor, options) {\n        this.blockAwareFileInfo = blockAwareFileInfo;\n        this.httpExecutor = httpExecutor;\n        this.options = options;\n        this.fileMetadataBuffer = null;\n        this.logger = options.logger;\n    }\n    createRequestOptions() {\n        const result = {\n            headers: {\n                ...this.options.requestHeaders,\n                accept: \"*/*\",\n            },\n        };\n        builder_util_runtime_1.configureRequestUrl(this.options.newUrl, result);\n        // user-agent, cache-control and other common options\n        builder_util_runtime_1.configureRequestOptions(result);\n        return result;\n    }\n    doDownload(oldBlockMap, newBlockMap) {\n        // we don't check other metadata like compressionMethod - generic check that it is make sense to differentially update is suitable for it\n        if (oldBlockMap.version !== newBlockMap.version) {\n            throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);\n        }\n        const logger = this.logger;\n        const operations = downloadPlanBuilder_1.computeOperations(oldBlockMap, newBlockMap, logger);\n        if (logger.debug != null) {\n            logger.debug(JSON.stringify(operations, null, 2));\n        }\n        let downloadSize = 0;\n        let copySize = 0;\n        for (const operation of operations) {\n            const length = operation.end - operation.start;\n            if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {\n                downloadSize += length;\n            }\n            else {\n                copySize += length;\n            }\n        }\n        const newSize = this.blockAwareFileInfo.size;\n        if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {\n            throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);\n        }\n        logger.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);\n        return this.downloadFile(operations);\n    }\n    downloadFile(tasks) {\n        const fdList = [];\n        const closeFiles = () => {\n            return Promise.all(fdList.map(openedFile => {\n                return fs_extra_1.close(openedFile.descriptor).catch(e => {\n                    this.logger.error(`cannot close file \"${openedFile.path}\": ${e}`);\n                });\n            }));\n        };\n        return this.doDownloadFile(tasks, fdList)\n            .then(closeFiles)\n            .catch(e => {\n            // then must be after catch here (since then always throws error)\n            return closeFiles()\n                .catch(closeFilesError => {\n                // closeFiles never throw error, but just to be sure\n                try {\n                    this.logger.error(`cannot close files: ${closeFilesError}`);\n                }\n                catch (errorOnLog) {\n                    try {\n                        console.error(errorOnLog);\n                    }\n                    catch (ignored) {\n                        // ok, give up and ignore error\n                    }\n                }\n                throw e;\n            })\n                .then(() => {\n                throw e;\n            });\n        });\n    }\n    async doDownloadFile(tasks, fdList) {\n        const oldFileFd = await fs_extra_1.open(this.options.oldFile, \"r\");\n        fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });\n        const newFileFd = await fs_extra_1.open(this.options.newFile, \"w\");\n        fdList.push({ descriptor: newFileFd, path: this.options.newFile });\n        const fileOut = fs_1.createWriteStream(this.options.newFile, { fd: newFileFd });\n        await new Promise((resolve, reject) => {\n            const streams = [];\n            // Create our download info transformer if we have one\n            let downloadInfoTransform = undefined;\n            if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {\n                // TODO: Does not support multiple ranges (someone feel free to PR this!)\n                const expectedByteCounts = [];\n                let grandTotalBytes = 0;\n                for (const task of tasks) {\n                    if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {\n                        expectedByteCounts.push(task.end - task.start);\n                        grandTotalBytes += task.end - task.start;\n                    }\n                }\n                const progressDifferentialDownloadInfo = {\n                    expectedByteCounts: expectedByteCounts,\n                    grandTotal: grandTotalBytes,\n                };\n                downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);\n                streams.push(downloadInfoTransform);\n            }\n            const digestTransform = new builder_util_runtime_1.DigestTransform(this.blockAwareFileInfo.sha512);\n            // to simply debug, do manual validation to allow file to be fully written\n            digestTransform.isValidateOnEnd = false;\n            streams.push(digestTransform);\n            // noinspection JSArrowFunctionCanBeReplacedWithShorthand\n            fileOut.on(\"finish\", () => {\n                ;\n                fileOut.close(() => {\n                    // remove from fd list because closed successfully\n                    fdList.splice(1, 1);\n                    try {\n                        digestTransform.validate();\n                    }\n                    catch (e) {\n                        reject(e);\n                        return;\n                    }\n                    resolve(undefined);\n                });\n            });\n            streams.push(fileOut);\n            let lastStream = null;\n            for (const stream of streams) {\n                stream.on(\"error\", reject);\n                if (lastStream == null) {\n                    lastStream = stream;\n                }\n                else {\n                    lastStream = lastStream.pipe(stream);\n                }\n            }\n            const firstStream = streams[0];\n            let w;\n            if (this.options.isUseMultipleRangeRequest) {\n                w = multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests(this, tasks, firstStream, oldFileFd, reject);\n                w(0);\n                return;\n            }\n            let downloadOperationCount = 0;\n            let actualUrl = null;\n            this.logger.info(`Differential download: ${this.options.newUrl}`);\n            const requestOptions = this.createRequestOptions();\n            requestOptions.redirect = \"manual\";\n            w = (index) => {\n                var _a, _b;\n                if (index >= tasks.length) {\n                    if (this.fileMetadataBuffer != null) {\n                        firstStream.write(this.fileMetadataBuffer);\n                    }\n                    firstStream.end();\n                    return;\n                }\n                const operation = tasks[index++];\n                if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {\n                    // We are copying, let's not send status updates to the UI\n                    if (downloadInfoTransform) {\n                        downloadInfoTransform.beginFileCopy();\n                    }\n                    DataSplitter_1.copyData(operation, firstStream, oldFileFd, reject, () => w(index));\n                    return;\n                }\n                const range = `bytes=${operation.start}-${operation.end - 1}`;\n                requestOptions.headers.range = range;\n                (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `download range: ${range}`);\n                // We are starting to download\n                if (downloadInfoTransform) {\n                    downloadInfoTransform.beginRangeDownload();\n                }\n                const request = this.httpExecutor.createRequest(requestOptions, response => {\n                    // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.\n                    if (response.statusCode >= 400) {\n                        reject(builder_util_runtime_1.createHttpError(response));\n                    }\n                    response.pipe(firstStream, {\n                        end: false,\n                    });\n                    response.once(\"end\", () => {\n                        // Pass on that we are downloading a segment\n                        if (downloadInfoTransform) {\n                            downloadInfoTransform.endRangeDownload();\n                        }\n                        if (++downloadOperationCount === 100) {\n                            downloadOperationCount = 0;\n                            setTimeout(() => w(index), 1000);\n                        }\n                        else {\n                            w(index);\n                        }\n                    });\n                });\n                request.on(\"redirect\", (statusCode, method, redirectUrl) => {\n                    this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);\n                    actualUrl = redirectUrl;\n                    builder_util_runtime_1.configureRequestUrl(new url_1.URL(actualUrl), requestOptions);\n                    request.followRedirect();\n                });\n                this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);\n                request.end();\n            };\n            w(0);\n        });\n    }\n    async readRemoteBytes(start, endInclusive) {\n        const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);\n        const requestOptions = this.createRequestOptions();\n        requestOptions.headers.range = `bytes=${start}-${endInclusive}`;\n        let position = 0;\n        await this.request(requestOptions, chunk => {\n            chunk.copy(buffer, position);\n            position += chunk.length;\n        });\n        if (position !== buffer.length) {\n            throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`);\n        }\n        return buffer;\n    }\n    request(requestOptions, dataHandler) {\n        return new Promise((resolve, reject) => {\n            const request = this.httpExecutor.createRequest(requestOptions, response => {\n                if (!multipleRangeDownloader_1.checkIsRangesSupported(response, reject)) {\n                    return;\n                }\n                response.on(\"data\", dataHandler);\n                response.on(\"end\", () => resolve());\n            });\n            this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);\n            request.end();\n        });\n    }\n}\nexports.DifferentialDownloader = DifferentialDownloader;\nfunction formatBytes(value, symbol = \" KB\") {\n    return new Intl.NumberFormat(\"en\").format((value / 1024).toFixed(2)) + symbol;\n}\n// safety\nfunction removeQuery(url) {\n    const index = url.indexOf(\"?\");\n    return index < 0 ? url : url.substring(0, index);\n}\n//# sourceMappingURL=DifferentialDownloader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;\nconst fs_extra_1 = require(\"fs-extra\");\nconst DifferentialDownloader_1 = require(\"./DifferentialDownloader\");\nconst zlib_1 = require(\"zlib\");\nclass FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {\n    async download() {\n        const packageInfo = this.blockAwareFileInfo;\n        const fileSize = packageInfo.size;\n        const offset = fileSize - (packageInfo.blockMapSize + 4);\n        this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);\n        const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));\n        await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);\n    }\n}\nexports.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader;\nfunction readBlockMap(data) {\n    return JSON.parse(zlib_1.inflateRawSync(data).toString());\n}\nasync function readEmbeddedBlockMapData(file) {\n    const fd = await fs_extra_1.open(file, \"r\");\n    try {\n        const fileSize = (await fs_extra_1.fstat(fd)).size;\n        const sizeBuffer = Buffer.allocUnsafe(4);\n        await fs_extra_1.read(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);\n        const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));\n        await fs_extra_1.read(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);\n        await fs_extra_1.close(fd);\n        return readBlockMap(dataBuffer);\n    }\n    catch (e) {\n        await fs_extra_1.close(fd);\n        throw e;\n    }\n}\n//# sourceMappingURL=FileWithEmbeddedBlockMapDifferentialDownloader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GenericDifferentialDownloader = void 0;\nconst DifferentialDownloader_1 = require(\"./DifferentialDownloader\");\nclass GenericDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {\n    download(oldBlockMap, newBlockMap) {\n        return this.doDownload(oldBlockMap, newBlockMap);\n    }\n}\nexports.GenericDifferentialDownloader = GenericDifferentialDownloader;\n//# sourceMappingURL=GenericDifferentialDownloader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProgressDifferentialDownloadCallbackTransform = void 0;\nconst stream_1 = require(\"stream\");\nvar OperationKind;\n(function (OperationKind) {\n    OperationKind[OperationKind[\"COPY\"] = 0] = \"COPY\";\n    OperationKind[OperationKind[\"DOWNLOAD\"] = 1] = \"DOWNLOAD\";\n})(OperationKind || (OperationKind = {}));\nclass ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {\n    constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {\n        super();\n        this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;\n        this.cancellationToken = cancellationToken;\n        this.onProgress = onProgress;\n        this.start = Date.now();\n        this.transferred = 0;\n        this.delta = 0;\n        this.expectedBytes = 0;\n        this.index = 0;\n        this.operationType = OperationKind.COPY;\n        this.nextUpdate = this.start + 1000;\n    }\n    _transform(chunk, encoding, callback) {\n        if (this.cancellationToken.cancelled) {\n            callback(new Error(\"cancelled\"), null);\n            return;\n        }\n        // Don't send progress update when copying from disk\n        if (this.operationType == OperationKind.COPY) {\n            callback(null, chunk);\n            return;\n        }\n        this.transferred += chunk.length;\n        this.delta += chunk.length;\n        const now = Date.now();\n        if (now >= this.nextUpdate &&\n            this.transferred !== this.expectedBytes /* will be emitted by endRangeDownload() */ &&\n            this.transferred !== this.progressDifferentialDownloadInfo.grandTotal /* will be emitted on _flush */) {\n            this.nextUpdate = now + 1000;\n            this.onProgress({\n                total: this.progressDifferentialDownloadInfo.grandTotal,\n                delta: this.delta,\n                transferred: this.transferred,\n                percent: (this.transferred / this.progressDifferentialDownloadInfo.grandTotal) * 100,\n                bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1000)),\n            });\n            this.delta = 0;\n        }\n        callback(null, chunk);\n    }\n    beginFileCopy() {\n        this.operationType = OperationKind.COPY;\n    }\n    beginRangeDownload() {\n        this.operationType = OperationKind.DOWNLOAD;\n        this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];\n    }\n    endRangeDownload() {\n        // _flush() will doour final 100%\n        if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {\n            this.onProgress({\n                total: this.progressDifferentialDownloadInfo.grandTotal,\n                delta: this.delta,\n                transferred: this.transferred,\n                percent: (this.transferred / this.progressDifferentialDownloadInfo.grandTotal) * 100,\n                bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1000)),\n            });\n        }\n    }\n    // Called when we are 100% done with the connection/download\n    _flush(callback) {\n        if (this.cancellationToken.cancelled) {\n            callback(new Error(\"cancelled\"));\n            return;\n        }\n        this.onProgress({\n            total: this.progressDifferentialDownloadInfo.grandTotal,\n            delta: this.delta,\n            transferred: this.transferred,\n            percent: 100,\n            bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1000)),\n        });\n        this.delta = 0;\n        this.transferred = 0;\n        callback(null);\n    }\n}\nexports.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform;\n//# sourceMappingURL=ProgressDifferentialDownloadCallbackTransform.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeOperations = exports.OperationKind = void 0;\nvar OperationKind;\n(function (OperationKind) {\n    OperationKind[OperationKind[\"COPY\"] = 0] = \"COPY\";\n    OperationKind[OperationKind[\"DOWNLOAD\"] = 1] = \"DOWNLOAD\";\n})(OperationKind = exports.OperationKind || (exports.OperationKind = {}));\nfunction computeOperations(oldBlockMap, newBlockMap, logger) {\n    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);\n    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);\n    let lastOperation = null;\n    // for now only one file is supported in block map\n    const blockMapFile = newBlockMap.files[0];\n    const operations = [];\n    const name = blockMapFile.name;\n    const oldEntry = nameToOldBlocks.get(name);\n    if (oldEntry == null) {\n        // new file (unrealistic case for now, because in any case both blockmap contain the only file named as \"file\")\n        throw new Error(`no file ${name} in old blockmap`);\n    }\n    const newFile = nameToNewBlocks.get(name);\n    let changedBlockCount = 0;\n    const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);\n    let newOffset = blockMapFile.offset;\n    for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {\n        const blockSize = newFile.sizes[i];\n        const checksum = newFile.checksums[i];\n        let oldOffset = checksumToOldOffset.get(checksum);\n        if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {\n            logger.warn(`Checksum (\"${checksum}\") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);\n            oldOffset = undefined;\n        }\n        if (oldOffset === undefined) {\n            // download data from new file\n            changedBlockCount++;\n            if (lastOperation != null && lastOperation.kind === OperationKind.DOWNLOAD && lastOperation.end === newOffset) {\n                lastOperation.end += blockSize;\n            }\n            else {\n                lastOperation = {\n                    kind: OperationKind.DOWNLOAD,\n                    start: newOffset,\n                    end: newOffset + blockSize,\n                    // oldBlocks: null,\n                };\n                validateAndAdd(lastOperation, operations, checksum, i);\n            }\n        }\n        else {\n            // reuse data from old file\n            if (lastOperation != null && lastOperation.kind === OperationKind.COPY && lastOperation.end === oldOffset) {\n                lastOperation.end += blockSize;\n                // lastOperation.oldBlocks!!.push(checksum)\n            }\n            else {\n                lastOperation = {\n                    kind: OperationKind.COPY,\n                    start: oldOffset,\n                    end: oldOffset + blockSize,\n                    // oldBlocks: [checksum]\n                };\n                validateAndAdd(lastOperation, operations, checksum, i);\n            }\n        }\n    }\n    if (changedBlockCount > 0) {\n        logger.info(`File${blockMapFile.name === \"file\" ? \"\" : \" \" + blockMapFile.name} has ${changedBlockCount} changed blocks`);\n    }\n    return operations;\n}\nexports.computeOperations = computeOperations;\nconst isValidateOperationRange = process.env[\"DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES\"] === \"true\";\nfunction validateAndAdd(operation, operations, checksum, index) {\n    if (isValidateOperationRange && operations.length !== 0) {\n        const lastOperation = operations[operations.length - 1];\n        if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {\n            const min = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => (p < v ? p : v));\n            throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind[operation.kind]}) overlaps previous operation (checksum: ${checksum}):\\n` +\n                `abs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}\\n` +\n                `rel: ${lastOperation.start - min} until ${lastOperation.end - min} and ${operation.start - min} until ${operation.end - min}`);\n        }\n    }\n    operations.push(operation);\n}\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nfunction buildChecksumMap(file, fileOffset, logger) {\n    const checksumToOffset = new Map();\n    const checksumToSize = new Map();\n    let offset = fileOffset;\n    for (let i = 0; i < file.checksums.length; i++) {\n        const checksum = file.checksums[i];\n        const size = file.sizes[i];\n        const existing = checksumToSize.get(checksum);\n        if (existing === undefined) {\n            checksumToOffset.set(checksum, offset);\n            checksumToSize.set(checksum, size);\n        }\n        else if (logger.debug != null) {\n            const sizeExplanation = existing === size ? \"(same size)\" : `(size: ${existing}, this size: ${size})`;\n            logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);\n        }\n        offset += size;\n    }\n    return { checksumToOffset, checksumToOldSize: checksumToSize };\n}\nfunction buildBlockFileMap(list) {\n    const result = new Map();\n    for (const item of list) {\n        result.set(item.name, item);\n    }\n    return result;\n}\n//# sourceMappingURL=downloadPlanBuilder.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkIsRangesSupported = exports.executeTasksUsingMultipleRangeRequests = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst DataSplitter_1 = require(\"./DataSplitter\");\nconst downloadPlanBuilder_1 = require(\"./downloadPlanBuilder\");\nfunction executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out, oldFileFd, reject) {\n    const w = (taskOffset) => {\n        if (taskOffset >= tasks.length) {\n            if (differentialDownloader.fileMetadataBuffer != null) {\n                out.write(differentialDownloader.fileMetadataBuffer);\n            }\n            out.end();\n            return;\n        }\n        const nextOffset = taskOffset + 1000;\n        doExecuteTasks(differentialDownloader, {\n            tasks,\n            start: taskOffset,\n            end: Math.min(tasks.length, nextOffset),\n            oldFileFd,\n        }, out, () => w(nextOffset), reject);\n    };\n    return w;\n}\nexports.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;\nfunction doExecuteTasks(differentialDownloader, options, out, resolve, reject) {\n    let ranges = \"bytes=\";\n    let partCount = 0;\n    const partIndexToTaskIndex = new Map();\n    const partIndexToLength = [];\n    for (let i = options.start; i < options.end; i++) {\n        const task = options.tasks[i];\n        if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {\n            ranges += `${task.start}-${task.end - 1}, `;\n            partIndexToTaskIndex.set(partCount, i);\n            partCount++;\n            partIndexToLength.push(task.end - task.start);\n        }\n    }\n    if (partCount <= 1) {\n        // the only remote range - copy\n        const w = (index) => {\n            if (index >= options.end) {\n                resolve();\n                return;\n            }\n            const task = options.tasks[index++];\n            if (task.kind === downloadPlanBuilder_1.OperationKind.COPY) {\n                DataSplitter_1.copyData(task, out, options.oldFileFd, reject, () => w(index));\n            }\n            else {\n                const requestOptions = differentialDownloader.createRequestOptions();\n                requestOptions.headers.Range = `bytes=${task.start}-${task.end - 1}`;\n                const request = differentialDownloader.httpExecutor.createRequest(requestOptions, response => {\n                    if (!checkIsRangesSupported(response, reject)) {\n                        return;\n                    }\n                    response.pipe(out, {\n                        end: false,\n                    });\n                    response.once(\"end\", () => w(index));\n                });\n                differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);\n                request.end();\n            }\n        };\n        w(options.start);\n        return;\n    }\n    const requestOptions = differentialDownloader.createRequestOptions();\n    requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);\n    const request = differentialDownloader.httpExecutor.createRequest(requestOptions, response => {\n        if (!checkIsRangesSupported(response, reject)) {\n            return;\n        }\n        const contentType = builder_util_runtime_1.safeGetHeader(response, \"content-type\");\n        const m = /^multipart\\/.+?(?:; boundary=(?:(?:\"(.+)\")|(?:([^\\s]+))))$/i.exec(contentType);\n        if (m == null) {\n            reject(new Error(`Content-Type \"multipart/byteranges\" is expected, but got \"${contentType}\"`));\n            return;\n        }\n        const dicer = new DataSplitter_1.DataSplitter(out, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);\n        dicer.on(\"error\", reject);\n        response.pipe(dicer);\n        response.on(\"end\", () => {\n            setTimeout(() => {\n                request.abort();\n                reject(new Error(\"Response ends without calling any handlers\"));\n            }, 10000);\n        });\n    });\n    differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);\n    request.end();\n}\nfunction checkIsRangesSupported(response, reject) {\n    // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.\n    if (response.statusCode >= 400) {\n        reject(builder_util_runtime_1.createHttpError(response));\n        return false;\n    }\n    if (response.statusCode !== 206) {\n        const acceptRanges = builder_util_runtime_1.safeGetHeader(response, \"accept-ranges\");\n        if (acceptRanges == null || acceptRanges === \"none\") {\n            reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`));\n            return false;\n        }\n    }\n    return true;\n}\nexports.checkIsRangesSupported = checkIsRangesSupported;\n//# sourceMappingURL=multipleRangeDownloader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ElectronHttpExecutor = exports.getNetSession = exports.NET_SESSION_NAME = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nexports.NET_SESSION_NAME = \"electron-updater\";\nfunction getNetSession() {\n    return require(\"electron\").session.fromPartition(exports.NET_SESSION_NAME, {\n        cache: false,\n    });\n}\nexports.getNetSession = getNetSession;\nclass ElectronHttpExecutor extends builder_util_runtime_1.HttpExecutor {\n    constructor(proxyLoginCallback) {\n        super();\n        this.proxyLoginCallback = proxyLoginCallback;\n        this.cachedSession = null;\n    }\n    async download(url, destination, options) {\n        return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {\n            const requestOptions = {\n                headers: options.headers || undefined,\n                redirect: \"manual\",\n            };\n            builder_util_runtime_1.configureRequestUrl(url, requestOptions);\n            builder_util_runtime_1.configureRequestOptions(requestOptions);\n            this.doDownload(requestOptions, {\n                destination,\n                options,\n                onCancel,\n                callback: error => {\n                    if (error == null) {\n                        resolve(destination);\n                    }\n                    else {\n                        reject(error);\n                    }\n                },\n                responseHandler: null,\n            }, 0);\n        });\n    }\n    createRequest(options, callback) {\n        // fix (node 7+) for making electron updater work when using AWS private buckets, check if headers contain Host property\n        if (options.headers && options.headers.Host) {\n            // set host value from headers.Host\n            options.host = options.headers.Host;\n            // remove header property 'Host', if not removed causes net::ERR_INVALID_ARGUMENT exception\n            delete options.headers.Host;\n        }\n        // differential downloader can call this method very often, so, better to cache session\n        if (this.cachedSession == null) {\n            this.cachedSession = getNetSession();\n        }\n        const request = require(\"electron\").net.request({\n            ...options,\n            session: this.cachedSession,\n        });\n        request.on(\"response\", callback);\n        if (this.proxyLoginCallback != null) {\n            request.on(\"login\", this.proxyLoginCallback);\n        }\n        return request;\n    }\n    addRedirectHandlers(request, options, reject, redirectCount, handler) {\n        request.on(\"redirect\", (statusCode, method, redirectUrl) => {\n            // no way to modify request options, abort old and make a new one\n            // https://github.com/electron/electron/issues/11505\n            request.abort();\n            if (redirectCount > this.maxRedirects) {\n                reject(this.createMaxRedirectError());\n            }\n            else {\n                handler(builder_util_runtime_1.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));\n            }\n        });\n    }\n}\nexports.ElectronHttpExecutor = ElectronHttpExecutor;\n//# sourceMappingURL=electronHttpExecutor.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.NsisUpdater = exports.MacUpdater = exports.AppImageUpdater = exports.Provider = exports.CancellationToken = exports.NoOpLogger = exports.AppUpdater = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nObject.defineProperty(exports, \"CancellationToken\", { enumerable: true, get: function () { return builder_util_runtime_1.CancellationToken; } });\nvar AppUpdater_1 = require(\"./AppUpdater\");\nObject.defineProperty(exports, \"AppUpdater\", { enumerable: true, get: function () { return AppUpdater_1.AppUpdater; } });\nObject.defineProperty(exports, \"NoOpLogger\", { enumerable: true, get: function () { return AppUpdater_1.NoOpLogger; } });\nvar Provider_1 = require(\"./providers/Provider\");\nObject.defineProperty(exports, \"Provider\", { enumerable: true, get: function () { return Provider_1.Provider; } });\nvar AppImageUpdater_1 = require(\"./AppImageUpdater\");\nObject.defineProperty(exports, \"AppImageUpdater\", { enumerable: true, get: function () { return AppImageUpdater_1.AppImageUpdater; } });\nvar MacUpdater_1 = require(\"./MacUpdater\");\nObject.defineProperty(exports, \"MacUpdater\", { enumerable: true, get: function () { return MacUpdater_1.MacUpdater; } });\nvar NsisUpdater_1 = require(\"./NsisUpdater\");\nObject.defineProperty(exports, \"NsisUpdater\", { enumerable: true, get: function () { return NsisUpdater_1.NsisUpdater; } });\n// autoUpdater to mimic electron bundled autoUpdater\nlet _autoUpdater;\nfunction doLoadAutoUpdater() {\n    // tslint:disable:prefer-conditional-expression\n    if (process.platform === \"win32\") {\n        _autoUpdater = new (require(\"./NsisUpdater\").NsisUpdater)();\n    }\n    else if (process.platform === \"darwin\") {\n        _autoUpdater = new (require(\"./MacUpdater\").MacUpdater)();\n    }\n    else {\n        _autoUpdater = new (require(\"./AppImageUpdater\").AppImageUpdater)();\n    }\n    return _autoUpdater;\n}\nObject.defineProperty(exports, \"autoUpdater\", {\n    enumerable: true,\n    get: () => {\n        return _autoUpdater || doLoadAutoUpdater();\n    },\n});\nexports.DOWNLOAD_PROGRESS = \"download-progress\";\nexports.UPDATE_DOWNLOADED = \"update-downloaded\";\nclass UpdaterSignal {\n    constructor(emitter) {\n        this.emitter = emitter;\n    }\n    /**\n     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).\n     */\n    login(handler) {\n        addHandler(this.emitter, \"login\", handler);\n    }\n    progress(handler) {\n        addHandler(this.emitter, exports.DOWNLOAD_PROGRESS, handler);\n    }\n    updateDownloaded(handler) {\n        addHandler(this.emitter, exports.UPDATE_DOWNLOADED, handler);\n    }\n    updateCancelled(handler) {\n        addHandler(this.emitter, \"update-cancelled\", handler);\n    }\n}\nexports.UpdaterSignal = UpdaterSignal;\nconst isLogEvent = false;\nfunction addHandler(emitter, event, handler) {\n    if (isLogEvent) {\n        emitter.on(event, (...args) => {\n            console.log(\"%s %s\", event, args);\n            handler(...args);\n        });\n    }\n    else {\n        emitter.on(event, handler);\n    }\n}\n//# sourceMappingURL=main.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createClient = exports.isUrlProbablySupportMultiRangeRequests = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst BintrayProvider_1 = require(\"./providers/BintrayProvider\");\nconst BitbucketProvider_1 = require(\"./providers/BitbucketProvider\");\nconst GenericProvider_1 = require(\"./providers/GenericProvider\");\nconst GitHubProvider_1 = require(\"./providers/GitHubProvider\");\nconst KeygenProvider_1 = require(\"./providers/KeygenProvider\");\nconst PrivateGitHubProvider_1 = require(\"./providers/PrivateGitHubProvider\");\nfunction isUrlProbablySupportMultiRangeRequests(url) {\n    return !url.includes(\"s3.amazonaws.com\");\n}\nexports.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;\nfunction createClient(data, updater, runtimeOptions) {\n    // noinspection SuspiciousTypeOfGuard\n    if (typeof data === \"string\") {\n        throw builder_util_runtime_1.newError(\"Please pass PublishConfiguration object\", \"ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION\");\n    }\n    const provider = data.provider;\n    switch (provider) {\n        case \"github\": {\n            const githubOptions = data;\n            const token = (githubOptions.private ? process.env[\"GH_TOKEN\"] || process.env[\"GITHUB_TOKEN\"] : null) || githubOptions.token;\n            if (token == null) {\n                return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);\n            }\n            else {\n                return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);\n            }\n        }\n        case \"bitbucket\":\n            return new BitbucketProvider_1.BitbucketProvider(data, updater, runtimeOptions);\n        case \"keygen\":\n            return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);\n        case \"s3\":\n        case \"spaces\":\n            return new GenericProvider_1.GenericProvider({\n                provider: \"generic\",\n                url: builder_util_runtime_1.getS3LikeProviderBaseUrl(data),\n                channel: data.channel || null,\n            }, updater, {\n                ...runtimeOptions,\n                // https://github.com/minio/minio/issues/5285#issuecomment-350428955\n                isUseMultipleRangeRequest: false,\n            });\n        case \"generic\": {\n            const options = data;\n            return new GenericProvider_1.GenericProvider(options, updater, {\n                ...runtimeOptions,\n                isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url),\n            });\n        }\n        case \"bintray\":\n            return new BintrayProvider_1.BintrayProvider(data, runtimeOptions);\n        case \"custom\": {\n            const options = data;\n            const constructor = options.updateProvider;\n            if (!constructor) {\n                throw builder_util_runtime_1.newError(\"Custom provider not specified\", \"ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION\");\n            }\n            return new constructor(options, updater, runtimeOptions);\n        }\n        default:\n            throw builder_util_runtime_1.newError(`Unsupported provider: ${provider}`, \"ERR_UPDATER_UNSUPPORTED_PROVIDER\");\n    }\n}\nexports.createClient = createClient;\n//# sourceMappingURL=providerFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BintrayProvider = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst bintray_1 = require(\"builder-util-runtime/out/bintray\");\nconst url_1 = require(\"url\");\nconst util_1 = require(\"../util\");\nconst Provider_1 = require(\"./Provider\");\nclass BintrayProvider extends Provider_1.Provider {\n    constructor(configuration, runtimeOptions) {\n        super(runtimeOptions);\n        this.client = new bintray_1.BintrayClient(configuration, runtimeOptions.executor, new builder_util_runtime_1.CancellationToken());\n        this.baseUrl = util_1.newBaseUrl(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}`);\n    }\n    setRequestHeaders(value) {\n        super.setRequestHeaders(value);\n        this.client.setRequestHeaders(value);\n    }\n    async getLatestVersion() {\n        try {\n            const data = await this.client.getVersion(\"_latest\");\n            const channelFilename = util_1.getChannelFilename(this.getDefaultChannelName());\n            const files = await this.client.getVersionFiles(data.name);\n            const channelFile = files.find(it => it.name.endsWith(`_${channelFilename}`) || it.name.endsWith(`-${channelFilename}`));\n            if (channelFile == null) {\n                // noinspection ExceptionCaughtLocallyJS\n                throw builder_util_runtime_1.newError(`Cannot find channel file \"${channelFilename}\", existing files:\\n${files.map(it => JSON.stringify(it, null, 2)).join(\",\\n\")}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n            }\n            const channelFileUrl = new url_1.URL(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}/${channelFile.name}`);\n            return Provider_1.parseUpdateInfo(await this.httpRequest(channelFileUrl), channelFilename, channelFileUrl);\n        }\n        catch (e) {\n            if (\"statusCode\" in e && e.statusCode === 404) {\n                throw builder_util_runtime_1.newError(`No latest version, please ensure that user, package and repository correctly configured. Or at least one version is published. ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n            }\n            throw e;\n        }\n    }\n    resolveFiles(updateInfo) {\n        return Provider_1.resolveFiles(updateInfo, this.baseUrl);\n    }\n}\nexports.BintrayProvider = BintrayProvider;\n//# sourceMappingURL=BintrayProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitbucketProvider = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst util_1 = require(\"../util\");\nconst Provider_1 = require(\"./Provider\");\nclass BitbucketProvider extends Provider_1.Provider {\n    constructor(configuration, updater, runtimeOptions) {\n        super({\n            ...runtimeOptions,\n            isUseMultipleRangeRequest: false,\n        });\n        this.configuration = configuration;\n        this.updater = updater;\n        const { owner, slug } = configuration;\n        this.baseUrl = util_1.newBaseUrl(`https://api.bitbucket.org/2.0/repositories/${owner}/${slug}/downloads`);\n    }\n    get channel() {\n        return this.updater.channel || this.configuration.channel || \"latest\";\n    }\n    async getLatestVersion() {\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        const channelFile = util_1.getChannelFilename(this.getCustomChannelName(this.channel));\n        const channelUrl = util_1.newUrlFromBase(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);\n        try {\n            const updateInfo = await this.httpRequest(channelUrl, undefined, cancellationToken);\n            return Provider_1.parseUpdateInfo(updateInfo, channelFile, channelUrl);\n        }\n        catch (e) {\n            throw builder_util_runtime_1.newError(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n        }\n    }\n    resolveFiles(updateInfo) {\n        return Provider_1.resolveFiles(updateInfo, this.baseUrl);\n    }\n    toString() {\n        const { owner, slug } = this.configuration;\n        return `Bitbucket (owner: ${owner}, slug: ${slug}, channel: ${this.channel})`;\n    }\n}\nexports.BitbucketProvider = BitbucketProvider;\n//# sourceMappingURL=BitbucketProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GenericProvider = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst util_1 = require(\"../util\");\nconst Provider_1 = require(\"./Provider\");\nclass GenericProvider extends Provider_1.Provider {\n    constructor(configuration, updater, runtimeOptions) {\n        super(runtimeOptions);\n        this.configuration = configuration;\n        this.updater = updater;\n        this.baseUrl = util_1.newBaseUrl(this.configuration.url);\n    }\n    get channel() {\n        const result = this.updater.channel || this.configuration.channel;\n        return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);\n    }\n    async getLatestVersion() {\n        const channelFile = util_1.getChannelFilename(this.channel);\n        const channelUrl = util_1.newUrlFromBase(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);\n        for (let attemptNumber = 0;; attemptNumber++) {\n            try {\n                return Provider_1.parseUpdateInfo(await this.httpRequest(channelUrl), channelFile, channelUrl);\n            }\n            catch (e) {\n                if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {\n                    throw builder_util_runtime_1.newError(`Cannot find channel \"${channelFile}\" update info: ${e.stack || e.message}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n                }\n                else if (e.code === \"ECONNREFUSED\") {\n                    if (attemptNumber < 3) {\n                        await new Promise((resolve, reject) => {\n                            try {\n                                setTimeout(resolve, 1000 * attemptNumber);\n                            }\n                            catch (e) {\n                                reject(e);\n                            }\n                        });\n                        continue;\n                    }\n                }\n                throw e;\n            }\n        }\n    }\n    resolveFiles(updateInfo) {\n        return Provider_1.resolveFiles(updateInfo, this.baseUrl);\n    }\n}\nexports.GenericProvider = GenericProvider;\n//# sourceMappingURL=GenericProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeReleaseNotes = exports.GitHubProvider = exports.BaseGitHubProvider = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst semver = require(\"semver\");\nconst url_1 = require(\"url\");\nconst util_1 = require(\"../util\");\nconst Provider_1 = require(\"./Provider\");\nconst hrefRegExp = /\\/tag\\/([^/]+)$/;\nclass BaseGitHubProvider extends Provider_1.Provider {\n    constructor(options, defaultHost, runtimeOptions) {\n        super({\n            ...runtimeOptions,\n            /* because GitHib uses S3 */\n            isUseMultipleRangeRequest: false,\n        });\n        this.options = options;\n        this.baseUrl = util_1.newBaseUrl(builder_util_runtime_1.githubUrl(options, defaultHost));\n        const apiHost = defaultHost === \"github.com\" ? \"api.github.com\" : defaultHost;\n        this.baseApiUrl = util_1.newBaseUrl(builder_util_runtime_1.githubUrl(options, apiHost));\n    }\n    computeGithubBasePath(result) {\n        // https://github.com/electron-userland/electron-builder/issues/1903#issuecomment-320881211\n        const host = this.options.host;\n        return host != null && host !== \"github.com\" && host !== \"api.github.com\" ? `/api/v3${result}` : result;\n    }\n}\nexports.BaseGitHubProvider = BaseGitHubProvider;\nclass GitHubProvider extends BaseGitHubProvider {\n    constructor(options, updater, runtimeOptions) {\n        super(options, \"github.com\", runtimeOptions);\n        this.options = options;\n        this.updater = updater;\n    }\n    async getLatestVersion() {\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        const feedXml = (await this.httpRequest(util_1.newUrlFromBase(`${this.basePath}.atom`, this.baseUrl), {\n            accept: \"application/xml, application/atom+xml, text/xml, */*\",\n        }, cancellationToken));\n        const feed = builder_util_runtime_1.parseXml(feedXml);\n        // noinspection TypeScriptValidateJSTypes\n        let latestRelease = feed.element(\"entry\", false, `No published versions on GitHub`);\n        let tag;\n        try {\n            if (this.updater.allowPrerelease) {\n                // noinspection TypeScriptValidateJSTypes\n                tag = hrefRegExp.exec(latestRelease.element(\"link\").attribute(\"href\"))[1];\n            }\n            else {\n                tag = await this.getLatestTagName(cancellationToken);\n                for (const element of feed.getElements(\"entry\")) {\n                    // noinspection TypeScriptValidateJSTypes\n                    if (hrefRegExp.exec(element.element(\"link\").attribute(\"href\"))[1] === tag) {\n                        latestRelease = element;\n                        break;\n                    }\n                }\n            }\n        }\n        catch (e) {\n            throw builder_util_runtime_1.newError(`Cannot parse releases feed: ${e.stack || e.message},\\nXML:\\n${feedXml}`, \"ERR_UPDATER_INVALID_RELEASE_FEED\");\n        }\n        if (tag == null) {\n            throw builder_util_runtime_1.newError(`No published versions on GitHub`, \"ERR_UPDATER_NO_PUBLISHED_VERSIONS\");\n        }\n        const channelFile = util_1.getChannelFilename(this.getDefaultChannelName());\n        const channelFileUrl = util_1.newUrlFromBase(this.getBaseDownloadPath(tag, channelFile), this.baseUrl);\n        const requestOptions = this.createRequestOptions(channelFileUrl);\n        let rawData;\n        try {\n            rawData = (await this.executor.request(requestOptions, cancellationToken));\n        }\n        catch (e) {\n            if (!this.updater.allowPrerelease && e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {\n                throw builder_util_runtime_1.newError(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n            }\n            throw e;\n        }\n        const result = Provider_1.parseUpdateInfo(rawData, channelFile, channelFileUrl);\n        if (result.releaseName == null) {\n            result.releaseName = latestRelease.elementValueOrEmpty(\"title\");\n        }\n        if (result.releaseNotes == null) {\n            result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);\n        }\n        return {\n            tag: tag,\n            ...result,\n        };\n    }\n    async getLatestTagName(cancellationToken) {\n        const options = this.options;\n        // do not use API for GitHub to avoid limit, only for custom host or GitHub Enterprise\n        const url = options.host == null || options.host === \"github.com\"\n            ? util_1.newUrlFromBase(`${this.basePath}/latest`, this.baseUrl)\n            : new url_1.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);\n        try {\n            const rawData = await this.httpRequest(url, { Accept: \"application/json\" }, cancellationToken);\n            if (rawData == null) {\n                return null;\n            }\n            const releaseInfo = JSON.parse(rawData);\n            return releaseInfo.tag_name;\n        }\n        catch (e) {\n            throw builder_util_runtime_1.newError(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n        }\n    }\n    get basePath() {\n        return `/${this.options.owner}/${this.options.repo}/releases`;\n    }\n    resolveFiles(updateInfo) {\n        // still replace space to - due to backward compatibility\n        return Provider_1.resolveFiles(updateInfo, this.baseUrl, p => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, \"-\")));\n    }\n    getBaseDownloadPath(tag, fileName) {\n        return `${this.basePath}/download/${tag}/${fileName}`;\n    }\n}\nexports.GitHubProvider = GitHubProvider;\nfunction getNoteValue(parent) {\n    const result = parent.elementValueOrEmpty(\"content\");\n    // GitHub reports empty notes as <content>No content.</content>\n    return result === \"No content.\" ? \"\" : result;\n}\nfunction computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {\n    if (!isFullChangelog) {\n        return getNoteValue(latestRelease);\n    }\n    const releaseNotes = [];\n    for (const release of feed.getElements(\"entry\")) {\n        // noinspection TypeScriptValidateJSTypes\n        const versionRelease = /\\/tag\\/v?([^/]+)$/.exec(release.element(\"link\").attribute(\"href\"))[1];\n        if (semver.lt(currentVersion, versionRelease)) {\n            releaseNotes.push({\n                version: versionRelease,\n                note: getNoteValue(release),\n            });\n        }\n    }\n    return releaseNotes.sort((a, b) => semver.rcompare(a.version, b.version));\n}\nexports.computeReleaseNotes = computeReleaseNotes;\n//# sourceMappingURL=GitHubProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeygenProvider = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst util_1 = require(\"../util\");\nconst Provider_1 = require(\"./Provider\");\nclass KeygenProvider extends Provider_1.Provider {\n    constructor(configuration, updater, runtimeOptions) {\n        super({\n            ...runtimeOptions,\n            isUseMultipleRangeRequest: false,\n        });\n        this.configuration = configuration;\n        this.updater = updater;\n        this.baseUrl = util_1.newBaseUrl(`https://api.keygen.sh/v1/accounts/${this.configuration.account}/artifacts`);\n    }\n    get channel() {\n        return this.updater.channel || this.configuration.channel || \"stable\";\n    }\n    async getLatestVersion() {\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        const channelFile = util_1.getChannelFilename(this.getCustomChannelName(this.channel));\n        const channelUrl = util_1.newUrlFromBase(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);\n        try {\n            const updateInfo = await this.httpRequest(channelUrl, {\n                Accept: \"application/vnd.api+json\",\n            }, cancellationToken);\n            return Provider_1.parseUpdateInfo(updateInfo, channelFile, channelUrl);\n        }\n        catch (e) {\n            throw builder_util_runtime_1.newError(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n        }\n    }\n    resolveFiles(updateInfo) {\n        return Provider_1.resolveFiles(updateInfo, this.baseUrl);\n    }\n    toString() {\n        const { account, product, platform } = this.configuration;\n        return `Keygen (account: ${account}, product: ${product}, platform: ${platform}, channel: ${this.channel})`;\n    }\n}\nexports.KeygenProvider = KeygenProvider;\n//# sourceMappingURL=KeygenProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PrivateGitHubProvider = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst js_yaml_1 = require(\"js-yaml\");\nconst path = require(\"path\");\nconst url_1 = require(\"url\");\nconst util_1 = require(\"../util\");\nconst GitHubProvider_1 = require(\"./GitHubProvider\");\nconst Provider_1 = require(\"./Provider\");\nclass PrivateGitHubProvider extends GitHubProvider_1.BaseGitHubProvider {\n    constructor(options, updater, token, runtimeOptions) {\n        super(options, \"api.github.com\", runtimeOptions);\n        this.updater = updater;\n        this.token = token;\n    }\n    createRequestOptions(url, headers) {\n        const result = super.createRequestOptions(url, headers);\n        result.redirect = \"manual\";\n        return result;\n    }\n    async getLatestVersion() {\n        const cancellationToken = new builder_util_runtime_1.CancellationToken();\n        const channelFile = util_1.getChannelFilename(this.getDefaultChannelName());\n        const releaseInfo = await this.getLatestVersionInfo(cancellationToken);\n        const asset = releaseInfo.assets.find(it => it.name === channelFile);\n        if (asset == null) {\n            // html_url must be always, but just to be sure\n            throw builder_util_runtime_1.newError(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n        }\n        const url = new url_1.URL(asset.url);\n        let result;\n        try {\n            result = js_yaml_1.load((await this.httpRequest(url, this.configureHeaders(\"application/octet-stream\"), cancellationToken)));\n        }\n        catch (e) {\n            if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {\n                throw builder_util_runtime_1.newError(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, \"ERR_UPDATER_CHANNEL_FILE_NOT_FOUND\");\n            }\n            throw e;\n        }\n        ;\n        result.assets = releaseInfo.assets;\n        return result;\n    }\n    get fileExtraDownloadHeaders() {\n        return this.configureHeaders(\"application/octet-stream\");\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n    configureHeaders(accept) {\n        return {\n            accept,\n            authorization: `token ${this.token}`,\n        };\n    }\n    async getLatestVersionInfo(cancellationToken) {\n        const allowPrerelease = this.updater.allowPrerelease;\n        let basePath = this.basePath;\n        if (!allowPrerelease) {\n            basePath = `${basePath}/latest`;\n        }\n        const url = util_1.newUrlFromBase(basePath, this.baseUrl);\n        try {\n            const version = JSON.parse((await this.httpRequest(url, this.configureHeaders(\"application/vnd.github.v3+json\"), cancellationToken)));\n            if (allowPrerelease) {\n                return version.find(it => it.prerelease) || version[0];\n            }\n            else {\n                return version;\n            }\n        }\n        catch (e) {\n            throw builder_util_runtime_1.newError(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, \"ERR_UPDATER_LATEST_VERSION_NOT_FOUND\");\n        }\n    }\n    get basePath() {\n        return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);\n    }\n    resolveFiles(updateInfo) {\n        return Provider_1.getFileList(updateInfo).map(it => {\n            const name = path.posix.basename(it.url).replace(/ /g, \"-\");\n            const asset = updateInfo.assets.find(it => it != null && it.name === name);\n            if (asset == null) {\n                throw builder_util_runtime_1.newError(`Cannot find asset \"${name}\" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, \"ERR_UPDATER_ASSET_NOT_FOUND\");\n            }\n            return {\n                url: new url_1.URL(asset.url),\n                info: it,\n            };\n        });\n    }\n}\nexports.PrivateGitHubProvider = PrivateGitHubProvider;\n//# sourceMappingURL=PrivateGitHubProvider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveFiles = exports.getFileList = exports.parseUpdateInfo = exports.findFile = exports.Provider = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst js_yaml_1 = require(\"js-yaml\");\nconst util_1 = require(\"../util\");\nclass Provider {\n    constructor(runtimeOptions) {\n        this.runtimeOptions = runtimeOptions;\n        this.requestHeaders = null;\n        this.executor = runtimeOptions.executor;\n    }\n    get isUseMultipleRangeRequest() {\n        return this.runtimeOptions.isUseMultipleRangeRequest !== false;\n    }\n    getChannelFilePrefix() {\n        if (this.runtimeOptions.platform === \"linux\") {\n            const arch = process.env[\"TEST_UPDATER_ARCH\"] || process.arch;\n            const archSuffix = arch === \"x64\" ? \"\" : `-${arch}`;\n            return \"-linux\" + archSuffix;\n        }\n        else {\n            return this.runtimeOptions.platform === \"darwin\" ? \"-mac\" : \"\";\n        }\n    }\n    // due to historical reasons for windows we use channel name without platform specifier\n    getDefaultChannelName() {\n        return this.getCustomChannelName(\"latest\");\n    }\n    getCustomChannelName(channel) {\n        return `${channel}${this.getChannelFilePrefix()}`;\n    }\n    get fileExtraDownloadHeaders() {\n        return null;\n    }\n    setRequestHeaders(value) {\n        this.requestHeaders = value;\n    }\n    /**\n     * Method to perform API request only to resolve update info, but not to download update.\n     */\n    httpRequest(url, headers, cancellationToken) {\n        return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);\n    }\n    createRequestOptions(url, headers) {\n        const result = {};\n        if (this.requestHeaders == null) {\n            if (headers != null) {\n                result.headers = headers;\n            }\n        }\n        else {\n            result.headers = headers == null ? this.requestHeaders : { ...this.requestHeaders, ...headers };\n        }\n        builder_util_runtime_1.configureRequestUrl(url, result);\n        return result;\n    }\n}\nexports.Provider = Provider;\nfunction findFile(files, extension, not) {\n    if (files.length === 0) {\n        throw builder_util_runtime_1.newError(\"No files provided\", \"ERR_UPDATER_NO_FILES_PROVIDED\");\n    }\n    const result = files.find(it => it.url.pathname.toLowerCase().endsWith(`.${extension}`));\n    if (result != null) {\n        return result;\n    }\n    else if (not == null) {\n        return files[0];\n    }\n    else {\n        return files.find(fileInfo => !not.some(ext => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));\n    }\n}\nexports.findFile = findFile;\nfunction parseUpdateInfo(rawData, channelFile, channelFileUrl) {\n    if (rawData == null) {\n        throw builder_util_runtime_1.newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, \"ERR_UPDATER_INVALID_UPDATE_INFO\");\n    }\n    let result;\n    try {\n        result = js_yaml_1.load(rawData);\n    }\n    catch (e) {\n        throw builder_util_runtime_1.newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, \"ERR_UPDATER_INVALID_UPDATE_INFO\");\n    }\n    return result;\n}\nexports.parseUpdateInfo = parseUpdateInfo;\nfunction getFileList(updateInfo) {\n    const files = updateInfo.files;\n    if (files != null && files.length > 0) {\n        return files;\n    }\n    // noinspection JSDeprecatedSymbols\n    if (updateInfo.path != null) {\n        // noinspection JSDeprecatedSymbols\n        return [\n            {\n                url: updateInfo.path,\n                sha2: updateInfo.sha2,\n                sha512: updateInfo.sha512,\n            },\n        ];\n    }\n    else {\n        throw builder_util_runtime_1.newError(`No files provided: ${builder_util_runtime_1.safeStringifyJson(updateInfo)}`, \"ERR_UPDATER_NO_FILES_PROVIDED\");\n    }\n}\nexports.getFileList = getFileList;\nfunction resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {\n    const files = getFileList(updateInfo);\n    const result = files.map(fileInfo => {\n        if (fileInfo.sha2 == null && fileInfo.sha512 == null) {\n            throw builder_util_runtime_1.newError(`Update info doesn't contain nor sha256 neither sha512 checksum: ${builder_util_runtime_1.safeStringifyJson(fileInfo)}`, \"ERR_UPDATER_NO_CHECKSUM\");\n        }\n        return {\n            url: util_1.newUrlFromBase(pathTransformer(fileInfo.url), baseUrl),\n            info: fileInfo,\n        };\n    });\n    const packages = updateInfo.packages;\n    const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;\n    if (packageInfo != null) {\n        ;\n        result[0].packageInfo = {\n            ...packageInfo,\n            path: util_1.newUrlFromBase(pathTransformer(packageInfo.path), baseUrl).href,\n        };\n    }\n    return result;\n}\nexports.resolveFiles = resolveFiles;\n//# sourceMappingURL=Provider.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.blockmapFiles = exports.getChannelFilename = exports.newUrlFromBase = exports.newBaseUrl = void 0;\n// if baseUrl path doesn't ends with /, this path will be not prepended to passed pathname for new URL(input, base)\nconst url_1 = require(\"url\");\n// @ts-ignore\nconst escapeRegExp = require(\"lodash.escaperegexp\");\n/** @internal */\nfunction newBaseUrl(url) {\n    const result = new url_1.URL(url);\n    if (!result.pathname.endsWith(\"/\")) {\n        result.pathname += \"/\";\n    }\n    return result;\n}\nexports.newBaseUrl = newBaseUrl;\n// addRandomQueryToAvoidCaching is false by default because in most cases URL already contains version number,\n// so, it makes sense only for Generic Provider for channel files\nfunction newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {\n    const result = new url_1.URL(pathname, baseUrl);\n    // search is not propagated (search is an empty string if not specified)\n    const search = baseUrl.search;\n    if (search != null && search.length !== 0) {\n        result.search = search;\n    }\n    else if (addRandomQueryToAvoidCaching) {\n        result.search = `noCache=${Date.now().toString(32)}`;\n    }\n    return result;\n}\nexports.newUrlFromBase = newUrlFromBase;\nfunction getChannelFilename(channel) {\n    return `${channel}.yml`;\n}\nexports.getChannelFilename = getChannelFilename;\nfunction blockmapFiles(baseUrl, oldVersion, newVersion) {\n    const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);\n    const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), \"g\"), oldVersion)}.blockmap`, baseUrl);\n    return [oldBlockMapUrl, newBlockMapUrl];\n}\nexports.blockmapFiles = blockmapFiles;\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifySignature = void 0;\nconst builder_util_runtime_1 = require(\"builder-util-runtime\");\nconst child_process_1 = require(\"child_process\");\nconst os = require(\"os\");\n// $certificateInfo = (Get-AuthenticodeSignature 'xxx\\yyy.exe'\n// | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains(\"CN=siemens.com\")})\n// | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }\nfunction verifySignature(publisherNames, unescapedTempUpdateFile, logger) {\n    return new Promise(resolve => {\n        // Escape quotes and backticks in filenames to prevent user from breaking the\n        // arguments and perform a remote command injection.\n        //\n        // Consider example powershell command:\n        // ```powershell\n        // Get-AuthenticodeSignature 'C:\\\\path\\\\my-bad-';calc;'filename.exe'\n        // ```\n        // The above would work expected and find the file name, however, it will also execute `;calc;`\n        // command and start the calculator app.\n        //\n        // From Powershell quoting rules:\n        // https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_quoting_rules?view=powershell-7\n        // * Double quotes `\"` are treated literally within single-quoted strings;\n        // * Single quotes can be escaped by doubling them: 'don''t' -> don't;\n        // * Backticks can be escaped by doubling them: 'A backtick (``) character';\n        //\n        // Also note that at this point the file has already been written to the disk, thus we are\n        // guaranteed that the path will not contain any illegal characters like <>:\"/\\|?*\n        // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n        const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, \"''\").replace(/`/g, \"``\");\n        // https://github.com/electron-userland/electron-builder/issues/2421\n        // https://github.com/electron-userland/electron-builder/issues/2535\n        child_process_1.execFile(\"powershell.exe\", [\n            \"-NoProfile\",\n            \"-NonInteractive\",\n            \"-InputFormat\",\n            \"None\",\n            \"-Command\",\n            `Get-AuthenticodeSignature '${tempUpdateFile}' | ConvertTo-Json -Compress | ForEach-Object { [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_)) }`,\n        ], {\n            timeout: 20 * 1000,\n        }, (error, stdout, stderr) => {\n            try {\n                if (error != null || stderr) {\n                    handleError(logger, error, stderr);\n                    resolve(null);\n                    return;\n                }\n                const data = parseOut(Buffer.from(stdout, \"base64\").toString(\"utf-8\"));\n                if (data.Status === 0) {\n                    const name = builder_util_runtime_1.parseDn(data.SignerCertificate.Subject).get(\"CN\");\n                    if (publisherNames.includes(name)) {\n                        resolve(null);\n                        return;\n                    }\n                }\n                const result = `publisherNames: ${publisherNames.join(\" | \")}, raw info: ` + JSON.stringify(data, (name, value) => (name === \"RawData\" ? undefined : value), 2);\n                logger.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);\n                resolve(result);\n            }\n            catch (e) {\n                logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error}. Ignoring signature validation due to unknown error.`);\n                resolve(null);\n                return;\n            }\n        });\n    });\n}\nexports.verifySignature = verifySignature;\nfunction parseOut(out) {\n    const data = JSON.parse(out);\n    delete data.PrivateKey;\n    delete data.IsOSBinary;\n    delete data.SignatureType;\n    const signerCertificate = data.SignerCertificate;\n    if (signerCertificate != null) {\n        delete signerCertificate.Archived;\n        delete signerCertificate.Extensions;\n        delete signerCertificate.Handle;\n        delete signerCertificate.HasPrivateKey;\n        // duplicates data.SignerCertificate (contains RawData)\n        delete signerCertificate.SubjectName;\n    }\n    delete data.Path;\n    return data;\n}\nfunction handleError(logger, error, stderr) {\n    if (isOldWin6()) {\n        logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);\n        return;\n    }\n    try {\n        child_process_1.execFileSync(\"powershell.exe\", [\"-NoProfile\", \"-NonInteractive\", \"-Command\", \"ConvertTo-Json test\"], { timeout: 10 * 1000 });\n    }\n    catch (testError) {\n        logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);\n        return;\n    }\n    if (error != null) {\n        throw error;\n    }\n    if (stderr) {\n        logger.warn(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Ignoring signature validation due to unknown stderr.`);\n        return;\n    }\n}\nfunction isOldWin6() {\n    const winVersion = os.release();\n    return winVersion.startsWith(\"6.\") && !winVersion.startsWith(\"6.3\");\n}\n//# sourceMappingURL=windowsExecutableCodeSignatureVerifier.js.map","/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n","'use strict';\n\nvar isGlob = require('is-glob');\nvar pathPosixDirname = require('path').posix.dirname;\nvar isWin32 = require('os').platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n","'use strict'\n\nmodule.exports = clone\n\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\n  return obj.__proto__\n}\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: getPrototypeOf(obj) }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          resetQueue()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      resetQueue()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      require('assert').equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb, startTime) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb, startTime) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb, startTime) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$copyFile = fs.copyFile\n  if (fs$copyFile)\n    fs.copyFile = copyFile\n  function copyFile (src, dest, flags, cb) {\n    if (typeof flags === 'function') {\n      cb = flags\n      flags = 0\n    }\n    return go$copyFile(src, dest, flags, cb)\n\n    function go$copyFile (src, dest, flags, cb, startTime) {\n      return fs$copyFile(src, dest, flags, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readdir(path, options, cb)\n\n    function go$readdir (path, options, cb, startTime) {\n      return fs$readdir(path, options, function (err, files) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (files && files.sort)\n            files.sort()\n\n          if (typeof cb === 'function')\n            cb.call(this, err, files)\n        }\n      })\n    }\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb, startTime) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n  retry()\n}\n\n// keep track of the timeout between retry() calls\nvar retryTimer\n\n// reset the startTime and lastTime to now\n// this resets the start of the 60 second overall timeout as well as the\n// delay between attempts so that we'll retry these jobs sooner\nfunction resetQueue () {\n  var now = Date.now()\n  for (var i = 0; i < fs[gracefulQueue].length; ++i) {\n    // entries that are only a length of 2 are from an older version, don't\n    // bother modifying those since they'll be retried anyway.\n    if (fs[gracefulQueue][i].length > 2) {\n      fs[gracefulQueue][i][3] = now // startTime\n      fs[gracefulQueue][i][4] = now // lastTime\n    }\n  }\n  // call retry to make sure we're actively processing the queue\n  retry()\n}\n\nfunction retry () {\n  // clear the timer and remove it to help prevent unintended concurrency\n  clearTimeout(retryTimer)\n  retryTimer = undefined\n\n  if (fs[gracefulQueue].length === 0)\n    return\n\n  var elem = fs[gracefulQueue].shift()\n  var fn = elem[0]\n  var args = elem[1]\n  // these items may be unset if they were added by an older graceful-fs\n  var err = elem[2]\n  var startTime = elem[3]\n  var lastTime = elem[4]\n\n  // if we don't have a startTime we have no way of knowing if we've waited\n  // long enough, so go ahead and retry this item now\n  if (startTime === undefined) {\n    debug('RETRY', fn.name, args)\n    fn.apply(null, args)\n  } else if (Date.now() - startTime >= 60000) {\n    // it's been more than 60 seconds total, bail now\n    debug('TIMEOUT', fn.name, args)\n    var cb = args.pop()\n    if (typeof cb === 'function')\n      cb.call(null, err)\n  } else {\n    // the amount of time between the last attempt and right now\n    var sinceAttempt = Date.now() - lastTime\n    // the amount of time between when we first tried, and when we last tried\n    // rounded up to at least 1\n    var sinceStart = Math.max(lastTime - startTime, 1)\n    // backoff. wait longer than the total time we've been retrying, but only\n    // up to a maximum of 100ms\n    var desiredDelay = Math.min(sinceStart * 1.2, 100)\n    // it's been long enough since the last retry, do it again\n    if (sinceAttempt >= desiredDelay) {\n      debug('RETRY', fn.name, args)\n      fn.apply(null, args.concat([startTime]))\n    } else {\n      // if we can't do this job yet, push it to the end of the queue\n      // and let the next iteration check again\n      fs[gracefulQueue].push(elem)\n    }\n  }\n\n  // schedule our next run if one isn't already scheduled\n  if (retryTimer === undefined) {\n    retryTimer = setTimeout(retry, 0)\n  }\n}\n","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\n// This check is needed until node.js 12 is required\nif (typeof process.chdir === 'function') {\n  var chdir = process.chdir\n  process.chdir = function (d) {\n    cwd = null\n    chdir.call(process, d)\n  }\n  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats) {\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n      }\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n","/**\n * @preserve\n * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)\n *\n * @author <a href=\"mailto:jensyt@gmail.com\">Jens Taylor</a>\n * @see http://github.com/homebrewing/brauhaus-diff\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n */\n(function(){\n    var cache;\n\n    // Call this function without `new` to use the cached object (good for\n    // single-threaded environments), or with `new` to create a new object.\n    //\n    // @param {string} key A UTF-16 or ASCII string\n    // @param {number} seed An optional positive integer\n    // @return {object} A MurmurHash3 object for incremental hashing\n    function MurmurHash3(key, seed) {\n        var m = this instanceof MurmurHash3 ? this : cache;\n        m.reset(seed)\n        if (typeof key === 'string' && key.length > 0) {\n            m.hash(key);\n        }\n\n        if (m !== this) {\n            return m;\n        }\n    };\n\n    // Incrementally add a string to this hash\n    //\n    // @param {string} key A UTF-16 or ASCII string\n    // @return {object} this\n    MurmurHash3.prototype.hash = function(key) {\n        var h1, k1, i, top, len;\n\n        len = key.length;\n        this.len += len;\n\n        k1 = this.k1;\n        i = 0;\n        switch (this.rem) {\n            case 0: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) : 0;\n            case 1: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;\n            case 2: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;\n            case 3:\n                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;\n                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;\n        }\n\n        this.rem = (len + this.rem) & 3; // & 3 is same as % 4\n        len -= this.rem;\n        if (len > 0) {\n            h1 = this.h1;\n            while (1) {\n                k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;\n                k1 = (k1 << 15) | (k1 >>> 17);\n                k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;\n\n                h1 ^= k1;\n                h1 = (h1 << 13) | (h1 >>> 19);\n                h1 = (h1 * 5 + 0xe6546b64) & 0xffffffff;\n\n                if (i >= len) {\n                    break;\n                }\n\n                k1 = ((key.charCodeAt(i++) & 0xffff)) ^\n                     ((key.charCodeAt(i++) & 0xffff) << 8) ^\n                     ((key.charCodeAt(i++) & 0xffff) << 16);\n                top = key.charCodeAt(i++);\n                k1 ^= ((top & 0xff) << 24) ^\n                      ((top & 0xff00) >> 8);\n            }\n\n            k1 = 0;\n            switch (this.rem) {\n                case 3: k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;\n                case 2: k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;\n                case 1: k1 ^= (key.charCodeAt(i) & 0xffff);\n            }\n\n            this.h1 = h1;\n        }\n\n        this.k1 = k1;\n        return this;\n    };\n\n    // Get the result of this hash\n    //\n    // @return {number} The 32-bit hash\n    MurmurHash3.prototype.result = function() {\n        var k1, h1;\n        \n        k1 = this.k1;\n        h1 = this.h1;\n\n        if (k1 > 0) {\n            k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;\n            h1 ^= k1;\n        }\n\n        h1 ^= this.len;\n\n        h1 ^= h1 >>> 16;\n        h1 = (h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000) & 0xffffffff;\n        h1 ^= h1 >>> 13;\n        h1 = (h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000) & 0xffffffff;\n        h1 ^= h1 >>> 16;\n\n        return h1 >>> 0;\n    };\n\n    // Reset the hash object for reuse\n    //\n    // @param {number} seed An optional positive integer\n    MurmurHash3.prototype.reset = function(seed) {\n        this.h1 = typeof seed === 'number' ? seed : 0;\n        this.rem = this.k1 = this.len = 0;\n        return this;\n    };\n\n    // A cached object to use. This can be safely used if you're in a single-\n    // threaded environment, otherwise you need to create new hashes to use.\n    cache = new MurmurHash3();\n\n    if (typeof(module) != 'undefined') {\n        module.exports = MurmurHash3;\n    } else {\n        this.MurmurHash3 = MurmurHash3;\n    }\n}());\n","'use strict';\nconst path = require('path');\nconst binaryExtensions = require('binary-extensions');\n\nconst extensions = new Set(binaryExtensions);\n\nmodule.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n","/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n","/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n","/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n","module.exports      = isTypedArray\nisTypedArray.strict = isStrictTypedArray\nisTypedArray.loose  = isLooseTypedArray\n\nvar toString = Object.prototype.toString\nvar names = {\n    '[object Int8Array]': true\n  , '[object Int16Array]': true\n  , '[object Int32Array]': true\n  , '[object Uint8Array]': true\n  , '[object Uint8ClampedArray]': true\n  , '[object Uint16Array]': true\n  , '[object Uint32Array]': true\n  , '[object Float32Array]': true\n  , '[object Float64Array]': true\n}\n\nfunction isTypedArray(arr) {\n  return (\n       isStrictTypedArray(arr)\n    || isLooseTypedArray(arr)\n  )\n}\n\nfunction isStrictTypedArray(arr) {\n  return (\n       arr instanceof Int8Array\n    || arr instanceof Int16Array\n    || arr instanceof Int32Array\n    || arr instanceof Uint8Array\n    || arr instanceof Uint8ClampedArray\n    || arr instanceof Uint16Array\n    || arr instanceof Uint32Array\n    || arr instanceof Float32Array\n    || arr instanceof Float64Array\n  )\n}\n\nfunction isLooseTypedArray(arr) {\n  return names[toString.call(arr)]\n}\n","'use strict';\n\n\nvar loader = require('./lib/loader');\nvar dumper = require('./lib/dumper');\n\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nmodule.exports.Type                = require('./lib/type');\nmodule.exports.Schema              = require('./lib/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./lib/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./lib/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./lib/schema/core');\nmodule.exports.DEFAULT_SCHEMA      = require('./lib/schema/default');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.YAMLException       = require('./lib/exception');\n\n// Re-export all types in case user wants to create custom schema\nmodule.exports.types = {\n  binary:    require('./lib/type/binary'),\n  float:     require('./lib/type/float'),\n  map:       require('./lib/type/map'),\n  null:      require('./lib/type/null'),\n  pairs:     require('./lib/type/pairs'),\n  set:       require('./lib/type/set'),\n  timestamp: require('./lib/type/timestamp'),\n  bool:      require('./lib/type/bool'),\n  int:       require('./lib/type/int'),\n  merge:     require('./lib/type/merge'),\n  omap:      require('./lib/type/omap'),\n  seq:       require('./lib/type/seq'),\n  str:       require('./lib/type/str')\n};\n\n// Removed functions from JS-YAML 3.0.x\nmodule.exports.safeLoad            = renamed('safeLoad', 'load');\nmodule.exports.safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nmodule.exports.safeDump            = renamed('safeDump', 'dump');\n","'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n","'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nmodule.exports.dump = dump;\n","// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nmodule.exports = YAMLException;\n","'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar makeSnippet         = require('./snippet');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = makeSnippet(mark);\n\n  return new YAMLException(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    // used for this specific key only because Object.defineProperty is slow\n    if (keyNode === '__proto__') {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nmodule.exports.loadAll = loadAll;\nmodule.exports.load    = load;\n","'use strict';\n\n/*eslint-disable max-len*/\n\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof Type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type.multi) {\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nmodule.exports = Schema;\n","// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nmodule.exports = require('./json');\n","// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nmodule.exports = require('./core').extend({\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n","// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n","// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nmodule.exports = require('./failsafe').extend({\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n","'use strict';\n\n\nvar common = require('./common');\n\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '→') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nmodule.exports = makeSnippet;\n","'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.options       = options; // keep original options in case user wants to extend this type later\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n","'use strict';\n\n/*eslint-disable no-bitwise*/\n\n\nvar Type = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n","const modifiers = /^(CommandOrControl|CmdOrCtrl|Command|Cmd|Control|Ctrl|AltGr|Option|Alt|Shift|Super)/i;\nconst keyCodes = /^(Plus|Space|Tab|Backspace|Delete|Insert|Return|Enter|Up|Down|Left|Right|Home|End|PageUp|PageDown|Escape|Esc|VolumeUp|VolumeDown|VolumeMute|MediaNextTrack|MediaPreviousTrack|MediaStop|MediaPlayPause|PrintScreen|F24|F23|F22|F21|F20|F19|F18|F17|F16|F15|F14|F13|F12|F11|F10|F9|F8|F7|F6|F5|F4|F3|F2|F1|[0-9A-Z)!@#$%^&*(:+<_>?~{|}\";=,\\-./`[\\\\\\]'])/i;\nconst UNSUPPORTED = {};\n\nfunction _command(accelerator, event, modifier) {\n\tif (process.platform !== 'darwin') {\n\t\treturn UNSUPPORTED;\n\t}\n\n\tif (event.metaKey) {\n\t\tthrow new Error('Double `Command` modifier specified.');\n\t}\n\n\treturn {\n\t\tevent: Object.assign({}, event, {metaKey: true}),\n\t\taccelerator: accelerator.slice(modifier.length)\n\t};\n}\n\nfunction _super(accelerator, event, modifier) {\n\tif (event.metaKey) {\n\t\tthrow new Error('Double `Super` modifier specified.');\n\t}\n\n\treturn {\n\t\tevent: Object.assign({}, event, {metaKey: true}),\n\t\taccelerator: accelerator.slice(modifier.length)\n\t};\n}\n\nfunction _commandorcontrol(accelerator, event, modifier) {\n\tif (process.platform === 'darwin') {\n\t\tif (event.metaKey) {\n\t\t\tthrow new Error('Double `Command` modifier specified.');\n\t\t}\n\n\t\treturn {\n\t\t\tevent: Object.assign({}, event, {metaKey: true}),\n\t\t\taccelerator: accelerator.slice(modifier.length)\n\t\t};\n\t}\n\n\tif (event.ctrlKey) {\n\t\tthrow new Error('Double `Control` modifier specified.');\n\t}\n\n\treturn {\n\t\tevent: Object.assign({}, event, {ctrlKey: true}),\n\t\taccelerator: accelerator.slice(modifier.length)\n\t};\n}\n\nfunction _alt(accelerator, event, modifier) {\n\tif (modifier === 'option' && process.platform !== 'darwin') {\n\t\treturn UNSUPPORTED;\n\t}\n\n\tif (event.altKey) {\n\t\tthrow new Error('Double `Alt` modifier specified.');\n\t}\n\n\treturn {\n\t\tevent: Object.assign({}, event, {altKey: true}),\n\t\taccelerator: accelerator.slice(modifier.length)\n\t};\n}\n\nfunction _shift(accelerator, event, modifier) {\n\tif (event.shiftKey) {\n\t\tthrow new Error('Double `Shift` modifier specified.');\n\t}\n\n\treturn {\n\t\tevent: Object.assign({}, event, {shiftKey: true}),\n\t\taccelerator: accelerator.slice(modifier.length)\n\t};\n}\n\nfunction _control(accelerator, event, modifier) {\n\tif (event.ctrlKey) {\n\t\tthrow new Error('Double `Control` modifier specified.');\n\t}\n\n\treturn {\n\t\tevent: Object.assign({}, event, {ctrlKey: true}),\n\t\taccelerator: accelerator.slice(modifier.length)\n\t};\n}\n\nfunction reduceModifier({accelerator, event}, modifier) {\n\tswitch (modifier) {\n\t\tcase 'command':\n\t\tcase 'cmd': {\n\t\t\treturn _command(accelerator, event, modifier);\n\t\t}\n\n\t\tcase 'super': {\n\t\t\treturn _super(accelerator, event, modifier);\n\t\t}\n\n\t\tcase 'control':\n\t\tcase 'ctrl': {\n\t\t\treturn _control(accelerator, event, modifier);\n\t\t}\n\n\t\tcase 'commandorcontrol':\n\t\tcase 'cmdorctrl': {\n\t\t\treturn _commandorcontrol(accelerator, event, modifier);\n\t\t}\n\n\t\tcase 'option':\n\t\tcase 'altgr':\n\t\tcase 'alt': {\n\t\t\treturn _alt(accelerator, event, modifier);\n\t\t}\n\n\t\tcase 'shift': {\n\t\t\treturn _shift(accelerator, event, modifier);\n\t\t}\n\n\t\tdefault:\n\t\t\tconsole.error(modifier);\n\t}\n}\n\nfunction reducePlus({accelerator, event}) {\n\treturn {\n\t\tevent,\n\t\taccelerator: accelerator.trim().slice(1)\n\t};\n}\n\nconst virtualKeyCodes = {\n\t0: 'Digit0',\n\t1: 'Digit1',\n\t2: 'Digit2',\n\t3: 'Digit3',\n\t4: 'Digit4',\n\t5: 'Digit5',\n\t6: 'Digit6',\n\t7: 'Digit7',\n\t8: 'Digit8',\n\t9: 'Digit9',\n\t'-': 'Minus',\n\t'=': 'Equal',\n\tQ: 'KeyQ',\n\tW: 'KeyW',\n\tE: 'KeyE',\n\tR: 'KeyR',\n\tT: 'KeyT',\n\tY: 'KeyY',\n\tU: 'KeyU',\n\tI: 'KeyI',\n\tO: 'KeyO',\n\tP: 'KeyP',\n\t'[': 'BracketLeft',\n\t']': 'BracketRight',\n\tA: 'KeyA',\n\tS: 'KeyS',\n\tD: 'KeyD',\n\tF: 'KeyF',\n\tG: 'KeyG',\n\tH: 'KeyH',\n\tJ: 'KeyJ',\n\tK: 'KeyK',\n\tL: 'KeyL',\n\t';': 'Semicolon',\n\t'\\'': 'Quote',\n\t'`': 'Backquote',\n\t'/': 'Backslash',\n\tZ: 'KeyZ',\n\tX: 'KeyX',\n\tC: 'KeyC',\n\tV: 'KeyV',\n\tB: 'KeyB',\n\tN: 'KeyN',\n\tM: 'KeyM',\n\t',': 'Comma',\n\t'.': 'Period',\n\t'\\\\': 'Slash',\n\t' ': 'Space'\n};\n\nfunction reduceKey({accelerator, event}, key) {\n\tif (key.length > 1 || event.key) {\n\t\tthrow new Error(`Unvalid keycode \\`${key}\\`.`);\n\t}\n\n\tconst code =\n\t\tkey.toUpperCase() in virtualKeyCodes ?\n\t\t\tvirtualKeyCodes[key.toUpperCase()] :\n\t\t\tnull;\n\n\treturn {\n\t\tevent: Object.assign({}, event, {key}, code ? {code} : null),\n\t\taccelerator: accelerator.trim().slice(key.length)\n\t};\n}\n\nconst domKeys = Object.assign(Object.create(null), {\n\tplus: 'Add',\n\tspace: 'Space',\n\ttab: 'Tab',\n\tbackspace: 'Backspace',\n\tdelete: 'Delete',\n\tinsert: 'Insert',\n\treturn: 'Return',\n\tenter: 'Return',\n\tup: 'ArrowUp',\n\tdown: 'ArrowDown',\n\tleft: 'ArrowLeft',\n\tright: 'ArrowRight',\n\thome: 'Home',\n\tend: 'End',\n\tpageup: 'PageUp',\n\tpagedown: 'PageDown',\n\tescape: 'Escape',\n\tesc: 'Escape',\n\tvolumeup: 'AudioVolumeUp',\n\tvolumedown: 'AudioVolumeDown',\n\tvolumemute: 'AudioVolumeMute',\n\tmedianexttrack: 'MediaTrackNext',\n\tmediaprevioustrack: 'MediaTrackPrevious',\n\tmediastop: 'MediaStop',\n\tmediaplaypause: 'MediaPlayPause',\n\tprintscreen: 'PrintScreen'\n});\n\n// Add function keys\nfor (let i = 1; i <= 24; i++) {\n\tdomKeys[`f${i}`] = `F${i}`;\n}\n\nfunction reduceCode({accelerator, event}, {code, key}) {\n\tif (event.code) {\n\t\tthrow new Error(`Duplicated keycode \\`${key}\\`.`);\n\t}\n\n\treturn {\n\t\tevent: Object.assign({}, event, {key}, code ? {code} : null),\n\t\taccelerator: accelerator.trim().slice((key && key.length) || 0)\n\t};\n}\n\n/**\n * This function transform an Electron Accelerator string into\n * a DOM KeyboardEvent object.\n *\n * @param  {string} accelerator an Electron Accelerator string, e.g. `Ctrl+C` or `Shift+Space`.\n * @return {object} a DOM KeyboardEvent object derivate from the `accelerator` argument.\n */\nfunction toKeyEvent(accelerator) {\n\tlet state = {accelerator, event: {}};\n\twhile (state.accelerator !== '') {\n\t\tconst modifierMatch = state.accelerator.match(modifiers);\n\t\tif (modifierMatch) {\n\t\t\tconst modifier = modifierMatch[0].toLowerCase();\n\t\t\tstate = reduceModifier(state, modifier);\n\t\t\tif (state === UNSUPPORTED) {\n\t\t\t\treturn {unsupportedKeyForPlatform: true};\n\t\t\t}\n\t\t} else if (state.accelerator.trim()[0] === '+') {\n\t\t\tstate = reducePlus(state);\n\t\t} else {\n\t\t\tconst codeMatch = state.accelerator.match(keyCodes);\n\t\t\tif (codeMatch) {\n\t\t\t\tconst code = codeMatch[0].toLowerCase();\n\t\t\t\tif (code in domKeys) {\n\t\t\t\t\tstate = reduceCode(state, {\n\t\t\t\t\t\tcode: domKeys[code],\n\t\t\t\t\t\tkey: code\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tstate = reduceKey(state, code);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Unvalid accelerator: \"${state.accelerator}\"`);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn state.event;\n}\n\nmodule.exports = {\n\tUNSUPPORTED,\n\treduceModifier,\n\treducePlus,\n\treduceKey,\n\treduceCode,\n\ttoKeyEvent\n};\n","'use strict';\n\nfunction _lower(key) {\n\tif (typeof key !== 'string') {\n\t\treturn key;\n\t}\n\treturn key.toLowerCase();\n}\n\nfunction areEqual(ev1, ev2) {\n\tif (ev1 === ev2) {\n\t\t// Same object\n\t\t// console.log(`Events are same.`)\n\t\treturn true;\n\t}\n\n\tfor (const prop of ['altKey', 'ctrlKey', 'shiftKey', 'metaKey']) {\n\t\tconst [value1, value2] = [ev1[prop], ev2[prop]];\n\n\t\tif (Boolean(value1) !== Boolean(value2)) {\n\t\t\t// One of the prop is different\n\t\t\t// console.log(`Comparing prop ${prop}: ${value1} ${value2}`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ((_lower(ev1.key) === _lower(ev2.key) && ev1.key !== undefined) ||\n\t\t(ev1.code === ev2.code && ev1.code !== undefined)) {\n\t\t// Events are equals\n\t\treturn true;\n\t}\n\n\t// Key or code are differents\n\t// console.log(`key or code are differents. ${ev1.key} !== ${ev2.key} ${ev1.code} !== ${ev2.code}`);\n\n\treturn false;\n}\n\nmodule.exports = areEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lazy = void 0;\nclass Lazy {\n    constructor(creator) {\n        this._value = null;\n        this.creator = creator;\n    }\n    get hasValue() {\n        return this.creator == null;\n    }\n    get value() {\n        if (this.creator == null) {\n            return this._value;\n        }\n        const result = this.creator();\n        this.value = result;\n        return result;\n    }\n    set value(value) {\n        this._value = value;\n        this.creator = null;\n    }\n}\nexports.Lazy = Lazy;\n//# sourceMappingURL=main.js.map","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */\nfunction escapeRegExp(string) {\n  string = toString(string);\n  return (string && reHasRegExpChar.test(string))\n    ? string.replace(reRegExpChar, '\\\\$&')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nmodule.exports = has;\n","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n * it's created. Arrays are created for missing index properties while objects\n * are created for all other missing properties. Use `_.setWith` to customize\n * `path` creation.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.set(object, 'a[0].b.c', 4);\n * console.log(object.a[0].b.c);\n * // => 4\n *\n * _.set(object, ['x', '0', 'y', 'z'], 5);\n * console.log(object.x[0].y.z);\n * // => 5\n */\nfunction set(object, path, value) {\n  return object == null ? object : baseSet(object, path, value);\n}\n\nmodule.exports = set;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n  object = parent(object, path);\n\n  var key = toKey(last(path));\n  return !(object != null && hasOwnProperty.call(object, key)) || delete object[key];\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array ? array.length : 0;\n  return length ? array[length - 1] : undefined;\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Removes the property at `path` of `object`.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n * _.unset(object, 'a[0].b.c');\n * // => true\n *\n * console.log(object);\n * // => { 'a': [{ 'b': {} }] };\n *\n * _.unset(object, ['a', '0', 'b', 'c']);\n * // => true\n *\n * console.log(object);\n * // => { 'a': [{ 'b': {} }] };\n */\nfunction unset(object, path) {\n  return object == null ? true : baseUnset(object, path);\n}\n\nmodule.exports = unset;\n","'use strict'\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = require('yallist')\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n","const optsArg = require('./lib/opts-arg.js')\nconst pathArg = require('./lib/path-arg.js')\n\nconst {mkdirpNative, mkdirpNativeSync} = require('./lib/mkdirp-native.js')\nconst {mkdirpManual, mkdirpManualSync} = require('./lib/mkdirp-manual.js')\nconst {useNative, useNativeSync} = require('./lib/use-native.js')\n\n\nconst mkdirp = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNative(opts)\n    ? mkdirpNative(path, opts)\n    : mkdirpManual(path, opts)\n}\n\nconst mkdirpSync = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNativeSync(opts)\n    ? mkdirpNativeSync(path, opts)\n    : mkdirpManualSync(path, opts)\n}\n\nmkdirp.sync = mkdirpSync\nmkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))\nmkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))\nmkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))\nmkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))\n\nmodule.exports = mkdirp\n","const {dirname} = require('path')\n\nconst findMade = (opts, parent, path = undefined) => {\n  // we never want the 'made' return value to be a root directory\n  if (path === parent)\n    return Promise.resolve()\n\n  return opts.statAsync(parent).then(\n    st => st.isDirectory() ? path : undefined, // will fail later\n    er => er.code === 'ENOENT'\n      ? findMade(opts, dirname(parent), parent)\n      : undefined\n  )\n}\n\nconst findMadeSync = (opts, parent, path = undefined) => {\n  if (path === parent)\n    return undefined\n\n  try {\n    return opts.statSync(parent).isDirectory() ? path : undefined\n  } catch (er) {\n    return er.code === 'ENOENT'\n      ? findMadeSync(opts, dirname(parent), parent)\n      : undefined\n  }\n}\n\nmodule.exports = {findMade, findMadeSync}\n","const {dirname} = require('path')\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n","const {dirname} = require('path')\nconst {findMade, findMadeSync} = require('./find-made.js')\nconst {mkdirpManual, mkdirpManualSync} = require('./mkdirp-manual.js')\n\nconst mkdirpNative = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirAsync(path, opts)\n\n  return findMade(opts, path).then(made =>\n    opts.mkdirAsync(path, opts).then(() => made)\n    .catch(er => {\n      if (er.code === 'ENOENT')\n        return mkdirpManual(path, opts)\n      else\n        throw er\n    }))\n}\n\nconst mkdirpNativeSync = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirSync(path, opts)\n\n  const made = findMadeSync(opts, path)\n  try {\n    opts.mkdirSync(path, opts)\n    return made\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts)\n    else\n      throw er\n  }\n}\n\nmodule.exports = {mkdirpNative, mkdirpNativeSync}\n","const { promisify } = require('util')\nconst fs = require('fs')\nconst optsArg = opts => {\n  if (!opts)\n    opts = { mode: 0o777, fs }\n  else if (typeof opts === 'object')\n    opts = { mode: 0o777, fs, ...opts }\n  else if (typeof opts === 'number')\n    opts = { mode: opts, fs }\n  else if (typeof opts === 'string')\n    opts = { mode: parseInt(opts, 8), fs }\n  else\n    throw new TypeError('invalid options argument')\n\n  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir\n  opts.mkdirAsync = promisify(opts.mkdir)\n  opts.stat = opts.stat || opts.fs.stat || fs.stat\n  opts.statAsync = promisify(opts.stat)\n  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync\n  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync\n  return opts\n}\nmodule.exports = optsArg\n","const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform\nconst { resolve, parse } = require('path')\nconst pathArg = path => {\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    throw Object.assign(\n      new TypeError('path must be a string without null bytes'),\n      {\n        path,\n        code: 'ERR_INVALID_ARG_VALUE',\n      }\n    )\n  }\n\n  path = resolve(path)\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const {root} = parse(path)\n    if (badWinChars.test(path.substr(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\nmodule.exports = pathArg\n","const fs = require('fs')\n\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\nconst hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12\n\nconst useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir\nconst useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync\n\nmodule.exports = {useNative, useNativeSync}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","const chokidar = require('chokidar');\nconst EventEmitter = require('events');\nconst fs = require('fs');\nconst os = require('os');\n\nconst watcher = Symbol('watcher');\nconst fd = Symbol('fd');\n\nfunction closeFile() {\n  if (this[td]) {\n    fs.close(this[fd], (err) => {\n      if (err) {\n        return;\n      }\n      this[td] = undefined;\n    });\n  }\n}\n\nclass Tail extends EventEmitter {\n\n  constructor(filename, options) {\n    super();\n    this.filename = filename;\n    this.options = Object.assign(options || {}, {\n      alwaysStat: true,\n      ignoreInitial: false,\n      persistent: true,\n    });\n    this[watcher] = undefined;\n    this[fd] = undefined;\n  }\n\n  watch() {\n    let lastSize = 0;\n\n    this[watcher] = chokidar.watch(this.filename, this.options)\n      .on('add', (path, stats) => {\n        lastSize = stats.size;\n      })\n      .on('change', (path, stats) => {\n        const diff = stats.size - lastSize;\n        if (diff <= 0) {\n          lastSize = stats.size;\n          return;\n        }\n        const buffer = Buffer.alloc(diff);\n        this[fd] = fs.openSync(path, 'r');\n        fs.read(this[fd], buffer, 0, diff, lastSize, (err) => {\n          if (err) {\n            return;\n          }\n          fs.closeSync(this[fd]);\n          buffer.toString().split(os.EOL).forEach((line, idx, ar) => {\n            if (idx < ar.length && line) {\n              this.emit('line', line);\n            }\n          });\n          \n        });\n        lastSize = stats.size;\n      })\n      .on('unlink', () => {\n        lastSize = 0;\n        closeFile.bind(this);\n      });\n  }\n\n  close() {\n    if (this[watcher]) {\n      this[watcher].unwatch(this.filename);\n      this[watcher].close();\n      this[watcher] = undefined;\n    }\n    this.emit('close');\n  }\n}\n\nmodule.exports = Tail;\n","/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n","'use strict';\n\nmodule.exports = require('./lib/picomatch');\n","'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {files, depth, path};\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = {path: sysPath.relative(this._root, fullPath), fullPath, basename};\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            return this._onError(new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            ));\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n",";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n","// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process\n\nconst processOk = function (process) {\n  return process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function'\n}\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process)) {\n  module.exports = function () {\n    return function () {}\n  }\n} else {\n  var assert = require('assert')\n  var signals = require('./signals.js')\n  var isWin = /^win/i.test(process.platform)\n\n  var EE = require('events')\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter\n  }\n\n  var emitter\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE()\n    emitter.count = 0\n    emitter.emitted = {}\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity)\n    emitter.infinite = true\n  }\n\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return function () {}\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n    if (loaded === false) {\n      load()\n    }\n\n    var ev = 'exit'\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit'\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb)\n      if (emitter.listeners('exit').length === 0 &&\n          emitter.listeners('afterexit').length === 0) {\n        unload()\n      }\n    }\n    emitter.on(ev, cb)\n\n    return remove\n  }\n\n  var unload = function unload () {\n    if (!loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = false\n\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    })\n    process.emit = originalProcessEmit\n    process.reallyExit = originalProcessReallyExit\n    emitter.count -= 1\n  }\n  module.exports.unload = unload\n\n  var emit = function emit (event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return\n    }\n    emitter.emitted[event] = true\n    emitter.emit(event, code, signal)\n  }\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {}\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener () {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process.listeners(sig)\n      if (listeners.length === emitter.count) {\n        unload()\n        emit('exit', null, sig)\n        /* istanbul ignore next */\n        emit('afterexit', null, sig)\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT'\n        }\n        /* istanbul ignore next */\n        process.kill(process.pid, sig)\n      }\n    }\n  })\n\n  module.exports.signals = function () {\n    return signals\n  }\n\n  var loaded = false\n\n  var load = function load () {\n    if (loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1\n\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig])\n        return true\n      } catch (er) {\n        return false\n      }\n    })\n\n    process.emit = processEmit\n    process.reallyExit = processReallyExit\n  }\n  module.exports.load = load\n\n  var originalProcessReallyExit = process.reallyExit\n  var processReallyExit = function processReallyExit (code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return\n    }\n    process.exitCode = code || /* istanbul ignore next */ 0\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process, process.exitCode)\n  }\n\n  var originalProcessEmit = process.emit\n  var processEmit = function processEmit (ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg\n      }\n      var ret = originalProcessEmit.apply(this, arguments)\n      /* istanbul ignore next */\n      emit('exit', process.exitCode, null)\n      /* istanbul ignore next */\n      emit('afterexit', process.exitCode, null)\n      /* istanbul ignore next */\n      return ret\n    } else {\n      return originalProcessEmit.apply(this, arguments)\n    }\n  }\n}\n","// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n","'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n","/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n","// Modules to control application life and create native browser window\r\nconst {app, BrowserWindow, ipcMain, Tray, Menu} = require('electron')\r\nconst path = require('path')\r\nlet fs = require('fs');\r\nconst settings = require('electron-settings');\r\nconst { create } = require('electron-log');\r\nconst localshortcut = require('electron-localshortcut');\r\nconst log = require('electron-log');\r\nlog.transports.file.level = 'info'\r\nconst { autoUpdater } = require(\"electron-updater\");\r\nautoUpdater.logger = log;\r\n\r\n//Only allow a single instance to run\r\nlet lock = app.requestSingleInstanceLock();\r\nif (!lock) {\r\n  app.quit();\r\n} else {\r\n  app.on('second-instance', () => {\r\n    createMainWindow();\r\n  });\r\n}\r\n\r\n//enable the autostart feature if selected\r\nlet isAutostart = settings.getSync('app.autostart');\r\nif (isAutostart == null) isAutostart = true;  //default to enabled\r\napp.setLoginItemSettings({openAtLogin: isAutostart});\r\n\r\n\r\n//check for any updates\r\nautoUpdater.addAuthHeader('update-downloaded', () => {\r\n  if (mainWindow) {\r\n    mainWindow.webContents.send('update-available');\r\n  }\r\n});\r\n\r\n\r\nfunction _showMainWindow() {\r\n  let electron = require('electron');\r\n  let screen = electron.screen;\r\n  let display = screen.getPrimaryDisplay();\r\n  let dh = display.workAreaSize.height;\r\n  let dw = display.workAreaSize.width;\r\n\r\n  let wh = mainWindow.getSize()[1];\r\n  let ww = mainWindow.getSize()[0];\r\n\r\n  let x = dw - ww;\r\n  let y = dh - wh;\r\n\r\n  mainWindow.setPosition(x, y);\r\n\r\n  mainWindow.show();\r\n  mainWindow.setAlwaysOnTop(true);\r\n  mainWindow.focus();\r\n}\r\n\r\n\r\nlet mainWindow;\r\nfunction createMainWindow () {\r\n  if (mainWindow != null) {\r\n    _showMainWindow();\r\n    return;\r\n  }\r\n\r\n  //is the main window supposed to be pinned to the top?\r\n  let isPinned = Boolean(settings.getSync('mainwindow.pinned'));\r\n\r\n  //restore our previous window size\r\n  let height = parseInt(settings.getSync('mainwindow.height'));\r\n  if (isNaN(height)) {\r\n    height = 800;\r\n  }\r\n\r\n  let width = parseInt(settings.getSync('mainwindow.width'));\r\n  if (isNaN(width)) {\r\n    width = 400;\r\n  }\r\n\r\n  // Create the browser window.\r\n  mainWindow = new BrowserWindow({\r\n    width: width,\r\n    height: height,\r\n    minHeight: 500,\r\n    minWidth: 300,\r\n    frame: false,\r\n    backgroundColor: 'white',\r\n    show: false,\r\n    icon: __dirname + './assets/pallet.png',\r\n    \r\n\r\n    webPreferences: {\r\n      nodeIntegration: true,\r\n      contextIsolation: false,\r\n      preload: path.join(__dirname, 'preload.js'),\r\n      webSecurity: true\r\n    }\r\n  });\r\n  mainWindow.removeMenu();\r\n\r\n  // and load the index.html of the app.\r\n  mainWindow.loadFile('src/index.html');\r\n  // mainWindow.webContents.openDevTools({\r\n  //   mode: 'detach'\r\n  // });\r\n  \r\n\r\n  mainWindow.on('ready-to-show', () => {\r\n    _showMainWindow();\r\n  });\r\n\r\n  mainWindow.on('close', (e) => {\r\n    e.preventDefault();\r\n    mainWindow.minimize();\r\n    mainWindow.hide();\r\n  });\r\n\r\n  mainWindow.on('resized', (e) => {\r\n    let size = mainWindow.getSize();\r\n    let width = size[0];\r\n    let height = size[1];\r\n\r\n    settings.setSync('mainwindow.height', height);\r\n    settings.setSync('mainwindow.width', width);\r\n\r\n  });\r\n\r\n  //only check for updates once the main window has been shown\r\n  mainWindow.once('ready-to-show', () => {\r\n    autoUpdater.checkForUpdatesAndNotify();\r\n  });\r\n\r\n  localshortcut.register(mainWindow, \"Ctrl+Shift+I\", () => {\r\n    mainWindow.webContents.openDevTools({\r\n      mode: 'detach'\r\n    });\r\n  });\r\n}\r\n\r\nfunction createTrayIcon() {\r\n  let iconPath = path.join(__dirname, './src/assets/pallet.png');\r\n  let tray = new Tray(iconPath);\r\n  const contextMenu = Menu.buildFromTemplate([\r\n    { label: 'Show', type: 'normal', click: () => {\r\n      createMainWindow();\r\n    } },\r\n    { label: `v ${app.getVersion()}`, type: 'normal', click: () => {\r\n      //nothing to do here\r\n    } },\r\n    { type: 'separator'},\r\n    { label: 'Quit', type: 'normal', click: () => {\r\n      log.info('quitting...')\r\n\r\n      fileImporter.stopImport();\r\n\r\n      app.quit();\r\n      process.exit();\r\n    }}\r\n  ])\r\n  tray.setToolTip('Container Importer')\r\n  tray.setContextMenu(contextMenu);\r\n\r\n  tray.on('click', () => {\r\n    log.debug('left click')\r\n    createMainWindow();\r\n  });\r\n  tray.on('right-click', () => {\r\n    log.debug('right click')\r\n    tray.popUpContextMenu();\r\n  })\r\n}\r\n\r\n\r\n// This method will be called when Electron has finished\r\n// initialization and is ready to create browser windows.\r\n// Some APIs can only be used after this event occurs.\r\napp.whenReady().then(() => {\r\n  createTrayIcon();\r\n\r\n  \r\n//for testing, go ahead and create the main window\r\n// createMainWindow();\r\n\r\n  \r\n\r\napp.on('activate', function () {\r\n    // On macOS it's common to re-create a window in the app when the\r\n    // dock icon is clicked and there are no other windows open.\r\n    if (BrowserWindow.getAllWindows().length === 0) createMainWindow()\r\n  })\r\n});\r\n\r\napp.on('window-all-closed', (e) => {\r\n  log.debug('All windows closed');\r\n\r\n});\r\n\r\napp.on('will-quit', () => {\r\n  log.debug('App will quit listener')\r\n})\r\n\r\napp.on('before-quit', (e) => {\r\n  //preventDefault in the window-all-closed listener will prevent the app from quiting\r\n  e.preventDefault = false;\r\n  log.debug('Shutting down...');\r\n  fileImporter.stopImport();\r\n  tail.close();\r\n})\r\n\r\nipcMain.on('mainwindow-pinned', (e, isPinned) => {\r\n  settings.setSync('mainwindow.pinned', isPinned);\r\n  if (mainWindow) {\r\n    mainWindow.setAlwaysOnTop(isPinned, 'normal');\r\n  }\r\n});\r\n\r\nipcMain.on('change-autostart', (e, isAutostart) => {\r\n  app.setLoginItemSettings({openAtLogin: isAutostart});\r\n});\r\n\r\n\r\n//listen for request to get/set configuration values\r\nipcMain.on('settings-set', (e, prop, val) => {\r\n  settings.set(prop, val);\r\n});\r\n\r\n//listen for request to get/set configuration values\r\nipcMain.on('settings-set-sync', (e, prop, val) => {\r\n  settings.set(prop, val);\r\n  e.returnValue = true;\r\n});\r\n\r\nipcMain.on('settings-get', (event, prop) => {\r\n  let val = settings.getSync(prop);\r\n  event.returnValue = val;\r\n});\r\n\r\n\r\nipcMain.on('show-settings', () => {\r\n  //show the main settings window\r\n});\r\n\r\nipcMain.on('notifiy-settings-changed', (e, detail) => {\r\n  let configurationComplete = Boolean(detail.configurationComplete);\r\n\r\n  //when the settings change notify the welcome window\r\n  if (welcomeWindow != null) {\r\n    welcomeWindow.webContents.send('settings-changed', configurationComplete);\r\n  }\r\n});\r\n\r\n\r\nipcMain.on('request-db-info', (e, dbFile) => {\r\n  _updateDbInfo(dbFile);\r\n});\r\n\r\nasync function _updateDbInfo(dbFile) {\r\n  log.info(`Updating database info for file ${dbFile}`)\r\n  //pull some basic data about the database file\r\n  let dbInfo = {\r\n    file: '-',\r\n    path: '-',\r\n    records: -1,\r\n    size: -1   //in bytes\r\n  }\r\n\r\n  try {\r\n    if (fs.existsSync(dbFile)) {\r\n      dbInfo.path = path.dirname(dbFile);\r\n      log.info(`Found DB path of ${dbInfo.path}`);\r\n      dbInfo.file = path.basename(dbFile);\r\n      log.info(`Found DB filename of ${dbInfo.file}`);\r\n      let stats = fs.statSync(dbFile);\r\n      dbInfo.size = stats.size;\r\n      log.info(`DB file is ${dbInfo.size} bytes`)\r\n\r\n      //try to get the record count from the database file\r\n      log.info(`Checking DB record count`)\r\n      let connectionString = `Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=${dbFile};`;\r\n      let connectionConfig = {\r\n        connectionString,\r\n        connectionTimeout: 10\r\n      }\r\n      const odbc = require('odbc');\r\n      const connection = await odbc.connect(connectionConfig);\r\n      \r\n      let result = await connection.query('SELECT count(*) as total from WeeklyShipments');\r\n      // await connection.close();\r\n      let count = result[0]['total'];\r\n      log.info(`Database has ${count} records`)\r\n      dbInfo.records = count;\r\n    } else {\r\n      log.info(`Database file does not exist! ${dbFile}`);\r\n      throw('Database file does not exist!')\r\n    }\r\n  } catch (err) {\r\n    dbInfo.error = err;\r\n  } finally {\r\n    //send the dbInfo object back to the window\r\n    if (mainWindow) {\r\n      mainWindow.webContents.send('db-info-update', dbInfo);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n//initialize the file importer\r\nconst FileImporter = require('./file-importer');\r\nconst fileImporter = new FileImporter();\r\nfileImporter.addListener('import-start', uuid => {\r\n  log.debug(`Saw import begin for file ${uuid}`);\r\n  if (mainWindow) {\r\n    mainWindow.webContents.send('import-start', uuid);\r\n  }\r\n});\r\n\r\nfileImporter.addListener('import-complete', uuid => {\r\n  log.debug(`Saw import complete for file ${uuid}`);\r\n  if (mainWindow) {\r\n    mainWindow.webContents.send('import-complete', uuid);\r\n  }\r\n});\r\n\r\nfileImporter.addListener('import-progress', (uuid, progress) => {\r\n  log.debug(`Saw import progress for file ${uuid}, ${progress}`);\r\n  if (mainWindow) {\r\n    mainWindow.webContents.send('import-progress', uuid, progress);\r\n  }\r\n});\r\n\r\nfileImporter.addListener('import-removed', uuid => {\r\n  log.debug(`Saw import removed for file ${uuid}`)\r\n  if (mainWindow) {\r\n    mainWindow.webContents.send('import-removed', uuid);\r\n  }\r\n});\r\n\r\nfileImporter.addListener('import-failed', (uuid, err) => {\r\n  let errMsg = \"Unable to import\"\r\n  let errDetails = err;\r\n  //try to give the client some useful details of why this import failed\r\n  if (err.constructor.name = 'Error') {\r\n    if (err.message) errDetails = err.message;\r\n    //tack on the specific odbc error if possible\r\n    if (err.odbcErrors != null && err.odbcErrors.length > 0) {\r\n      for (var i = 0; i < err.odbcErrors.length; i++) {\r\n        let odbErr = err.odbcErrors[i];\r\n        errDetails = `${errDetails}\\n\\nODBC Error code ${odbErr.code}: ${odbErr.message}`;\r\n      }\r\n    }\r\n    if (err.errorRow) {\r\n      errDetails = `${errDetails}\\n\\nRow that generated error: ${err.errorRow}`;\r\n    }\r\n    if (err.lastRowImported) {\r\n      errDetails = `${errDetails}\\n\\nLast row successfully imported ${err.lastRowImported}`;\r\n    }\r\n  }\r\n  log.debug(`Saw import failed for file ${uuid}`)\r\n  if (mainWindow) {\r\n    mainWindow.webContents.send('import-failed', uuid, errMsg, errDetails);\r\n  }\r\n});\r\n\r\nfileImporter.beginImport();\r\n\r\n\r\nipcMain.on('add-import-file', (e, importFile) => {\r\n  log.info(`Adding file to import ${importFile.path}`);\r\n  //todo add the import file to the queue and process\r\n  fileImporter.addImport(importFile);\r\n});\r\n\r\nipcMain.on('cancel-import-file', (e, uuid) => {\r\n  //todo check if the import can be cancelled, then cancel\r\n  fileImporter.cancelImport(uuid);\r\n});\r\n\r\nipcMain.on('select-backup-path', (e) => {\r\n  let dialog = require('electron').dialog;\r\n  const results = dialog.showOpenDialogSync(mainWindow, {properties: ['openDirectory']});\r\n  e.returnValue = results;\r\n});\r\n\r\nipcMain.on('do-update', () => {\r\n  autoUpdater.quitAndInstall();\r\n});\r\n\r\n\r\n//watch for new lines on the log and notify the main window\r\nlet Tail = require('nodejs-tail');\r\nlet logFile = log.transports.file.getFile().path;\r\nlet tail = new Tail(logFile);\r\ntail.on('line', line => {\r\n  if (mainWindow) {\r\n    mainWindow.webContents.send('log-line', line);\r\n  }\r\n});\r\ntail.watch();\r\n","/**\n * Convert a typed array to a Buffer without a copy\n *\n * Author:   Feross Aboukhadijeh <https://feross.org>\n * License:  MIT\n *\n * `npm install typedarray-to-buffer`\n */\n\nvar isTypedArray = require('is-typedarray').strict\n\nmodule.exports = function typedarrayToBuffer (arr) {\n  if (isTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer)\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)\n    }\n    return buf\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr)\n  }\n}\n","'use strict'\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\nmodule.exports._cleanupOnExit = cleanupOnExit\n\nconst fs = require('fs')\nconst MurmurHash3 = require('imurmurhash')\nconst onExit = require('signal-exit')\nconst path = require('path')\nconst isTypedArray = require('is-typedarray')\nconst typedArrayToBuffer = require('typedarray-to-buffer')\nconst { promisify } = require('util')\nconst activeFiles = {}\n\n// if we run inside of a worker_thread, `process.pid` is not unique\n/* istanbul ignore next */\nconst threadId = (function getId () {\n  try {\n    const workerThreads = require('worker_threads')\n\n    /// if we are in main thread, this is set to `0`\n    return workerThreads.threadId\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0\n  }\n})()\n\nlet invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(threadId))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction cleanupOnExit (tmpfile) {\n  return () => {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)\n    } catch (_) {}\n  }\n}\n\nfunction serializeActiveFile (absoluteName) {\n  return new Promise(resolve => {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = []\n\n    activeFiles[absoluteName].push(resolve) // add this job to the queue\n    if (activeFiles[absoluteName].length === 1) resolve() // kick off the first one\n  })\n}\n\n// https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342\nfunction isChownErrOk (err) {\n  if (err.code === 'ENOSYS') {\n    return true\n  }\n\n  const nonroot = !process.getuid || process.getuid() !== 0\n  if (nonroot) {\n    if (err.code === 'EINVAL' || err.code === 'EPERM') {\n      return true\n    }\n  }\n\n  return false\n}\n\nasync function writeFileAsync (filename, data, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  let fd\n  let tmpfile\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n  const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))\n  const absoluteName = path.resolve(filename)\n\n  try {\n    await serializeActiveFile(absoluteName)\n    const truename = await promisify(fs.realpath)(filename).catch(() => filename)\n    tmpfile = getTmpname(truename)\n\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      const stats = await promisify(fs.stat)(truename).catch(() => {})\n      if (stats) {\n        if (options.mode == null) {\n          options.mode = stats.mode\n        }\n\n        if (options.chown == null && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      }\n    }\n\n    fd = await promisify(fs.open)(tmpfile, 'w', options.mode)\n    if (options.tmpfileCreated) {\n      await options.tmpfileCreated(tmpfile)\n    }\n    if (isTypedArray(data)) {\n      data = typedArrayToBuffer(data)\n    }\n    if (Buffer.isBuffer(data)) {\n      await promisify(fs.write)(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n\n    if (options.fsync !== false) {\n      await promisify(fs.fsync)(fd)\n    }\n\n    await promisify(fs.close)(fd)\n    fd = null\n\n    if (options.chown) {\n      await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      })\n    }\n\n    if (options.mode) {\n      await promisify(fs.chmod)(tmpfile, options.mode).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      })\n    }\n\n    await promisify(fs.rename)(tmpfile, truename)\n  } finally {\n    if (fd) {\n      await promisify(fs.close)(fd).catch(\n        /* istanbul ignore next */\n        () => {}\n      )\n    }\n    removeOnExitHandler()\n    await promisify(fs.unlink)(tmpfile).catch(() => {})\n    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0]() // start next job if one is pending\n    } else delete activeFiles[absoluteName]\n  }\n}\n\nfunction writeFile (filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options\n    options = {}\n  }\n\n  const promise = writeFileAsync(filename, data, options)\n  if (callback) {\n    promise.then(callback, callback)\n  }\n\n  return promise\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (typeof options === 'string') options = { encoding: options }\n  else if (!options) options = {}\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  const tmpfile = getTmpname(filename)\n\n  if (!options.mode || !options.chown) {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    try {\n      const stats = fs.statSync(filename)\n      options = Object.assign({}, options)\n      if (!options.mode) {\n        options.mode = stats.mode\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n    } catch (ex) {\n      // ignore stat errors\n    }\n  }\n\n  let fd\n  const cleanup = cleanupOnExit(tmpfile)\n  const removeOnExitHandler = onExit(cleanup)\n\n  let threw = true\n  try {\n    fd = fs.openSync(tmpfile, 'w', options.mode || 0o666)\n    if (options.tmpfileCreated) {\n      options.tmpfileCreated(tmpfile)\n    }\n    if (isTypedArray(data)) {\n      data = typedArrayToBuffer(data)\n    }\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd)\n    }\n\n    fs.closeSync(fd)\n    fd = null\n\n    if (options.chown) {\n      try {\n        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      }\n    }\n\n    if (options.mode) {\n      try {\n        fs.chmodSync(tmpfile, options.mode)\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      }\n    }\n\n    fs.renameSync(tmpfile, filename)\n    threw = false\n  } finally {\n    if (fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (ex) {\n        // ignore close errors at this stage, error may have closed fd already.\n      }\n    }\n    removeOnExitHandler()\n    if (threw) {\n      cleanup()\n    }\n  }\n}\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","module.exports = require(\"assert\");","module.exports = require(\"child_process\");","module.exports = require(\"constants\");","module.exports = require(\"crypto\");","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"fs/promises\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"querystring\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"worker_threads\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(__webpack_require__.s = \"./src/main.ts\");\n",""],"names":[],"sourceRoot":""}